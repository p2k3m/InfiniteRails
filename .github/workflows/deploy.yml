name: Deploy to AWS

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    name: Build & Deploy
    runs-on: ubuntu-latest
    outputs:
      cloudfront_distribution_id: ${{ steps.ensure_distribution.outputs.distribution-id }}
      cloudfront_url: ${{ steps.ensure_distribution.outputs.distribution-domain }}
      deployment_url: ${{ steps.finalize.outputs.deployment-url }}
    steps:
      - name: Validate AWS secrets
        id: validate
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.AWS_CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          set -euo pipefail
          missing=()
          for var in AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_REGION AWS_S3_BUCKET AWS_CLOUDFRONT_DISTRIBUTION_ID; do
            if [ -z "${!var:-}" ]; then
              missing+=("$var")
            fi
          done
          if [ ${#missing[@]} -gt 0 ]; then
            printf '::error::Missing required GitHub secret(s): %s' "${missing[*]}"
            {
              echo '### âŒ Deployment blocked'
              echo ''
              echo 'The workflow cannot continue because the following secrets are missing:'
              for name in "${missing[@]}"; do
                echo "- \`${name}\`"
              done
              echo ''
              echo '#### How to fix'
              echo '1. Open **Settings â†’ Secrets and variables â†’ Actions** in this repository.'
              echo '2. Create each secret listed above with the exact name.'
              echo '3. Re-run the workflow from the Actions tab once the secrets are saved.'
            } >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Validate asset manifest coverage
        run: node scripts/validate-asset-manifest.js

      - name: Sync site to S3
        env:
          DEPLOY_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail
          if [ -z "${DEPLOY_BUCKET}" ]; then
            echo '::error::AWS_S3_BUCKET secret resolved to an empty string. Ensure the secret contains the bucket name.'
            exit 1
          fi

          if ! OUTPUT=$(aws s3api head-bucket --bucket "${DEPLOY_BUCKET}" 2>&1); then
            STATUS=$?
            if echo "${OUTPUT}" | grep -q '(404)'; then
              CREATE_ARGS=(--bucket "${DEPLOY_BUCKET}")
              if [ -n "${AWS_REGION:-}" ] && [ "${AWS_REGION}" != "us-east-1" ]; then
                CREATE_ARGS+=(--create-bucket-configuration "LocationConstraint=${AWS_REGION}")
              fi
              aws s3api create-bucket "${CREATE_ARGS[@]}"
              aws s3api wait bucket-exists --bucket "${DEPLOY_BUCKET}"
              {
                echo '### ðŸª£ Created deployment bucket'
                echo ''
                echo "- Bucket: \`${DEPLOY_BUCKET}\`"
                if [ -n "${AWS_REGION:-}" ]; then
                  echo "- Region: \`${AWS_REGION}\`"
                fi
              } >> "$GITHUB_STEP_SUMMARY"
            elif echo "${OUTPUT}" | grep -q '(301)'; then
              echo "::error::S3 bucket ${DEPLOY_BUCKET} exists in a different region. Set AWS_S3_BUCKET to a bucket in ${AWS_REGION:-your configured region} or update the AWS_REGION secret to match the bucket's location."
              exit 1
            elif echo "${OUTPUT}" | grep -qi 'AccessDenied'; then
              echo "::error::Access denied when checking bucket ${DEPLOY_BUCKET}. Confirm that the IAM user has s3:HeadBucket permissions."
              exit 1
            else
              echo "::error::Failed to access S3 bucket ${DEPLOY_BUCKET}. AWS CLI exited with status ${STATUS}. Output: ${OUTPUT}"
              exit 1
            fi
          fi

          aws s3 sync . "s3://${DEPLOY_BUCKET}" \
            --delete \
            --exclude "*" \
            --include "index.html" \
            --include "styles.css" \
            --include "asset-resolver.js" \
            --include "audio-aliases.js" \
            --include "audio-captions.js" \
            --include "combat-utils.js" \
            --include "crafting.js" \
            --include "script.js" \
            --include "simple-experience.js" \
            --include "portal-mechanics.js" \
            --include "scoreboard-utils.js" \
            --include "assets/**" \
            --include "textures/**" \
            --include "vendor/*"

      - name: Configure bucket access policy
        env:
          DEPLOY_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail
          if [ -z "${DEPLOY_BUCKET}" ]; then
            echo '::error::Deployment bucket name is empty. Ensure AWS_S3_BUCKET is set.'
            exit 1
          fi

          ORIGIN_CLASSIC="${DEPLOY_BUCKET}.s3.amazonaws.com"
          ORIGIN_REGIONAL="${DEPLOY_BUCKET}.s3.${AWS_REGION}.amazonaws.com"
          ORIGIN_WEBSITE="${DEPLOY_BUCKET}.s3-website-${AWS_REGION}.amazonaws.com"
          OAI_ID=""

          MATCH=$(aws cloudfront list-distributions --query "DistributionList.Items[?Origins.Items[?DomainName=='${ORIGIN_CLASSIC}' || DomainName=='${ORIGIN_REGIONAL}' || DomainName=='${ORIGIN_WEBSITE}']]|[0]")
          if [ -n "${MATCH}" ] && [ "${MATCH}" != "null" ]; then
            OAI_PATH=$(echo "${MATCH}" | jq -r \
              --arg classic "${ORIGIN_CLASSIC}" \
              --arg regional "${ORIGIN_REGIONAL}" \
              --arg website "${ORIGIN_WEBSITE}" \
              '.Origins.Items[] | select(.DomainName == $classic or .DomainName == $regional or .DomainName == $website) | .S3OriginConfig.OriginAccessIdentity // empty' | head -n 1)
            if [ -n "${OAI_PATH}" ] && [ "${OAI_PATH}" != "null" ]; then
              OAI_ID="${OAI_PATH##*/}"
            fi
          fi

          POLICY_FILE=$(mktemp)

          if [ -n "${OAI_ID}" ]; then
            aws s3api put-public-access-block \
              --bucket "${DEPLOY_BUCKET}" \
              --public-access-block-configuration BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=false,RestrictPublicBuckets=false

            jq -n \
              --arg bucket "${DEPLOY_BUCKET}" \
              --arg oai "${OAI_ID}" \
              '{
                Version: "2012-10-17",
                Statement: [
                  {
                    Sid: "AllowCloudFrontOAIRead",
                    Effect: "Allow",
                    Principal: {
                      AWS: ("arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity " + $oai)
                    },
                    Action: "s3:GetObject",
                    Resource: [
                      ("arn:aws:s3:::" + $bucket + "/index.html"),
                      ("arn:aws:s3:::" + $bucket + "/styles.css"),
                      ("arn:aws:s3:::" + $bucket + "/asset-resolver.js"),
                      ("arn:aws:s3:::" + $bucket + "/audio-aliases.js"),
                      ("arn:aws:s3:::" + $bucket + "/audio-captions.js"),
                      ("arn:aws:s3:::" + $bucket + "/combat-utils.js"),
                      ("arn:aws:s3:::" + $bucket + "/crafting.js"),
                      ("arn:aws:s3:::" + $bucket + "/portal-mechanics.js"),
                      ("arn:aws:s3:::" + $bucket + "/scoreboard-utils.js"),
                      ("arn:aws:s3:::" + $bucket + "/script.js"),
                      ("arn:aws:s3:::" + $bucket + "/simple-experience.js"),
                      ("arn:aws:s3:::" + $bucket + "/assets/*"),
                      ("arn:aws:s3:::" + $bucket + "/textures/*"),
                      ("arn:aws:s3:::" + $bucket + "/vendor/*")
                    ]
                  }
                ]
              }' > "${POLICY_FILE}"

            ACCESS_MODE="CloudFront OAI (${OAI_ID})"
          else
            echo '::warning::No CloudFront Origin Access Identity is attached to the distribution. Falling back to a public read bucket policy.'
            aws s3api put-public-access-block \
              --bucket "${DEPLOY_BUCKET}" \
              --public-access-block-configuration BlockPublicAcls=false,IgnorePublicAcls=false,BlockPublicPolicy=false,RestrictPublicBuckets=false

            jq -n \
              --arg bucket "${DEPLOY_BUCKET}" \
              '{
                Version: "2012-10-17",
                Statement: [
                  {
                    Sid: "AllowPublicRead",
                    Effect: "Allow",
                    Principal: "*",
                    Action: "s3:GetObject",
                    Resource: ("arn:aws:s3:::" + $bucket + "/*")
                  }
                ]
              }' > "${POLICY_FILE}"

            ACCESS_MODE="Public read"
          fi

          aws s3api put-bucket-policy --bucket "${DEPLOY_BUCKET}" --policy "file://${POLICY_FILE}"
          rm -f "${POLICY_FILE}"

          {
            echo '### ðŸ“„ Configured bucket access'
            echo ''
            echo "- Bucket: \`${DEPLOY_BUCKET}\`"
            echo "- Access: ${ACCESS_MODE}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Ensure CloudFront distribution
        id: ensure_distribution
        env:
          DEPLOY_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.AWS_CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          set -euo pipefail
          ORIGIN_CLASSIC="${DEPLOY_BUCKET}.s3.amazonaws.com"
          ORIGIN_REGIONAL="${DEPLOY_BUCKET}.s3.${AWS_REGION}.amazonaws.com"
          ORIGIN_WEBSITE="${DEPLOY_BUCKET}.s3-website-${AWS_REGION}.amazonaws.com"
          if [ -n "${CLOUDFRONT_DISTRIBUTION_ID:-}" ]; then
            if ! DISTRIBUTION_OUTPUT=$(aws cloudfront get-distribution --id "${CLOUDFRONT_DISTRIBUTION_ID}" 2>&1); then
              echo "::error::Failed to fetch CloudFront distribution ${CLOUDFRONT_DISTRIBUTION_ID}. AWS CLI output: ${DISTRIBUTION_OUTPUT}"
              exit 1
            fi

            CF_DOMAIN=$(echo "${DISTRIBUTION_OUTPUT}" | jq -r '.Distribution.DomainName // empty')
            if [ -z "${CF_DOMAIN}" ]; then
              echo '::error::CloudFront distribution response did not include a DomainName.'
              exit 1
            fi

            ORIGIN_MATCH=0
            while IFS= read -r origin; do
              if [ "${origin}" = "${ORIGIN_CLASSIC}" ] || [ "${origin}" = "${ORIGIN_REGIONAL}" ] || [ "${origin}" = "${ORIGIN_WEBSITE}" ]; then
                ORIGIN_MATCH=1
                break
              fi
            done < <(echo "${DISTRIBUTION_OUTPUT}" | jq -r '.Distribution.DistributionConfig.Origins.Items[].DomainName // empty')

            if [ "${ORIGIN_MATCH}" -ne 1 ]; then
              echo "::error::CloudFront distribution ${CLOUDFRONT_DISTRIBUTION_ID} does not reference the ${DEPLOY_BUCKET} bucket. Update the secret or attach the bucket as an origin."
              exit 1
            fi

            echo "distribution-id=${CLOUDFRONT_DISTRIBUTION_ID}" >> "$GITHUB_OUTPUT"
            echo "distribution-domain=https://${CF_DOMAIN}" >> "$GITHUB_OUTPUT"

            {
              echo '### âœ… CloudFront distribution verified'
              echo ''
              echo "- **Distribution ID**: \`${CLOUDFRONT_DISTRIBUTION_ID}\`"
              echo "- **CloudFront URL**: https://${CF_DOMAIN}"
            } >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi
          MATCH=$(aws cloudfront list-distributions --query "DistributionList.Items[?Origins.Items[?DomainName=='${ORIGIN_CLASSIC}' || DomainName=='${ORIGIN_REGIONAL}' || DomainName=='${ORIGIN_WEBSITE}']]|[0]")
          if [ -n "$MATCH" ] && [ "$MATCH" != "null" ]; then
            CF_ID=$(echo "$MATCH" | jq -r '.Id // empty')
            CF_DOMAIN=$(echo "$MATCH" | jq -r '.DomainName // empty')
            if [ -z "$CF_ID" ] || [ -z "$CF_DOMAIN" ]; then
              echo '::error::CloudFront distribution is missing an Id or DomainName. Inspect the AWS console.'
              exit 1
            fi

            CURRENT_ORIGIN=$(echo "$MATCH" | jq -r '.Origins.Items[0].DomainName // empty')
            if [ "$CURRENT_ORIGIN" = "$ORIGIN_WEBSITE" ]; then
              echo '::notice::Updating CloudFront distribution to use the S3 REST endpoint.'
              CONFIG_OUTPUT=$(aws cloudfront get-distribution-config --id "$CF_ID")
              ETAG=$(echo "$CONFIG_OUTPUT" | jq -r '.ETag // empty')
              if [ -z "$ETAG" ]; then
                echo '::error::Failed to read distribution ETag.'
                exit 1
              fi

              ORIGIN_ID="S3-${DEPLOY_BUCKET}"
              ORIGIN_ID_OLD="S3-${DEPLOY_BUCKET}-website"
              UPDATED_CONFIG=$(echo "$CONFIG_OUTPUT" | jq -r '.DistributionConfig' | jq \
                --arg domain "$ORIGIN_REGIONAL" \
                --arg origin_id "$ORIGIN_ID" \
                --arg origin_id_old "$ORIGIN_ID_OLD" \
                --arg website "$ORIGIN_WEBSITE" \
                '
                  .Origins.Items = (.Origins.Items | map(
                    if (.Id == $origin_id_old) or (.DomainName == $website) then
                      (.Id = $origin_id
                       | .DomainName = $domain
                       | .S3OriginConfig = { OriginAccessIdentity: "" }
                       | del(.CustomOriginConfig))
                    else
                      .
                    end
                  ))
                  | .Origins.Quantity = (.Origins.Items | length)
                  | .DefaultCacheBehavior.TargetOriginId =
                      (if .DefaultCacheBehavior.TargetOriginId == $origin_id_old then $origin_id else .DefaultCacheBehavior.TargetOriginId end)
                  | if .CacheBehaviors? and (.CacheBehaviors.Items | length) > 0 then
                      .CacheBehaviors.Items = (.CacheBehaviors.Items | map(
                        if .TargetOriginId == $origin_id_old then
                          .TargetOriginId = $origin_id
                        else
                          .
                        end
                      ))
                    else
                      .
                    end
                ')

              TMP_CONFIG=$(mktemp)
              echo "$UPDATED_CONFIG" > "$TMP_CONFIG"
              aws cloudfront update-distribution --id "$CF_ID" --if-match "$ETAG" --distribution-config "file://${TMP_CONFIG}"
              rm -f "$TMP_CONFIG"
              aws cloudfront wait distribution-deployed --id "$CF_ID"
            fi

            echo "distribution-id=${CF_ID}" >> "$GITHUB_OUTPUT"
            echo "distribution-domain=https://${CF_DOMAIN}" >> "$GITHUB_OUTPUT"
            {
              echo '### âœ… CloudFront distribution detected'
              echo ''
              echo "- **Distribution ID**: \`${CF_ID}\`"
              echo "- **CloudFront URL**: https://${CF_DOMAIN}"
            } >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          CALLER_REFERENCE="infinite-rails-${DEPLOY_BUCKET}-$(date +%s)"
          CONFIG_FILE=$(mktemp)
          cat >"${CONFIG_FILE}" <<JSON
          {
            "CallerReference": "${CALLER_REFERENCE}",
            "Comment": "Infinite Rails static site for bucket ${DEPLOY_BUCKET}",
            "Enabled": true,
            "PriceClass": "PriceClass_All",
            "Origins": {
              "Quantity": 1,
              "Items": [
                {
                  "Id": "S3-${DEPLOY_BUCKET}",
                  "DomainName": "${ORIGIN_REGIONAL}",
                  "S3OriginConfig": {
                    "OriginAccessIdentity": ""
                  }
                }
              ]
            },
            "DefaultRootObject": "index.html",
            "DefaultCacheBehavior": {
              "TargetOriginId": "S3-${DEPLOY_BUCKET}",
              "ViewerProtocolPolicy": "redirect-to-https",
              "AllowedMethods": {
                "Quantity": 2,
                "Items": ["GET", "HEAD"],
                "CachedMethods": {
                  "Quantity": 2,
                  "Items": ["GET", "HEAD"]
                }
              },
              "Compress": true,
              "CachePolicyId": "658327ea-f89d-4fab-a63d-7e88639e58f6"
            }
          }
          JSON

          CREATE_OUTPUT=$(aws cloudfront create-distribution --distribution-config "file://${CONFIG_FILE}")
          rm -f "${CONFIG_FILE}"

          CF_ID=$(echo "$CREATE_OUTPUT" | jq -r '.Distribution.Id // empty')
          CF_DOMAIN=$(echo "$CREATE_OUTPUT" | jq -r '.Distribution.DomainName // empty')
          if [ -z "$CF_ID" ] || [ -z "$CF_DOMAIN" ]; then
            echo '::error::Failed to parse CloudFront distribution details from creation response.'
            exit 1
          fi

          aws cloudfront wait distribution-deployed --id "$CF_ID"

          echo "distribution-id=${CF_ID}" >> "$GITHUB_OUTPUT"
          echo "distribution-domain=https://${CF_DOMAIN}" >> "$GITHUB_OUTPUT"

          {
            echo '### ðŸš€ Created CloudFront distribution'
            echo ''
            echo "- **Distribution ID**: \`${CF_ID}\`"
            echo "- **CloudFront URL**: https://${CF_DOMAIN}"
            echo "- **Origin**: ${ORIGIN_REGIONAL}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Invalidate CloudFront cache
        env:
          DISTRIBUTION_ID: ${{ steps.ensure_distribution.outputs.distribution-id || secrets.AWS_CLOUDFRONT_DISTRIBUTION_ID || '' }}
        run: |
          set -euo pipefail
          if [ -z "${DISTRIBUTION_ID}" ]; then
            echo '::error::CloudFront distribution ID is empty. Set AWS_CLOUDFRONT_DISTRIBUTION_ID or ensure the discovery step locates the distribution before retrying.'
            exit 1
          fi
          MAX_ATTEMPTS=5
          BASE_DELAY=5
          ATTEMPT=1
          INVALIDATION_OUTPUT=""
          INVALIDATION_ID=""

          while [ "${ATTEMPT}" -le "${MAX_ATTEMPTS}" ]; do
            if INVALIDATION_OUTPUT=$(aws cloudfront create-invalidation --distribution-id "$DISTRIBUTION_ID" --paths '/*' 2>&1); then
              INVALIDATION_ID=$(echo "${INVALIDATION_OUTPUT}" | jq -r '.Invalidation.Id // empty')
              break
            fi

            STATUS=$?
            if echo "${INVALIDATION_OUTPUT}" | grep -qi 'Throttling' && [ "${ATTEMPT}" -lt "${MAX_ATTEMPTS}" ]; then
              SLEEP_DURATION=$((BASE_DELAY * 2 ** (ATTEMPT - 1)))
              echo "::warning::CloudFront invalidation throttled (attempt ${ATTEMPT}/${MAX_ATTEMPTS}). Retrying in ${SLEEP_DURATION}s."
              sleep "${SLEEP_DURATION}"
              ATTEMPT=$((ATTEMPT + 1))
              continue
            fi

            echo "::error::Failed to create CloudFront invalidation after ${ATTEMPT} attempt(s). AWS CLI exited with status ${STATUS}. Output: ${INVALIDATION_OUTPUT}"
            exit "${STATUS}"
          done

          if [ -z "${INVALIDATION_ID}" ]; then
            echo '::warning::Cache invalidation request completed but no ID was returned.'
          else
            echo "::notice::Submitted CloudFront invalidation ${INVALIDATION_ID}"

            echo "Waiting for CloudFront invalidation ${INVALIDATION_ID} to complete..."
            aws cloudfront wait invalidation-completed \
              --distribution-id "${DISTRIBUTION_ID}" \
              --id "${INVALIDATION_ID}"

            {
              echo '### ðŸ§¹ CloudFront cache flushed'
              echo ''
              echo "- Distribution ID: \`${DISTRIBUTION_ID}\`"
              echo "- Invalidation ID: \`${INVALIDATION_ID}\`"
              echo "- Paths: \`/*\`"
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Announce deployment URL
        env:
          DISTRIBUTION_DOMAIN: ${{ steps.ensure_distribution.outputs.distribution-domain }}
          DISTRIBUTION_ID: ${{ steps.ensure_distribution.outputs.distribution-id }}
          DEPLOY_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail
          if [ -n "${DISTRIBUTION_DOMAIN:-}" ]; then
            echo "::notice::Deployment available at ${DISTRIBUTION_DOMAIN}"
            {
              echo '### ðŸŒ Play the latest build'
              echo ''
              echo "- CloudFront URL: ${DISTRIBUTION_DOMAIN}"
              echo "- Distribution ID: \`${DISTRIBUTION_ID}\`"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            S3_CONSOLE_URL="https://s3.console.aws.amazon.com/s3/buckets/${DEPLOY_BUCKET}?region=${AWS_REGION}&tab=objects"
            echo "::notice::Deployment synced to s3://${DEPLOY_BUCKET}. Configure CloudFront for a CDN URL."
            {
              echo '### ðŸ“¦ Site uploaded to S3'
              echo ''
              echo "- Bucket: \`${DEPLOY_BUCKET}\`"
              echo "- Region: \`${AWS_REGION}\`"
              echo "- AWS Console: ${S3_CONSOLE_URL}"
              echo ''
              echo 'Add a CloudFront distribution to get a global CDN URL and automatic cache invalidations.'
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Finalize deployment outputs
        id: finalize
        env:
          DISTRIBUTION_DOMAIN: ${{ steps.ensure_distribution.outputs.distribution-domain }}
          DEPLOY_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail
          if [ -n "${DISTRIBUTION_DOMAIN:-}" ]; then
            echo "deployment-url=${DISTRIBUTION_DOMAIN}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -z "${DEPLOY_BUCKET}" ]; then
            echo '::warning::Unable to compute deployment URL because the bucket name is empty.'
            echo 'deployment-url=' >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "${AWS_REGION:-}" ]; then
            echo "deployment-url=https://${DEPLOY_BUCKET}.s3.${AWS_REGION}.amazonaws.com/index.html" >> "$GITHUB_OUTPUT"
          else
            echo "deployment-url=https://${DEPLOY_BUCKET}.s3.amazonaws.com/index.html" >> "$GITHUB_OUTPUT"
          fi
