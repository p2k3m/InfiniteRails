name: Deploy to AWS

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    name: Build & Deploy
    runs-on: ubuntu-latest
    outputs:
      cloudfront_distribution_id: ${{ steps.ensure_distribution.outputs.distribution-id }}
      cloudfront_url: ${{ steps.ensure_distribution.outputs.distribution-domain }}
    steps:
      - name: Validate AWS secrets
        id: validate
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
        run: |
          set -euo pipefail
          missing=()
          for var in AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_REGION AWS_S3_BUCKET; do
            if [ -z "${!var:-}" ]; then
              missing+=("$var")
            fi
          done
          if [ ${#missing[@]} -gt 0 ]; then
            printf '::error::Missing required GitHub secret(s): %s' "${missing[*]}"
            {
              echo '### ❌ Deployment blocked'
              echo ''
              echo 'The workflow cannot continue because the following secrets are missing:'
              for name in "${missing[@]}"; do
                echo "- \`${name}\`"
              done
              echo ''
              echo '#### How to fix'
              echo '1. Open **Settings → Secrets and variables → Actions** in this repository.'
              echo '2. Create each secret listed above with the exact name.'
              echo '3. Re-run the workflow from the Actions tab once the secrets are saved.'
            } >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Sync site to S3
        env:
          DEPLOY_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail
          if [ -z "${DEPLOY_BUCKET}" ]; then
            echo '::error::AWS_S3_BUCKET secret resolved to an empty string. Ensure the secret contains the bucket name.'
            exit 1
          fi

          if ! OUTPUT=$(aws s3api head-bucket --bucket "${DEPLOY_BUCKET}" 2>&1); then
            STATUS=$?
            if echo "${OUTPUT}" | grep -q '(404)'; then
              CREATE_ARGS=(--bucket "${DEPLOY_BUCKET}")
              if [ -n "${AWS_REGION:-}" ] && [ "${AWS_REGION}" != "us-east-1" ]; then
                CREATE_ARGS+=(--create-bucket-configuration "LocationConstraint=${AWS_REGION}")
              fi
              aws s3api create-bucket "${CREATE_ARGS[@]}"
              aws s3api wait bucket-exists --bucket "${DEPLOY_BUCKET}"
              {
                echo '### 🪣 Created deployment bucket'
                echo ''
                echo "- Bucket: \`${DEPLOY_BUCKET}\`"
                if [ -n "${AWS_REGION:-}" ]; then
                  echo "- Region: \`${AWS_REGION}\`"
                fi
              } >> "$GITHUB_STEP_SUMMARY"
            elif echo "${OUTPUT}" | grep -q '(301)'; then
              echo "::error::S3 bucket ${DEPLOY_BUCKET} exists in a different region. Set AWS_S3_BUCKET to a bucket in ${AWS_REGION:-your configured region} or update the AWS_REGION secret to match the bucket's location."
              exit 1
            elif echo "${OUTPUT}" | grep -qi 'AccessDenied'; then
              echo "::error::Access denied when checking bucket ${DEPLOY_BUCKET}. Confirm that the IAM user has s3:HeadBucket permissions."
              exit 1
            else
              echo "::error::Failed to access S3 bucket ${DEPLOY_BUCKET}. AWS CLI exited with status ${STATUS}. Output: ${OUTPUT}"
              exit 1
            fi
          fi

          aws s3 sync . "s3://${DEPLOY_BUCKET}" --delete --exclude ".git/*" --exclude ".github/*" --exclude "README.md" --exclude "LICENSE"

      - name: Configure S3 static website hosting
        env:
          DEPLOY_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail
          if [ -z "${DEPLOY_BUCKET}" ]; then
            echo '::error::Deployment bucket name is empty. Ensure AWS_S3_BUCKET is set.'
            exit 1
          fi

          aws s3api put-public-access-block \
            --bucket "${DEPLOY_BUCKET}" \
            --public-access-block-configuration BlockPublicAcls=false,IgnorePublicAcls=false,BlockPublicPolicy=false,RestrictPublicBuckets=false

          aws s3 website "s3://${DEPLOY_BUCKET}/" --index-document index.html --error-document index.html

          POLICY_FILE=$(mktemp)
          cat >"${POLICY_FILE}" <<POLICY
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Sid": "AllowPublicRead",
                "Effect": "Allow",
                "Principal": "*",
                "Action": "s3:GetObject",
                "Resource": "arn:aws:s3:::${DEPLOY_BUCKET}/*"
              }
            ]
          }
          POLICY

          aws s3api put-bucket-policy --bucket "${DEPLOY_BUCKET}" --policy "file://${POLICY_FILE}"
          rm -f "${POLICY_FILE}"

          {
            echo '### 🌐 Enabled static website hosting'
            echo ''
            echo "- Bucket: \`${DEPLOY_BUCKET}\`"
            echo "- Index document: \`index.html\`"
            echo "- Error document: \`index.html\`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Ensure CloudFront distribution
        id: ensure_distribution
        env:
          DEPLOY_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail
          ORIGIN_CLASSIC="${DEPLOY_BUCKET}.s3.amazonaws.com"
          ORIGIN_REGIONAL="${DEPLOY_BUCKET}.s3.${AWS_REGION}.amazonaws.com"
          ORIGIN_WEBSITE="${DEPLOY_BUCKET}.s3-website-${AWS_REGION}.amazonaws.com"
          MATCH=$(aws cloudfront list-distributions --query "DistributionList.Items[?Origins.Items[?DomainName=='${ORIGIN_CLASSIC}' || DomainName=='${ORIGIN_REGIONAL}' || DomainName=='${ORIGIN_WEBSITE}']]|[0]")
          if [ -n "$MATCH" ] && [ "$MATCH" != "null" ]; then
            CF_ID=$(echo "$MATCH" | jq -r '.Id // empty')
            CF_DOMAIN=$(echo "$MATCH" | jq -r '.DomainName // empty')
            if [ -z "$CF_ID" ] || [ -z "$CF_DOMAIN" ]; then
              echo '::error::CloudFront distribution is missing an Id or DomainName. Inspect the AWS console.'
              exit 1
            fi
            echo "distribution-id=${CF_ID}" >> "$GITHUB_OUTPUT"
            echo "distribution-domain=https://${CF_DOMAIN}" >> "$GITHUB_OUTPUT"
            {
              echo '### ✅ CloudFront distribution detected'
              echo ''
              echo "- **Distribution ID**: \`${CF_ID}\`"
              echo "- **CloudFront URL**: https://${CF_DOMAIN}"
            } >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          CALLER_REFERENCE="infinite-rails-${DEPLOY_BUCKET}-$(date +%s)"
          CONFIG_FILE=$(mktemp)
          cat >"${CONFIG_FILE}" <<JSON
          {
            "CallerReference": "${CALLER_REFERENCE}",
            "Comment": "Infinite Rails static site for bucket ${DEPLOY_BUCKET}",
            "Enabled": true,
            "PriceClass": "PriceClass_All",
            "Origins": {
              "Quantity": 1,
              "Items": [
                {
                  "Id": "S3-${DEPLOY_BUCKET}-website",
                  "DomainName": "${ORIGIN_WEBSITE}",
                  "CustomOriginConfig": {
                    "HTTPPort": 80,
                    "HTTPSPort": 443,
                    "OriginProtocolPolicy": "http-only",
                    "OriginSslProtocols": {
                      "Quantity": 3,
                      "Items": ["TLSv1", "TLSv1.1", "TLSv1.2"]
                    }
                  }
                }
              ]
            },
            "DefaultRootObject": "index.html",
            "DefaultCacheBehavior": {
              "TargetOriginId": "S3-${DEPLOY_BUCKET}-website",
              "ViewerProtocolPolicy": "redirect-to-https",
              "AllowedMethods": {
                "Quantity": 2,
                "Items": ["GET", "HEAD"],
                "CachedMethods": {
                  "Quantity": 2,
                  "Items": ["GET", "HEAD"]
                }
              },
              "Compress": true,
              "CachePolicyId": "658327ea-f89d-4fab-a63d-7e88639e58f6"
            }
          }
          JSON

          CREATE_OUTPUT=$(aws cloudfront create-distribution --distribution-config "file://${CONFIG_FILE}")
          rm -f "${CONFIG_FILE}"

          CF_ID=$(echo "$CREATE_OUTPUT" | jq -r '.Distribution.Id // empty')
          CF_DOMAIN=$(echo "$CREATE_OUTPUT" | jq -r '.Distribution.DomainName // empty')
          if [ -z "$CF_ID" ] || [ -z "$CF_DOMAIN" ]; then
            echo '::error::Failed to parse CloudFront distribution details from creation response.'
            exit 1
          fi

          aws cloudfront wait distribution-deployed --id "$CF_ID"

          echo "distribution-id=${CF_ID}" >> "$GITHUB_OUTPUT"
          echo "distribution-domain=https://${CF_DOMAIN}" >> "$GITHUB_OUTPUT"

          {
            echo '### 🚀 Created CloudFront distribution'
            echo ''
            echo "- **Distribution ID**: \`${CF_ID}\`"
            echo "- **CloudFront URL**: https://${CF_DOMAIN}"
            echo "- **Origin**: ${ORIGIN_WEBSITE}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Invalidate CloudFront cache
        if: steps.ensure_distribution.outputs['distribution-id'] != ''
        env:
          DISTRIBUTION_ID: ${{ steps.ensure_distribution.outputs.distribution-id }}
        run: |
          set -euo pipefail
          if [ -z "${DISTRIBUTION_ID}" ]; then
            echo '::error::CloudFront distribution ID is empty. Check the discovery step output.'
            exit 1
          fi
          aws cloudfront create-invalidation --distribution-id "$DISTRIBUTION_ID" --paths '/*'

      - name: Announce deployment URL
        env:
          DISTRIBUTION_DOMAIN: ${{ steps.ensure_distribution.outputs.distribution-domain }}
          DISTRIBUTION_ID: ${{ steps.ensure_distribution.outputs.distribution-id }}
          DEPLOY_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail
          if [ -n "${DISTRIBUTION_DOMAIN:-}" ]; then
            echo "::notice::Deployment available at ${DISTRIBUTION_DOMAIN}"
            {
              echo '### 🌐 Play the latest build'
              echo ''
              echo "- CloudFront URL: ${DISTRIBUTION_DOMAIN}"
              echo "- Distribution ID: \`${DISTRIBUTION_ID}\`"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            S3_CONSOLE_URL="https://s3.console.aws.amazon.com/s3/buckets/${DEPLOY_BUCKET}?region=${AWS_REGION}&tab=objects"
            echo "::notice::Deployment synced to s3://${DEPLOY_BUCKET}. Configure CloudFront for a CDN URL."
            {
              echo '### 📦 Site uploaded to S3'
              echo ''
              echo "- Bucket: \`${DEPLOY_BUCKET}\`"
              echo "- Region: \`${AWS_REGION}\`"
              echo "- AWS Console: ${S3_CONSOLE_URL}"
              echo ''
              echo 'Add a CloudFront distribution to get a global CDN URL and automatic cache invalidations.'
            } >> "$GITHUB_STEP_SUMMARY"
          fi
