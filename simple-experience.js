(function () {
  function clamp01(value) {
    if (!Number.isFinite(value)) {
      return 0;
    }
    if (value <= 0) {
      return 0;
    }
    if (value >= 1) {
      return 1;
    }
    return value;
  }

  function normaliseHexString(hex) {
    if (typeof hex !== 'string') {
      return '';
    }
    const trimmed = hex.trim().replace(/^#/, '');
    if (trimmed.length === 3) {
      return trimmed
        .split('')
        .map((char) => char + char)
        .join('');
    }
    return trimmed;
  }

  function parseHexColor(hex, fallback) {
    const normalised = normaliseHexString(hex);
    if (normalised.length === 6) {
      const value = Number.parseInt(normalised, 16);
      if (Number.isFinite(value)) {
        return {
          r: (value >> 16) & 255,
          g: (value >> 8) & 255,
          b: value & 255,
        };
      }
    }
    return {
      r: fallback?.r ?? 0,
      g: fallback?.g ?? 0,
      b: fallback?.b ?? 0,
    };
  }

  function mixRgb(colorA, colorB, ratio) {
    const amount = clamp01(ratio);
    const inverse = 1 - amount;
    return {
      r: Math.round(colorA.r * inverse + colorB.r * amount),
      g: Math.round(colorA.g * inverse + colorB.g * amount),
      b: Math.round(colorA.b * inverse + colorB.b * amount),
    };
  }

  function rgbToCss(color) {
    return `rgb(${color.r}, ${color.g}, ${color.b})`;
  }

  function normalisePositiveInteger(value, minimum) {
    if (value === null || value === undefined) {
      return null;
    }
    const number = Number(value);
    if (!Number.isFinite(number)) {
      return null;
    }
    const truncated = Math.floor(number);
    return Math.max(minimum, truncated);
  }

  function resolveTextureRetryIntervalMs(source) {
    if (!source || typeof source !== 'object') {
      return null;
    }
    const milliseconds = normalisePositiveInteger(source.texturePackRetryIntervalMs, 1000);
    if (milliseconds !== null) {
      return milliseconds;
    }
    const seconds = normalisePositiveInteger(source.texturePackRetryIntervalSeconds, 1);
    if (seconds !== null) {
      return seconds * 1000;
    }
    return null;
  }

  const scope =
        typeof globalThis !== 'undefined'
          ? globalThis
          : typeof window !== 'undefined'
            ? window
            : typeof global !== 'undefined'
              ? global
              : null;

  const runtimeScope =
    scope && scope.window && typeof scope.window === 'object'
      ? scope.window
      : scope;

  const CONTROL_MAP_GLOBAL_KEY = '__INFINITE_RAILS_CONTROL_MAP__';
  const AUDIO_FALLBACK_SUFFIX = 'Fallback beep active until audio assets are restored.';
  const activeSimpleExperiences = new Set();

  const DEFAULT_ASSET_VERSION_TAG = '1';

  function normaliseAssetVersionTag(value) {
    if (value === null || value === undefined) {
      return '';
    }
    if (typeof value === 'number' && Number.isFinite(value)) {
      return String(value);
    }
    if (typeof value === 'string') {
      const trimmed = value.trim();
      return trimmed.length > 0 ? trimmed : '';
    }
    if (typeof value?.toString === 'function') {
      const stringified = String(value).trim();
      return stringified.length > 0 ? stringified : '';
    }
    return '';
  }

  function resolveAssetVersionTag() {
    const config = runtimeScope?.APP_CONFIG && typeof runtimeScope.APP_CONFIG === 'object'
      ? runtimeScope.APP_CONFIG
      : null;
    const configured = normaliseAssetVersionTag(config?.assetVersionTag);
    if (configured) {
      runtimeScope.INFINITE_RAILS_ASSET_VERSION_TAG = configured;
      return configured;
    }

    const ambient = normaliseAssetVersionTag(runtimeScope?.INFINITE_RAILS_ASSET_VERSION_TAG);
    if (ambient) {
      if (config) {
        config.assetVersionTag = ambient;
      }
      return ambient;
    }

    if (config) {
      config.assetVersionTag = DEFAULT_ASSET_VERSION_TAG;
    }
    if (runtimeScope) {
      runtimeScope.INFINITE_RAILS_ASSET_VERSION_TAG = DEFAULT_ASSET_VERSION_TAG;
    }
    return DEFAULT_ASSET_VERSION_TAG;
  }

  function applyAssetVersionTag(url) {
    if (typeof url !== 'string' || url.length === 0) {
      return url;
    }
    if (/^(?:data|blob):/i.test(url)) {
      return url;
    }

    const versionTag = resolveAssetVersionTag();
    if (!versionTag) {
      return url;
    }

    const [base, hash = ''] = url.split('#', 2);
    if (/(?:^|[?&])assetVersion=/.test(base)) {
      return url;
    }

    if (/^[a-z][a-z0-9+.-]*:/i.test(base)) {
      try {
        const parsed = new URL(url);
        if (!parsed.searchParams.has('assetVersion')) {
          parsed.searchParams.set('assetVersion', versionTag);
        }
        return parsed.toString();
      } catch (error) {
        // Fall through to manual handling when URL parsing fails (likely relative paths).
      }
    }

    const separator = base.includes('?') ? '&' : '?';
    const tagged = `${base}${separator}assetVersion=${encodeURIComponent(versionTag)}`;
    return hash ? `${tagged}#${hash}` : tagged;
  }

  resolveAssetVersionTag();

  const FALLBACK_PROCEDURAL_RGB = Object.freeze({
    grass: { r: 111, g: 191, b: 115 },
    cloud: { r: 229, g: 247, b: 255 },
    shadow: { r: 63, g: 122, b: 58 },
    sky: { r: 138, g: 212, b: 255 },
  });

  function buildProceduralColorSet(palette = {}) {
    return {
      grass: parseHexColor(palette.base, FALLBACK_PROCEDURAL_RGB.grass),
      cloud: parseHexColor(palette.highlight, FALLBACK_PROCEDURAL_RGB.cloud),
      shadow: parseHexColor(palette.shadow, FALLBACK_PROCEDURAL_RGB.shadow),
      sky: parseHexColor(palette.accent, FALLBACK_PROCEDURAL_RGB.sky),
    };
  }

  function createSkyGrassDataTexture(THREE, colorSet) {
    const width = 4;
    const height = 4;
    const data = new Uint8Array(width * height * 4);
    const base = colorSet.grass;
    const highlight = mixRgb(base, colorSet.cloud, 0.6);
    const midTone = mixRgb(base, colorSet.sky, 0.25);
    const shadow = mixRgb(base, colorSet.shadow, 0.65);
    const edgeHighlight = mixRgb(highlight, colorSet.cloud, 0.2);
    const edgeShadow = mixRgb(shadow, colorSet.shadow, 0.25);
    const pixels = [
      edgeHighlight,
      highlight,
      highlight,
      mixRgb(highlight, colorSet.sky, 0.35),
      mixRgb(highlight, midTone, 0.5),
      midTone,
      midTone,
      mixRgb(midTone, colorSet.sky, 0.4),
      mixRgb(midTone, shadow, 0.25),
      shadow,
      shadow,
      edgeShadow,
      mixRgb(shadow, colorSet.shadow, 0.35),
      edgeShadow,
      edgeShadow,
      mixRgb(edgeShadow, colorSet.shadow, 0.5),
    ];
    for (let i = 0; i < pixels.length; i += 1) {
      const { r, g, b } = pixels[i];
      const index = i * 4;
      data[index] = r;
      data[index + 1] = g;
      data[index + 2] = b;
      data[index + 3] = 255;
    }
    const texture = new THREE.DataTexture(data, width, height, THREE.RGBAFormat, THREE.UnsignedByteType);
    texture.colorSpace = THREE.SRGBColorSpace;
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.needsUpdate = true;
    return texture;
  }

  const WORLD_SIZE = 64;
  const NAVMESH_RELOAD_REASONS = new Set(['world-load', 'world-reload']);
  const DEFAULT_PROCEDURAL_VOXEL_PALETTE = {
    base: '#6fbf73',
    highlight: '#e5f7ff',
    shadow: '#3f7a3a',
    accent: '#8ad4ff',
  };
  const PROCEDURAL_TEXTURE_FALLBACK_PALETTES = Object.freeze({
    grass: {
      base: '#2f9e44',
      highlight: '#c3fa9b',
      shadow: '#176123',
      accent: '#8ce0ff',
    },
    dirt: {
      base: '#b0793f',
      highlight: '#f3c892',
      shadow: '#5f3616',
      accent: '#ffd8a8',
    },
    stone: {
      base: '#94a3b8',
      highlight: '#e2e8f0',
      shadow: '#475569',
      accent: '#cbd5f5',
    },
    rails: {
      base: '#d97706',
      highlight: '#fcd34d',
      shadow: '#92400e',
      accent: '#fde68a',
    },
    sand: {
      base: '#f1d39c',
      highlight: '#fff4d6',
      shadow: '#c49a4a',
      accent: '#ffe5b4',
    },
    gravel: {
      base: '#8d8f98',
      highlight: '#dce1e8',
      shadow: '#53545b',
      accent: '#bbc0c7',
    },
    obsidian: {
      base: '#4338ca',
      highlight: '#a5b4fc',
      shadow: '#1e1b4b',
      accent: '#c7d2fe',
    },
    portal: {
      base: '#7c3aed',
      highlight: '#c4b5fd',
      shadow: '#4c1d95',
      accent: '#a855f7',
    },
  });

  function resolveProceduralVoxelPalette(key) {
    if (typeof key !== 'string') {
      return DEFAULT_PROCEDURAL_VOXEL_PALETTE;
    }
    const normalised = key.trim().toLowerCase();
    if (!normalised) {
      return DEFAULT_PROCEDURAL_VOXEL_PALETTE;
    }
    return PROCEDURAL_TEXTURE_FALLBACK_PALETTES[normalised] || DEFAULT_PROCEDURAL_VOXEL_PALETTE;
  }
  const BLOCK_SIZE = 1;
  const EMBEDDED_TEXTURE_DATA = {
    grass: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAGUlEQVR4nGOMn2/KQApgIkn1qIZRDUNKAwDeMQFTRB/l3QAAAABJRU5ErkJggg==',
    dirt: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAGUlEQVR4nGNsS3BmIAUwkaR6VMOohiGlAQC/vgFJA9SUHwAAAABJRU5ErkJggg==',
    stone: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAGUlEQVR4nGNsaGhgIAUwkaR6VMOohiGlAQDJTAGgLgFHggAAAABJRU5ErkJggg==',
    rails: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAaElEQVR4nGPUkhH4zzCAgHHnxln/5eWVGJZOboALnr30DM7Or6lgoKU8CzZXff35C6+rqSnPhFclHQDjaBrA5qrRNEBXB4ymAbwq6QBG08BoGhhNA6NpYDQNjKaB0TQwmgZG08BoGgAA0SM0+BZHEZkAAAAASUVORK5CYII=',
  };
  const DEFAULT_TEXTURE_MANIFEST = {
    grass: [EMBEDDED_TEXTURE_DATA.grass],
    dirt: [EMBEDDED_TEXTURE_DATA.dirt],
    stone: [EMBEDDED_TEXTURE_DATA.stone],
    rails: [EMBEDDED_TEXTURE_DATA.rails],
  };

  const CRITICAL_ASSET_AVAILABILITY_DEFAULT_TIMEOUT_MS = 1800;
  const CRITICAL_ASSET_AVAILABILITY_MAX_CONCURRENCY = 4;
  const CRITICAL_ASSET_AVAILABILITY_MAX_FAILURES = 10;
  const TEXTURE_PACK_ERROR_NOTICE_THRESHOLD = 3;
  const MIN_COLUMN_HEIGHT = 1;
  const MAX_COLUMN_HEIGHT = 6;
  const MAX_TERRAIN_VOXELS = WORLD_SIZE * WORLD_SIZE * MAX_COLUMN_HEIGHT;
  const DEFAULT_TERRAIN_VOXEL_CAP = WORLD_SIZE * WORLD_SIZE * 4;
  const TERRAIN_CULLING_POSITION_EPSILON_SQ = 0.0001;
  const TERRAIN_CULLING_ROTATION_EPSILON = 0.0001;
  const LAZY_ASSET_WARMUP_DELAY_MS = 250;
  const PLAYER_EYE_HEIGHT = 1.8;
  const PLAYER_BASE_SPEED = 4.5;
  const PLAYER_INERTIA = 0.88;
  const DAY_LENGTH_SECONDS = 600;
  const POINTER_SENSITIVITY = 0.0022;
  const POINTER_TUTORIAL_MESSAGE =
    'Click the viewport to capture your mouse, then use your movement keys to move and left-click to mine.';
  const POINTER_LOCK_FALLBACK_MESSAGE =
    'Pointer lock is blocked by your browser or an extension. Click and drag to look around, or allow mouse capture to re-enable full look controls.';
  const POINTER_LOCK_MAX_RETRIES = 2;
  const POINTER_LOCK_RETRY_DELAY_MS = 200;
  const POINTER_LOCK_RETRY_HINT_MESSAGE = 'Browser blocked mouse capture — retrying…';
  const POINTER_LOCK_CHANGE_EVENTS = ['pointerlockchange', 'mozpointerlockchange', 'webkitpointerlockchange'];
  const POINTER_LOCK_ERROR_EVENTS = ['pointerlockerror', 'mozpointerlockerror', 'webkitpointerlockerror'];
  const HUD_INTERACTION_TIMEOUT_MS = 4500;
  const FALLBACK_HEALTH = 10;
  const FALLBACK_BREATH = 10;
  const PORTAL_BLOCK_REQUIREMENT = 10;
  const PORTAL_INTERACTION_RANGE = 4.5;
  const PORTAL_SHADER_FALLBACK_ANNOUNCEMENT =
    'Portal shader offline — plain flashing color active while shaders recover.';
  const ZOMBIE_CONTACT_RANGE = 1.35;
  const ZOMBIE_COLLISION_RADIUS = 0.62;
  const ZOMBIE_SPAWN_INTERVAL = 8;
  const ZOMBIE_MAX_PER_DIMENSION = 4;
  const GOLEM_COLLISION_RADIUS = 0.95;
  const HOTBAR_SLOTS = 10;
  const KEY_BINDINGS_STORAGE_KEY = 'infinite-rails-keybindings';
  const SCOREBOARD_STORAGE_KEY = 'infinite-dimension-scoreboard';
  const SCOREBOARD_CACHE_MAX_AGE_MS = 1000 * 60 * 60 * 24 * 7;
  const SCORE_SYNC_QUEUE_STORAGE_KEY = 'infinite-dimension-score-queue';
  const SCORE_SYNC_QUEUE_LIMIT = 25;
  const FIRST_RUN_TUTORIAL_STORAGE_KEY = 'infinite-rails-first-run-tutorial';
  const MOVEMENT_ACTIONS = ['moveForward', 'moveBackward', 'moveLeft', 'moveRight'];
  const LEGACY_KEYBOARD_CODE_MAP = Object.freeze({
    ArrowUp: 'ArrowUp',
    ArrowDown: 'ArrowDown',
    ArrowLeft: 'ArrowLeft',
    ArrowRight: 'ArrowRight',
    Up: 'ArrowUp',
    Down: 'ArrowDown',
    Left: 'ArrowLeft',
    Right: 'ArrowRight',
    Escape: 'Escape',
    Esc: 'Escape',
    Spacebar: 'Space',
    Space: 'Space',
    ' ': 'Space',
    Enter: 'Enter',
    Return: 'Enter',
    Tab: 'Tab',
  });
  const DEFAULT_KEY_BINDINGS = (() => {
    const map = {
      moveForward: ['KeyW', 'ArrowUp'],
      moveBackward: ['KeyS', 'ArrowDown'],
      moveLeft: ['KeyA', 'ArrowLeft'],
      moveRight: ['KeyD', 'ArrowRight'],
      jump: ['Space'],
      interact: ['KeyF'],
      buildPortal: ['KeyR'],
      resetPosition: ['KeyT'],
      placeBlock: ['KeyQ'],
      toggleCameraPerspective: ['KeyV'],
      toggleCrafting: ['KeyE'],
      toggleInventory: ['KeyI'],
      openGuide: [],
      toggleTutorial: ['F1', 'Slash'],
      toggleDeveloperOverlay: ['Backquote', 'F8'],
      openSettings: ['F2'],
      openLeaderboard: ['F3'],
      closeMenus: ['Escape'],
    };
    for (let slot = 1; slot <= HOTBAR_SLOTS; slot += 1) {
      const digit = slot % 10;
      const action = `hotbar${slot}`;
      const primary = digit === 0 ? 'Digit0' : `Digit${digit}`;
      const secondary = digit === 0 ? 'Numpad0' : `Numpad${digit}`;
      map[action] = [primary, secondary];
    }
    Object.keys(map).forEach((action) => {
      map[action] = Object.freeze([...map[action]]);
    });
    return Object.freeze(map);
  })();

  function normaliseLiveDiagnosticError(error) {
    if (!error) {
      return null;
    }
    if (error instanceof Error) {
      return {
        name: error.name,
        message: error.message,
        stack: typeof error.stack === 'string' ? error.stack : undefined,
      };
    }
    if (typeof error === 'string') {
      return { message: error };
    }
    if (typeof error === 'number' || typeof error === 'boolean') {
      return { value: error };
    }
    try {
      return JSON.parse(JSON.stringify(error));
    } catch (serializationError) {
      return { message: String(error) };
    }
  }

  function notifyLiveDiagnostics(category, message, detail = null, options = {}) {
    try {
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      const api = scope?.InfiniteRails?.diagnostics;
      if (api && typeof api.record === 'function') {
        api.record(category, message, detail, options);
      }
    } catch (error) {
      // Ignore live diagnostics forwarding errors to keep gameplay responsive.
    }
  }

  function ensureAudioFallbackMessage(text) {
    const trimmed = typeof text === 'string' ? text.trim() : '';
    if (!trimmed) {
      return AUDIO_FALLBACK_SUFFIX;
    }
    let message = trimmed.replace(
      /Fallback alert tone active until audio assets are restored\.?$/i,
      AUDIO_FALLBACK_SUFFIX,
    );
    const suffixPattern = new RegExp(
      AUDIO_FALLBACK_SUFFIX.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),
      'i',
    );
    if (suffixPattern.test(message)) {
      return message.endsWith('.') || message.endsWith('!') || message.endsWith('?')
        ? message
        : `${message}.`;
    }
    const separator = message.endsWith('.') || message.endsWith('!') || message.endsWith('?') ? ' ' : '. ';
    return `${message}${separator}${AUDIO_FALLBACK_SUFFIX}`;
  }

  function displayAudioFallbackOverlay(message, detail = {}) {
    const overlay =
      runtimeScope?.bootstrapOverlay ||
      runtimeScope?.InfiniteRails?.bootstrapOverlay ||
      runtimeScope?.__INFINITE_RAILS_BOOTSTRAP_OVERLAY__ ||
      null;
    if (!overlay) {
      return;
    }
    const normalisedMessage = ensureAudioFallbackMessage(message);
    const missingSample = detail.missingSample === true;
    const title = missingSample ? 'Missing audio sample' : 'Audio playback failed';
    try {
      if (typeof overlay.showError === 'function') {
        overlay.showError({ title, message: normalisedMessage });
      }
    } catch (error) {
      if (typeof console !== 'undefined' && typeof console.debug === 'function') {
        console.debug('Unable to display audio fallback overlay.', error);
      }
    }
    try {
      if (typeof overlay.setDiagnostic === 'function') {
        overlay.setDiagnostic('audio', { status: 'error', message: normalisedMessage });
      }
    } catch (error) {
      if (typeof console !== 'undefined' && typeof console.debug === 'function') {
        console.debug('Unable to record audio fallback diagnostic.', error);
      }
    }
    const logDetail =
      detail.detail && typeof detail.detail === 'object'
        ? detail.detail
        : {
            code: detail.code || (missingSample ? 'missing-sample' : 'welcome-playback-error'),
            requestedName: detail.requestedName ?? 'welcome',
            resolvedName: detail.resolvedName ?? null,
            missingSample,
            fallbackActive: detail.fallbackActive === true,
          };
    try {
      if (typeof overlay.logEvent === 'function') {
        overlay.logEvent('audio', normalisedMessage, { level: 'error', detail: logDetail });
      }
    } catch (error) {
      if (typeof console !== 'undefined' && typeof console.debug === 'function') {
        console.debug('Unable to record audio fallback overlay event.', error);
      }
    }
  }

  function cloneScoreBreakdown(source) {
    if (!source || typeof source !== 'object') {
      return {};
    }
    const clone = {};
    Object.entries(source).forEach(([key, value]) => {
      if (typeof key === 'string' && key.trim()) {
        clone[key] = Number.isFinite(value) ? value : value;
      }
    });
    return clone;
  }

  function cloneHotbarSlots(source) {
    if (!Array.isArray(source)) {
      return [];
    }
    return source.map((slot = {}) => ({
      item: typeof slot.item === 'string' ? slot.item : slot.item ?? null,
      quantity: Number.isFinite(slot.quantity) ? slot.quantity : 0,
    }));
  }

  function cloneSatchelEntries(source) {
    if (!(source instanceof Map)) {
      return [];
    }
    const entries = [];
    source.forEach((quantity, item) => {
      const safeItem = typeof item === 'string' ? item : item ?? null;
      const safeQuantity = Number.isFinite(quantity) ? quantity : 0;
      if (safeItem && safeQuantity > 0) {
        entries.push([safeItem, safeQuantity]);
      }
    });
    return entries;
  }

  function createAtomicAbortError(code, message, info = {}) {
    const error = new Error(message || 'Atomic gameplay mutation aborted.');
    error.name = 'GameplayAtomicAbortError';
    error.code = code || 'atomic-abort';
    error.info = info || {};
    return error;
  }

  function isAtomicAbortError(error) {
    if (!error) {
      return false;
    }
    if (error.name === 'GameplayAtomicAbortError') {
      return true;
    }
    if (typeof error.code === 'string' && error.code.startsWith('atomic-')) {
      return true;
    }
    return false;
  }

  const configWarningDeduper = new Set();

  const DEFAULT_AMBIENT_TRACKS = Object.freeze([
    'ambientOverworld',
    'ambientDefault',
    'ambient',
    'bubble',
  ]);

  const GAME_GUIDE_SLIDES = Object.freeze([
    {
      id: 'controls',
      icon: '🎮',
      label: 'Core Systems',
      title: 'Command the Rails',
      description:
        'Comfortable movement and smart interactions keep you alive long enough to craft an exit. Use these bindings to stay nimble.',
      sections(experience) {
        const moveKeys = experience.getCombinedActionLabels(
          ['moveForward', 'moveLeft', 'moveBackward', 'moveRight'],
          { limitPerAction: 1 },
        );
        const jumpKeys = experience.getActionKeyLabels('jump', { limit: 2 });
        const interactKeys = experience.getActionKeyLabels('interact', { limit: 3 });
        const placeKeys = experience.getActionKeyLabels('placeBlock', { limit: 3 });
        const resetKeys = experience.getActionKeyLabels('resetPosition', { limit: 2 });
        return [
          {
            title: 'Movement & Awareness',
            items: [
              {
                label: 'Traverse the rail',
                description: 'Walk, strafe, and reposition with your primary movement keys or virtual joystick.',
                keys: moveKeys,
              },
              {
                label: 'Jump / climb',
                description: 'Clear gaps, scramble up ledges, and cancel fall momentum.',
                keys: jumpKeys,
              },
              {
                label: 'Look around',
                description:
                  'Move the mouse, drag on touch, or swipe the viewport. Tap the canvas to recapture pointer lock if the cursor appears.',
              },
            ],
          },
          {
            title: 'Immediate actions',
            items: [
              {
                label: 'Gather / interact',
                description: 'Harvest resources, open chests, and trigger switches while facing the target block.',
                keys: interactKeys,
              },
              {
                label: 'Place block',
                description: 'Drop the equipped hotbar block onto the world. Perfect placement keeps the frame aligned.',
                keys: placeKeys,
              },
              {
                label: 'Reset position',
                description: 'Return to the spawn anchor if you become wedged between blocks.',
                keys: resetKeys,
              },
              {
                label: 'Swap hotbar items',
                description: 'Press number keys 1–0 or tap a slot to equip different tools and materials.',
              },
            ],
          },
        ];
      },
      footer:
        'Need breathing room? Press Esc to pause interactions, then refocus the canvas when you are ready to continue.',
    },
    {
      id: 'crafting',
      icon: '🛠️',
      label: 'Crafting & Inventory',
      title: 'Assemble Essential Gear',
      description:
        'Queue ingredients into the crafting ring, manage your satchel, and unlock recipes that reinforce the rail network.',
      sections(experience) {
        const craftingKeys = experience.getActionKeyLabels('toggleCrafting', { limit: 3 });
        const inventoryKeys = experience.getActionKeyLabels('toggleInventory', { limit: 3 });
        const interactKeys = experience.getActionKeyLabels('interact', { limit: 3 });
        return [
          {
            title: 'Access interfaces',
            items: [
              {
                label: 'Open crafting',
                description: 'Tap the hammer icon or use the shortcut to pop open the portable crafting terminal.',
                keys: craftingKeys,
              },
              {
                label: 'Review inventory',
                description: 'Toggle the satchel view to rearrange slots, move items, and expand storage.',
                keys: inventoryKeys,
              },
              {
                label: 'Confirm crafting',
                description: 'Select the Craft button or your interact key to forge the queued recipe when all ingredients align.',
                keys: interactKeys,
              },
            ],
          },
          {
            title: 'Recipe flow',
            items: [
              {
                label: 'Queue ingredients',
                description: 'Select items from the hotbar or satchel to line up the exact order required by each recipe.',
              },
              {
                label: 'Consult the helper',
                description: 'Hover over an ingredient or recipe to view the crafting helper’s tips and unlock hints.',
              },
              {
                label: 'Search quickly',
                description: 'Use the magnifier to filter recipes. Matching results can be slotted directly into the crafting circle.',
              },
            ],
          },
        ];
      },
      footer: 'Unlocking new recipes awards score bonuses—craft early, craft often.',
    },
    {
      id: 'portals',
      icon: '🌀',
      label: 'Portals & Progression',
      title: 'Stabilise Escape Portals',
      description:
        'Every biome demands a precise frame. Gather blocks, build the structure, and ignite it before nightfall overwhelms you.',
      sections(experience) {
        const placeKeys = experience.getActionKeyLabels('placeBlock', { limit: 3 });
        const buildKeys = experience.getActionKeyLabels('buildPortal', { limit: 3 });
        const interactKeys = experience.getActionKeyLabels('interact', { limit: 3 });
        return [
          {
            title: 'Portal construction',
            items: [
              {
                label: 'Set the frame',
                description: 'Arrange a 4×3 rectangle using the biome’s required block. Corners must align to register.',
                keys: placeKeys,
              },
              {
                label: 'Ignite the gateway',
                description: 'Use the ignition binding once the frame is complete to spin up the vortex.',
                keys: buildKeys,
              },
              {
                label: 'Enter the portal',
                description: 'Step in or use your interact key once the status reads Active to travel to the next dimension.',
                keys: interactKeys,
              },
            ],
          },
          {
            title: 'Stay informed',
            items: [
              {
                label: 'Monitor portal HUD',
                description: 'Watch the portal status tile and progress bar at the bottom of the HUD for readiness cues.',
              },
              {
                label: 'Track objectives',
                description: 'The Objectives panel highlights current biome goals, hazards, and portal requirements.',
              },
              {
                label: 'Log your run',
                description: 'Complete a dimension or finish the expedition to sync stats with the leaderboard modal.',
              },
            ],
          },
        ];
      },
      footer:
        'Portals destabilise overnight—ignite them quickly and bring spare blocks in case the frame gets damaged.',
    },
  ]);

  function logConfigWarning(message, context = {}) {
    const consoleRef = typeof console !== 'undefined' ? console : null;
    if (!consoleRef) {
      return;
    }
    const sortedKeys = Object.keys(context).sort();
    const dedupeKey = `${message}|${sortedKeys.map((key) => `${key}:${context[key]}`).join(',')}`;
    if (configWarningDeduper.has(dedupeKey)) {
      return;
    }
    configWarningDeduper.add(dedupeKey);
    if (typeof consoleRef.warn === 'function') {
      consoleRef.warn(message, context);
    } else if (typeof consoleRef.error === 'function') {
      consoleRef.error(message, context);
    } else if (typeof consoleRef.log === 'function') {
      if (typeof consoleRef.error === 'function') {
        consoleRef.error(message, context);
      } else {
        consoleRef.log(message, context);
      }
    }
  }

  function setInertState(element, shouldBeInert) {
    if (!element) {
      return;
    }
    if (typeof element.toggleAttribute === 'function') {
      element.toggleAttribute('inert', shouldBeInert);
    } else if (shouldBeInert) {
      element.setAttribute?.('inert', '');
    } else {
      element.removeAttribute?.('inert');
    }
  }

  function setElementHidden(element, hidden) {
    if (!element) {
      return;
    }
    const shouldHide = Boolean(hidden);
    if ('hidden' in element) {
      try {
        element.hidden = shouldHide;
      } catch (error) {
        // Ignore failures from DOM stubs that expose a non-writable hidden property.
      }
    }
    if (typeof element.toggleAttribute === 'function') {
      element.toggleAttribute('hidden', shouldHide);
    } else if (shouldHide) {
      element.setAttribute?.('hidden', '');
    } else {
      element.removeAttribute?.('hidden');
    }
  }

  function focusElementSilently(target) {
    if (!target || typeof target.focus !== 'function') {
      return false;
    }
    try {
      target.focus({ preventScroll: true });
      return true;
    } catch (error) {
      try {
        target.focus();
        return true;
      } catch (nestedError) {
        return false;
      }
    }
  }

  function moveFocusAwayFromElement(element, doc, fallbackFocus) {
    if (!element || !doc) {
      return true;
    }
    const contains = typeof element.contains === 'function' ? element.contains.bind(element) : null;
    if (!contains) {
      return true;
    }
    const active = doc.activeElement || null;
    if (!active || !contains(active)) {
      return true;
    }
    if (fallbackFocus) {
      let handled = false;
      if (typeof fallbackFocus === 'function') {
        try {
          const result = fallbackFocus();
          handled = result !== false;
        } catch (error) {
          handled = false;
        }
      } else {
        handled = focusElementSilently(fallbackFocus);
      }
      if (handled && !contains(doc.activeElement || null)) {
        return true;
      }
    }
    if (doc.body && doc.body !== active && focusElementSilently(doc.body) && !contains(doc.activeElement || null)) {
      return true;
    }
    if (typeof active.blur === 'function') {
      active.blur();
    }
    return !contains(doc.activeElement || null);
  }

  function safelySetAriaHidden(element, hidden, options = {}) {
    if (!element) {
      return false;
    }
    const doc = element.ownerDocument || (typeof document !== 'undefined' ? document : null);
    if (!hidden) {
      if (options.toggleInert) {
        setInertState(element, false);
      }
      element.removeAttribute?.('aria-hidden');
      return true;
    }
    const fallbackFocus = options.fallbackFocus || null;
    const cleared = moveFocusAwayFromElement(element, doc, fallbackFocus);
    if (!cleared) {
      return false;
    }
    if (options.toggleInert) {
      setInertState(element, true);
    }
    element.removeAttribute?.('aria-hidden');
    return true;
  }

  const overlayIsolationState = {
    stack: [],
    originals: new Map(),
    doc: null,
  };

  function normaliseOverlayIsolationDocument(doc) {
    if (!doc?.body) {
      overlayIsolationState.stack = [];
      overlayIsolationState.originals.clear();
      overlayIsolationState.doc = null;
      return [];
    }
    overlayIsolationState.stack = overlayIsolationState.stack.filter((element) => {
      if (!element) {
        return false;
      }
      if (element.isConnected === false) {
        return false;
      }
      if (doc.body && typeof doc.body.contains === 'function' && !doc.body.contains(element)) {
        return false;
      }
      return true;
    });
    const children = doc.body?.children;
    return Array.isArray(children) ? children : Array.from(children ?? []);
  }

  function applyOverlayIsolation(docOverride = null) {
    const doc =
      docOverride || overlayIsolationState.doc || (typeof document !== 'undefined' ? document : null);
    if (!doc?.body) {
      overlayIsolationState.stack = [];
      overlayIsolationState.originals.clear();
      overlayIsolationState.doc = null;
      return;
    }
    overlayIsolationState.doc = doc;
    const bodyChildren = normaliseOverlayIsolationDocument(doc);
    const activeOverlay =
      overlayIsolationState.stack.length > 0
        ? overlayIsolationState.stack[overlayIsolationState.stack.length - 1]
        : null;

    if (!activeOverlay) {
      for (const [element, originalState] of Array.from(overlayIsolationState.originals.entries())) {
        if (!element) {
          overlayIsolationState.originals.delete(element);
          continue;
        }
        const bodyContainsElement =
          doc.body && typeof doc.body.contains === 'function' ? doc.body.contains(element) : true;
        if (!bodyContainsElement) {
          overlayIsolationState.originals.delete(element);
          continue;
        }
        setInertState(element, Boolean(originalState));
        overlayIsolationState.originals.delete(element);
      }
      overlayIsolationState.originals.clear();
      return;
    }

    if (doc.body && typeof doc.body.contains === 'function' && !doc.body.contains(activeOverlay)) {
      overlayIsolationState.stack.pop();
      applyOverlayIsolation(doc);
      return;
    }

    const backgroundElements = [];
    for (const child of bodyChildren) {
      if (!child) {
        continue;
      }
      const containsOverlay =
        typeof child.contains === 'function' ? child.contains(activeOverlay) : child === activeOverlay;
      if (!containsOverlay) {
        backgroundElements.push(child);
      }
    }
    const backgroundSet = new Set(backgroundElements);
    for (const element of backgroundElements) {
      if (!overlayIsolationState.originals.has(element)) {
        const hadInert = typeof element.hasAttribute === 'function' ? element.hasAttribute('inert') : false;
        overlayIsolationState.originals.set(element, hadInert);
      }
      setInertState(element, true);
    }
    for (const [element, originalState] of Array.from(overlayIsolationState.originals.entries())) {
      if (!backgroundSet.has(element)) {
        const bodyContainsElement =
          doc.body && typeof doc.body.contains === 'function' ? doc.body.contains(element) : true;
        if (!bodyContainsElement) {
          overlayIsolationState.originals.delete(element);
          continue;
        }
        setInertState(element, Boolean(originalState));
        overlayIsolationState.originals.delete(element);
      }
    }
  }

  function activateOverlayIsolation(element) {
    if (!element) {
      return;
    }
    const doc = element.ownerDocument || overlayIsolationState.doc || (typeof document !== 'undefined' ? document : null);
    if (!doc?.body) {
      return;
    }
    normaliseOverlayIsolationDocument(doc);
    const existingIndex = overlayIsolationState.stack.indexOf(element);
    if (existingIndex !== -1) {
      overlayIsolationState.stack.splice(existingIndex, 1);
    }
    overlayIsolationState.stack.push(element);
    applyOverlayIsolation(doc);
  }

  function releaseOverlayIsolation(element) {
    if (!element) {
      return;
    }
    const doc = overlayIsolationState.doc || element.ownerDocument || (typeof document !== 'undefined' ? document : null);
    if (!doc?.body) {
      return;
    }
    normaliseOverlayIsolationDocument(doc);
    overlayIsolationState.stack = overlayIsolationState.stack.filter((entry) => entry && entry !== element);
    applyOverlayIsolation(doc);
  }

  function deepFreeze(value, seen = new WeakSet()) {
    if (!value || typeof value !== 'object') {
      return value;
    }
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    const propertyNames = Object.getOwnPropertyNames(value);
    for (const name of propertyNames) {
      const property = value[name];
      if (property && typeof property === 'object') {
        deepFreeze(property, seen);
      }
    }
    return Object.freeze(value);
  }

  function normaliseApiBaseUrl(base) {
    if (!base || typeof base !== 'string') {
      return null;
    }
    const trimmed = base.trim();
    if (!trimmed) {
      return null;
    }
    let resolved;
    try {
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      resolved = new URL(trimmed, scope?.location?.href ?? undefined);
    } catch (error) {
      logConfigWarning(
        'Invalid APP_CONFIG.apiBaseUrl detected; remote sync disabled. Update APP_CONFIG.apiBaseUrl to a valid absolute HTTP(S) URL in your configuration to restore remote synchronisation.',
        {
          apiBaseUrl: base,
          error: error?.message ?? String(error),
        },
      );
      return null;
    }
    const hasExplicitProtocol = /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(trimmed);
    if (!hasExplicitProtocol) {
      logConfigWarning(
        'APP_CONFIG.apiBaseUrl must be an absolute URL including the protocol. Set APP_CONFIG.apiBaseUrl to a fully-qualified HTTP(S) endpoint (for example, https://example.com/api).',
        {
          apiBaseUrl: base,
          resolved: resolved.href,
        },
      );
      return null;
    }
    if (resolved.protocol !== 'https:' && resolved.protocol !== 'http:') {
      logConfigWarning(
        'APP_CONFIG.apiBaseUrl must use HTTP or HTTPS. Update the configuration to point at an HTTP(S) service that can accept leaderboard sync requests.',
        {
          apiBaseUrl: base,
          protocol: resolved.protocol,
        },
      );
      return null;
    }
    if (resolved.search || resolved.hash) {
      logConfigWarning(
        'APP_CONFIG.apiBaseUrl should not include query strings or fragments; ignoring extras. Remove trailing query parameters or hashes from APP_CONFIG.apiBaseUrl so requests reach the API root.',
        {
          apiBaseUrl: base,
          search: resolved.search,
          hash: resolved.hash,
        },
      );
      resolved.search = '';
      resolved.hash = '';
    }
    return resolved.href.replace(/\/+$/, '');
  }

  function cloneKeyBindingMap(source = {}) {
    const result = {};
    Object.entries(source).forEach(([action, keys]) => {
      if (Array.isArray(keys)) {
        result[action] = [...keys];
      }
    });
    return result;
  }

  function normaliseKeyBindingValue(value) {
    if (typeof value === 'string') {
      const trimmed = value.trim();
      return trimmed ? [trimmed] : [];
    }
    if (Array.isArray(value)) {
      const seen = new Set();
      const result = [];
      value.forEach((entry) => {
        if (typeof entry !== 'string') return;
        const trimmed = entry.trim();
        if (!trimmed || seen.has(trimmed)) return;
        seen.add(trimmed);
        result.push(trimmed);
      });
      return result;
    }
    return [];
  }

  function normaliseKeyBindingMap(source) {
    if (!source || typeof source !== 'object') {
      return null;
    }
    const result = {};
    Object.entries(source).forEach(([action, value]) => {
      const keys = normaliseKeyBindingValue(value);
      if (keys.length) {
        result[action] = keys;
      }
    });
    return Object.keys(result).length ? result : null;
  }

  function mergeKeyBindingMaps(base, ...sources) {
    const merged = cloneKeyBindingMap(base);
    sources.forEach((source) => {
      if (!source) return;
      Object.entries(source).forEach(([action, keys]) => {
        if (!Array.isArray(keys) || !keys.length) return;
        merged[action] = [...keys];
      });
    });
    return merged;
  }

  function updateAmbientControlMap(map) {
    if (!runtimeScope) {
      return;
    }
    const snapshot = cloneKeyBindingMap(map || {});
    try {
      runtimeScope[CONTROL_MAP_GLOBAL_KEY] = snapshot;
    } catch (error) {
      // Ignore assignment failures in restricted environments.
    }
    const appConfig =
      runtimeScope.APP_CONFIG && typeof runtimeScope.APP_CONFIG === 'object'
        ? runtimeScope.APP_CONFIG
        : null;
    if (appConfig) {
      appConfig.controlMap = snapshot;
    }
  }

  function applyControlMapToExperience(instance, map) {
    if (!instance || typeof instance !== 'object') {
      return;
    }
    const baseMap = map ? cloneKeyBindingMap(map) : cloneKeyBindingMap(DEFAULT_KEY_BINDINGS);
    instance.controlMapBase = baseMap;
    instance.baseKeyBindings = mergeKeyBindingMaps(
      instance.defaultKeyBindings || cloneKeyBindingMap(DEFAULT_KEY_BINDINGS),
      baseMap,
      instance.configKeyBindingOverrides,
      instance.optionKeyBindingOverrides,
    );
    if (typeof instance.buildKeyBindings === 'function') {
      instance.keyBindings = instance.buildKeyBindings({ includeStored: true });
    } else {
      instance.keyBindings = cloneKeyBindingMap(instance.baseKeyBindings);
    }
    if (typeof instance.ensureMovementBindingsConfigured === 'function') {
      instance.ensureMovementBindingsConfigured();
    }
    if (typeof instance.refreshFirstRunTutorialContent === 'function') {
      try {
        instance.refreshFirstRunTutorialContent();
      } catch (error) {
        if (typeof console !== 'undefined' && typeof console.debug === 'function') {
          console.debug('Failed to refresh tutorial content after control map update.', error);
        }
      }
    }
  }

  function normalizeKeyboardEventCode(event) {
    if (!event) {
      return '';
    }
    const code = typeof event.code === 'string' ? event.code : '';
    if (code) {
      return code;
    }
    const rawKey = typeof event.key === 'string' ? event.key : '';
    if (!rawKey) {
      return '';
    }
    if (LEGACY_KEYBOARD_CODE_MAP[rawKey]) {
      return LEGACY_KEYBOARD_CODE_MAP[rawKey];
    }
    const trimmed = rawKey.trim();
    if (LEGACY_KEYBOARD_CODE_MAP[trimmed]) {
      return LEGACY_KEYBOARD_CODE_MAP[trimmed];
    }
    if (!trimmed) {
      return '';
    }
    if (/^[a-z]$/i.test(trimmed)) {
      return `Key${trimmed.toUpperCase()}`;
    }
    if (/^[0-9]$/.test(trimmed)) {
      return `Digit${trimmed}`;
    }
    if (/^F[0-9]{1,2}$/i.test(trimmed)) {
      return trimmed.toUpperCase();
    }
    if (/^Numpad[0-9]$/i.test(trimmed)) {
      return `Numpad${trimmed.slice(-1)}`;
    }
    return '';
  }

  function formatKeyLabel(code) {
    if (!code || typeof code !== 'string') {
      return '';
    }
    if (code.startsWith('Key')) {
      return code.slice(3);
    }
    if (code.startsWith('Digit')) {
      return code.slice(5);
    }
    if (code.startsWith('Numpad')) {
      return `Numpad ${code.slice(6)}`;
    }
    switch (code) {
      case 'ArrowUp':
        return '↑';
      case 'ArrowDown':
        return '↓';
      case 'ArrowLeft':
        return '←';
      case 'ArrowRight':
        return '→';
      case 'Space':
        return 'Space';
      case 'Escape':
        return 'Esc';
      default:
        return code;
    }
  }

  function joinKeyLabels(labels, options = {}) {
    const { fallback = '' } = options ?? {};
    if (!Array.isArray(labels)) {
      return fallback;
    }
    const filtered = labels.filter((label) => typeof label === 'string' && label.trim());
    if (!filtered.length) {
      return fallback;
    }
    if (filtered.length === 1) {
      return filtered[0];
    }
    return filtered.join(' / ');
  }

  function formatKeyListForSentence(labels, options = {}) {
    const { fallback = '' } = options ?? {};
    if (!Array.isArray(labels) || !labels.length) {
      return fallback;
    }
    if (labels.length === 1) {
      return labels[0];
    }
    if (labels.length === 2) {
      return `${labels[0]} or ${labels[1]}`;
    }
    const head = labels.slice(0, -1).join(', ');
    return `${head}, or ${labels[labels.length - 1]}`;
  }
  const MAX_STACK_SIZE = 99;
  const GOLEM_CONTACT_RANGE = 1.6;
  const GOLEM_SPAWN_INTERVAL = 26;
  const GOLEM_MAX_PER_DIMENSION = 2;
  const CHEST_COUNT_PER_DIMENSION = 2;
  const CHEST_INTERACT_RANGE = 1.8;
  const CHEST_HINT_COOLDOWN = 4.5;

  function freezeDimensionLootTables(sourceTables) {
    const output = {};
    const entries = Object.entries(sourceTables || {});
    for (const [dimensionId, table] of entries) {
      const items = Array.isArray(table) ? table : [];
      const frozenEntries = items.map((entry) => {
        const lootItems = Array.isArray(entry.items)
          ? entry.items.map((item) =>
              Object.freeze({
                item: item.item,
                quantity: item.quantity,
              }),
            )
          : [];
        return Object.freeze({
          items: Object.freeze(lootItems),
          score: Number.isFinite(entry.score) ? entry.score : 0,
          message: entry.message || '',
        });
      });
      output[dimensionId] = Object.freeze(frozenEntries);
    }
    return Object.freeze(output);
  }

  const DIMENSION_LOOT_TABLE_SOURCE = {
    origin: [
      {
        items: [
          { item: 'stick', quantity: 3 },
          { item: 'stone', quantity: 1 },
        ],
        score: 2,
        message: 'Starter cache recovered — craft your tools.',
      },
      {
        items: [
          { item: 'grass-block', quantity: 3 },
          { item: 'dirt', quantity: 2 },
        ],
        score: 1.5,
        message: 'Extra building stock secured from the chest.',
      },
    ],
    rock: [
      {
        items: [
          { item: 'stone', quantity: 4 },
          { item: 'portal-charge', quantity: 1 },
        ],
        score: 3,
        message: 'Dense rock cache pulsing with portal energy.',
      },
      {
        items: [
          { item: 'stone', quantity: 3 },
          { item: 'stick', quantity: 1 },
        ],
        score: 2.5,
        message: 'Rails reinforced with honed stone slabs.',
      },
    ],
    stone: [
      {
        items: [
          { item: 'portal-charge', quantity: 2 },
          { item: 'stone', quantity: 2 },
        ],
        score: 3.5,
        message: 'Portal charges hum with refined stone dust.',
      },
      {
        items: [
          { item: 'stone-pickaxe', quantity: 1 },
          { item: 'portal-charge', quantity: 1 },
        ],
        score: 4,
        message: 'A tempered pickaxe gleams inside the vault.',
      },
    ],
    tar: [
      {
        items: [
          { item: 'portal-charge', quantity: 2 },
          { item: 'grass-block', quantity: 2 },
        ],
        score: 3,
        message: 'Recovered supplies before the tar swallowed them.',
      },
      {
        items: [
          { item: 'stone', quantity: 2 },
          { item: 'stick', quantity: 2 },
        ],
        score: 2.5,
        message: 'Tar-soaked lumber salvaged for future rails.',
      },
    ],
    marble: [
      {
        items: [
          { item: 'portal-charge', quantity: 3 },
        ],
        score: 4.5,
        message: 'Marble vault releases concentrated portal charge.',
      },
      {
        items: [
          { item: 'stone', quantity: 2 },
          { item: 'grass-block', quantity: 2 },
        ],
        score: 3,
        message: 'Lightweight marble bricks packed for construction.',
      },
    ],
    netherite: [
      {
        items: [
          { item: 'portal-charge', quantity: 4 },
        ],
        score: 5,
        message: 'Eternal Ingot fragments resonate through the chest.',
      },
      {
        items: [
          { item: 'stone-pickaxe', quantity: 1 },
          { item: 'portal-charge', quantity: 2 },
        ],
        score: 5,
        message: 'Armaments secured for the final Netherite sprint.',
      },
    ],
  };

  const DIMENSION_LOOT_TABLES = freezeDimensionLootTables(DIMENSION_LOOT_TABLE_SOURCE);


  const assetResolver =
    (typeof window !== 'undefined' && window.InfiniteRailsAssetResolver) ||
    (typeof globalThis !== 'undefined' && globalThis.InfiniteRailsAssetResolver) ||
    null;

  const createAssetUrlCandidates =
    assetResolver?.createAssetUrlCandidates ||
    ((relativePath) => {
      if (!relativePath || typeof relativePath !== 'string') {
        return [];
      }
      const candidates = [];
      const seen = new Set();
      const addCandidate = (value) => {
        if (typeof value !== 'string' || value.length === 0) {
          return;
        }
        const tagged = applyAssetVersionTag(value);
        if (!tagged || seen.has(tagged)) {
          return;
        }
        seen.add(tagged);
        candidates.push(tagged);
      };
      try {
        const base =
          (typeof document !== 'undefined' && document.baseURI) ||
          (typeof window !== 'undefined' && window.location?.href) ||
          undefined;
        const resolved = new URL(relativePath, base);
        addCandidate(resolved.href);
      } catch (error) {}
      addCandidate(relativePath);
      return candidates;
    });

  const resolveAssetUrl =
    assetResolver?.resolveAssetUrl ||
    ((relativePath) => {
      const candidates = createAssetUrlCandidates(relativePath);
      return candidates.length ? candidates[0] : relativePath;
    });

  function normaliseAssetAvailabilityCandidates(sources) {
    const results = [];
    const seen = new Set();
    const values = Array.isArray(sources) ? sources : [];
    values.forEach((value) => {
      if (typeof value !== 'string') {
        return;
      }
      const trimmed = value.trim();
      if (!trimmed) {
        return;
      }
      const tagged = applyAssetVersionTag(trimmed);
      if (/^(?:data|blob):/i.test(tagged)) {
        if (!seen.has(tagged)) {
          seen.add(tagged);
          results.push({ url: tagged, inline: true, raw: trimmed });
        }
        return;
      }
      const candidates = createAssetUrlCandidates(tagged);
      candidates.forEach((candidate) => {
        if (typeof candidate !== 'string') {
          return;
        }
        const finalValue = candidate.trim();
        if (!finalValue || seen.has(finalValue)) {
          return;
        }
        let absolute = finalValue;
        if (!/^(?:https?:|data:|blob:)/i.test(finalValue)) {
          try {
            const scope =
              (typeof window !== 'undefined' && window.location?.href)
              || (typeof globalThis !== 'undefined' && globalThis.location?.href)
              || undefined;
            absolute = new URL(finalValue, scope).href;
          } catch (error) {
            absolute = null;
          }
        }
        if (!absolute) {
          return;
        }
        seen.add(absolute);
        results.push({ url: absolute, inline: false, raw: trimmed });
      });
    });
    return results;
  }

  const GLTF_LOADER_URL = resolveAssetUrl('vendor/GLTFLoader.js');

  const RECIPE_UNLOCK_STORAGE_KEY = 'infinite-rails-recipe-unlocks';

  const PORTAL_MECHANICS =
    (typeof window !== 'undefined' && window.PortalMechanics) ||
    (typeof globalThis !== 'undefined' && globalThis.PortalMechanics) ||
    null;

  const IDENTITY_STORAGE_KEY = 'infinite-rails-simple-identity';

  const MODEL_URLS = {
    arm: resolveAssetUrl('assets/arm.gltf'),
    steve: resolveAssetUrl('assets/steve.gltf'),
    zombie: resolveAssetUrl('assets/zombie.gltf'),
    golem: resolveAssetUrl('assets/iron_golem.gltf'),
  };

  const MODEL_URL_LOOKUP = (() => {
    const entries = Object.entries(MODEL_URLS)
      .map(([key, url]) => [typeof url === 'string' ? url : null, key])
      .filter(([url]) => typeof url === 'string' && url.length > 0);
    const map = new Map(entries);
    return {
      byUrl(value) {
        if (typeof value !== 'string' || !value) {
          return null;
        }
        const trimmed = value.trim();
        if (!trimmed) {
          return null;
        }
        return map.get(trimmed) || null;
      },
      entries,
    };
  })();

  const BASE_TERRAIN_REFERENCES = ['grass-block', 'dirt', 'stone', 'rail-segment', 'portal-anchor'];
  const BASE_MOB_REFERENCES = ['player-avatar', 'zombie', 'iron-golem'];
  const BASE_OBJECT_REFERENCES = [
    'loot-chest',
    'portal-frame',
    'portal-core',
    'rail-network',
    'crafting-interface',
    'eternal-ingot',
  ];
  const BASE_TEXTURE_REFERENCES = {
    grass: 'grass',
    dirt: 'dirt',
    stone: 'stone',
    rails: 'rails',
  };
  const BASE_MODEL_REFERENCES = {
    player: MODEL_URLS.steve,
    helperArm: MODEL_URLS.arm,
    zombie: MODEL_URLS.zombie,
    golem: MODEL_URLS.golem,
  };

  const REQUIRED_MANIFEST_ASSET_KEYS = deepFreeze({
    textures: Object.keys(BASE_TEXTURE_REFERENCES),
    models: Object.keys(BASE_MODEL_REFERENCES),
  });

  const REQUIRED_DIMENSION_MANIFEST_COVERAGE = deepFreeze({
    origin: {
      terrain: [...BASE_TERRAIN_REFERENCES],
      mobs: [...BASE_MOB_REFERENCES],
      objects: [...BASE_OBJECT_REFERENCES],
    },
    rock: {
      terrain: [...BASE_TERRAIN_REFERENCES],
      mobs: [...BASE_MOB_REFERENCES],
      objects: [...BASE_OBJECT_REFERENCES],
    },
    stone: {
      terrain: [...BASE_TERRAIN_REFERENCES],
      mobs: [...BASE_MOB_REFERENCES],
      objects: [...BASE_OBJECT_REFERENCES, 'bastion-rampart'],
    },
    tar: {
      terrain: [...BASE_TERRAIN_REFERENCES, 'tar-pool'],
      mobs: [...BASE_MOB_REFERENCES, 'swamp-phantom'],
      objects: [...BASE_OBJECT_REFERENCES],
    },
    marble: {
      terrain: [...BASE_TERRAIN_REFERENCES],
      mobs: [...BASE_MOB_REFERENCES],
      objects: [...BASE_OBJECT_REFERENCES, 'marble-bridge'],
    },
    netherite: {
      terrain: [...BASE_TERRAIN_REFERENCES],
      mobs: [...BASE_MOB_REFERENCES],
      objects: [...BASE_OBJECT_REFERENCES, 'eternal-ingot-pedestal'],
    },
  });

  const reportedDimensionManifestIssues = new Set();
  const reportedMissingThemeLoads = new Set();

  function logDimensionManifestIssue(themeId, message) {
    if (!message) {
      return;
    }
    const id = typeof themeId === 'string' && themeId ? themeId : 'unknown';
    const key = `${id}::${message}`;
    if (reportedDimensionManifestIssues.has(key)) {
      return;
    }
    reportedDimensionManifestIssues.add(key);
    if (typeof console === 'undefined') {
      return;
    }
    const logger = typeof console.error === 'function' ? console.error : console.log;
    if (typeof logger === 'function') {
      logger(`Dimension theme "${id}" manifest issue: ${message}`);
    }
  }

  function ensureDimensionThemeManifestCoverage(theme) {
    if (!theme || typeof theme !== 'object') {
      return;
    }
    const themeId = typeof theme.id === 'string' && theme.id ? theme.id : 'unknown';
    const manifest = theme.assetManifest;
    if (!manifest || typeof manifest !== 'object') {
      logDimensionManifestIssue(themeId, 'asset manifest is missing.');
      return;
    }

    const coverage = REQUIRED_DIMENSION_MANIFEST_COVERAGE[themeId] || {
      terrain: BASE_TERRAIN_REFERENCES,
      mobs: BASE_MOB_REFERENCES,
      objects: BASE_OBJECT_REFERENCES,
    };

    ['terrain', 'mobs', 'objects'].forEach((field) => {
      const expected = Array.isArray(coverage[field]) ? coverage[field] : [];
      const actual = Array.isArray(manifest[field]) ? manifest[field] : [];
      if (actual.length === 0) {
        logDimensionManifestIssue(themeId, `manifest has no ${field} entries.`);
        return;
      }
      const missing = expected.filter((entry) => !actual.includes(entry));
      if (missing.length > 0) {
        logDimensionManifestIssue(
          themeId,
          `manifest ${field} is missing required entries: ${missing.join(', ')}.`,
        );
      }
    });

    const assets = manifest.assets;
    if (!assets || typeof assets !== 'object') {
      logDimensionManifestIssue(themeId, 'asset manifest is missing its assets map.');
      return;
    }

    const { textures, models } = assets;
    if (!textures || typeof textures !== 'object') {
      logDimensionManifestIssue(themeId, 'texture manifest is unavailable.');
    } else {
      REQUIRED_MANIFEST_ASSET_KEYS.textures.forEach((key) => {
        if (!(key in textures)) {
          logDimensionManifestIssue(themeId, `texture manifest is missing "${key}".`);
        }
      });
    }

    if (!models || typeof models !== 'object') {
      logDimensionManifestIssue(themeId, 'model manifest is unavailable.');
    } else {
      REQUIRED_MANIFEST_ASSET_KEYS.models.forEach((key) => {
        if (!(key in models)) {
          logDimensionManifestIssue(themeId, `model manifest is missing "${key}".`);
        }
      });
    }
  }

  const DEFAULT_TERRAIN_PROFILE = Object.freeze({
    minHeight: MIN_COLUMN_HEIGHT,
    maxHeight: MAX_COLUMN_HEIGHT,
    baseHeight: 1,
    falloffStrength: 2.6,
    falloffRadius: 0.68,
    falloffExponent: 1,
    noiseFrequency: 0.35,
    noiseAmplitude: 2,
    secondaryFrequency: 0.18,
    secondaryAmplitude: 0.9,
    ridgeFrequency: 0,
    ridgeAmplitude: 0,
    rimHeightBias: 0,
    centerHeightBias: 0,
    voxelBudgetMultiplier: 1,
    voxelBudgetOffset: 0,
    seedMultiplier: 53,
  });

  function buildTerrainProfile(overrides = {}) {
    const profile = {
      ...DEFAULT_TERRAIN_PROFILE,
      ...(overrides && typeof overrides === 'object' ? overrides : {}),
    };
    return Object.freeze(profile);
  }

  const DIMENSION_TERRAIN_PROFILES = deepFreeze({
    origin: buildTerrainProfile({
      minHeight: 1,
      maxHeight: 5,
      baseHeight: 1.15,
      falloffStrength: 2.4,
      falloffRadius: 0.7,
      noiseFrequency: 0.32,
      noiseAmplitude: 1.9,
      secondaryFrequency: 0.2,
      secondaryAmplitude: 0.65,
      centerHeightBias: 0.45,
      seedMultiplier: 41,
    }),
    rock: buildTerrainProfile({
      minHeight: 2,
      maxHeight: 6,
      baseHeight: 1.35,
      falloffStrength: 3.2,
      falloffRadius: 0.62,
      falloffExponent: 1.15,
      noiseFrequency: 0.44,
      noiseAmplitude: 2.35,
      secondaryFrequency: 0.26,
      secondaryAmplitude: 1.05,
      ridgeFrequency: 0.18,
      ridgeAmplitude: 0.7,
      rimHeightBias: 0.35,
      centerHeightBias: 0.25,
      voxelBudgetMultiplier: 1.1,
      seedMultiplier: 59,
    }),
    stone: buildTerrainProfile({
      minHeight: 3,
      maxHeight: 6,
      baseHeight: 1.5,
      falloffStrength: 3.4,
      falloffRadius: 0.64,
      falloffExponent: 1.25,
      noiseFrequency: 0.36,
      noiseAmplitude: 2.1,
      secondaryFrequency: 0.22,
      secondaryAmplitude: 0.95,
      ridgeFrequency: 0.21,
      ridgeAmplitude: 0.55,
      centerHeightBias: 0.6,
      voxelBudgetMultiplier: 1.05,
      seedMultiplier: 67,
    }),
    tar: buildTerrainProfile({
      minHeight: 1,
      maxHeight: 5,
      baseHeight: 0.9,
      falloffStrength: 2.15,
      falloffRadius: 0.74,
      falloffExponent: 0.85,
      noiseFrequency: 0.28,
      noiseAmplitude: 1.45,
      secondaryFrequency: 0.24,
      secondaryAmplitude: 1.3,
      ridgeFrequency: 0.16,
      ridgeAmplitude: 0.4,
      rimHeightBias: -0.2,
      centerHeightBias: 0.2,
      voxelBudgetMultiplier: 0.95,
      seedMultiplier: 47,
    }),
    marble: buildTerrainProfile({
      minHeight: 2,
      maxHeight: 6,
      baseHeight: 1.1,
      falloffStrength: 2.9,
      falloffRadius: 0.66,
      falloffExponent: 0.9,
      noiseFrequency: 0.33,
      noiseAmplitude: 1.7,
      secondaryFrequency: 0.19,
      secondaryAmplitude: 0.75,
      ridgeFrequency: 0.2,
      ridgeAmplitude: 0.6,
      centerHeightBias: 0.8,
      voxelBudgetMultiplier: 1.08,
      seedMultiplier: 73,
    }),
    netherite: buildTerrainProfile({
      minHeight: 2,
      maxHeight: 6,
      baseHeight: 1.45,
      falloffStrength: 3.6,
      falloffRadius: 0.6,
      falloffExponent: 1.32,
      noiseFrequency: 0.46,
      noiseAmplitude: 2.55,
      secondaryFrequency: 0.27,
      secondaryAmplitude: 1.25,
      ridgeFrequency: 0.22,
      ridgeAmplitude: 0.75,
      rimHeightBias: 0.5,
      centerHeightBias: 0.35,
      voxelBudgetMultiplier: 1.12,
      seedMultiplier: 89,
    }),
  });

  function normaliseStringSet(values, fallback) {
    const list = Array.isArray(values) && values.length ? values : fallback;
    return Array.from(
      new Set(
        list
          .map((value) => (typeof value === 'string' ? value.trim() : ''))
          .filter((value) => value.length > 0),
      ),
    );
  }

  function buildDimensionManifestEntry({
    id,
    name,
    inheritsFrom = null,
    terrain = BASE_TERRAIN_REFERENCES,
    mobs = BASE_MOB_REFERENCES,
    objects = BASE_OBJECT_REFERENCES,
    textures = BASE_TEXTURE_REFERENCES,
    models = BASE_MODEL_REFERENCES,
  }) {
    return {
      id,
      name,
      inheritsFrom,
      terrain: normaliseStringSet(terrain, BASE_TERRAIN_REFERENCES),
      mobs: normaliseStringSet(mobs, BASE_MOB_REFERENCES),
      objects: normaliseStringSet(objects, BASE_OBJECT_REFERENCES),
      assets: {
        textures: { ...(textures && typeof textures === 'object' ? textures : BASE_TEXTURE_REFERENCES) },
        models: { ...(models && typeof models === 'object' ? models : BASE_MODEL_REFERENCES) },
      },
    };
  }

  const DIMENSION_ASSET_MANIFEST = deepFreeze({
    origin: buildDimensionManifestEntry({ id: 'origin', name: 'Origin Grassland' }),
    rock: buildDimensionManifestEntry({
      id: 'rock',
      name: 'Rock Frontier',
      inheritsFrom: 'origin',
    }),
    stone: buildDimensionManifestEntry({
      id: 'stone',
      name: 'Stone Bastion',
      inheritsFrom: 'rock',
      objects: [...BASE_OBJECT_REFERENCES, 'bastion-rampart'],
    }),
    tar: buildDimensionManifestEntry({
      id: 'tar',
      name: 'Tar Marsh',
      inheritsFrom: 'stone',
      terrain: [...BASE_TERRAIN_REFERENCES, 'tar-pool'],
      mobs: [...BASE_MOB_REFERENCES, 'swamp-phantom'],
    }),
    marble: buildDimensionManifestEntry({
      id: 'marble',
      name: 'Marble Heights',
      inheritsFrom: 'tar',
      objects: [...BASE_OBJECT_REFERENCES, 'marble-bridge'],
    }),
    netherite: buildDimensionManifestEntry({
      id: 'netherite',
      name: 'Netherite Terminus',
      inheritsFrom: 'marble',
      objects: [...BASE_OBJECT_REFERENCES, 'eternal-ingot-pedestal'],
    }),
  });

  if (typeof window !== 'undefined') {
    window.InfiniteRailsDimensionManifest = DIMENSION_ASSET_MANIFEST;
  } else if (typeof globalThis !== 'undefined') {
    globalThis.InfiniteRailsDimensionManifest = DIMENSION_ASSET_MANIFEST;
  }

  if (typeof module !== 'undefined' && module.exports) {
    module.exports.DIMENSION_ASSET_MANIFEST = DIMENSION_ASSET_MANIFEST;
  }

  let cachedGltfLoaderPromise = null;

  function loadExternalScript(url) {
    return new Promise((resolve, reject) => {
      if (typeof document === 'undefined') {
        reject(new Error('Document is unavailable for script injection.'));
        return;
      }
      const existing = document.querySelector(`script[data-src="${url}"]`);
      if (existing) {
        if (existing.hasAttribute('data-loaded')) {
          resolve();
          return;
        }
        existing.addEventListener('load', () => resolve(), { once: true });
        existing.addEventListener(
          'error',
          () => reject(new Error(`Failed to load script: ${url}`)),
          { once: true },
        );
        return;
      }
      const script = document.createElement('script');
      script.src = url;
      script.async = false;
      script.dataset.src = url;
      script.addEventListener('load', () => {
        script.setAttribute('data-loaded', 'true');
        resolve();
      });
      script.addEventListener('error', () => {
        script.remove();
        reject(new Error(`Failed to load script: ${url}`));
      });
      document.head.appendChild(script);
    });
  }

  function ensureGltfLoader(THREE) {
    if (!THREE) {
      return Promise.reject(new Error('Three.js is unavailable; cannot initialise GLTFLoader.'));
    }
    if (THREE.GLTFLoader) {
      return Promise.resolve(THREE.GLTFLoader);
    }
    if (!cachedGltfLoaderPromise) {
      const scope = typeof window !== 'undefined' ? window : globalThis;
      if (!GLTF_LOADER_URL) {
        return Promise.reject(new Error('GLTFLoader asset URL is not configured.'));
      }
      cachedGltfLoaderPromise = loadExternalScript(GLTF_LOADER_URL)
        .then(() => {
          if (!THREE.GLTFLoader && scope?.GLTFLoaderModule?.GLTFLoader) {
            THREE.GLTFLoader = scope.GLTFLoaderModule.GLTFLoader;
          }
          if (!THREE.GLTFLoader) {
            throw new Error('GLTFLoader script loaded but did not register the loader.');
          }
          return THREE.GLTFLoader;
        })
        .catch((error) => {
          cachedGltfLoaderPromise = null;
          if (error?.message === 'GLTFLoader script loaded but did not register the loader.') {
            throw error;
          }
          const failureError = new Error(`Unable to load GLTFLoader from ${GLTF_LOADER_URL}.`);
          if (error && failureError !== error) {
            failureError.cause = error;
          }
          throw failureError;
        });
    }
    return cachedGltfLoaderPromise;
  }

  function buildHierarchyMap(nodes = [], map = new Map()) {
    nodes.forEach((node, index) => {
      const name = typeof node?.name === 'string' ? node.name : null;
      if (!name) {
        return;
      }
      const children = Array.isArray(node.children)
        ? node.children.map((childIndex) => nodes[childIndex]?.name).filter(Boolean)
        : [];
      map.set(name, { index, node, children });
    });
    return map;
  }

  function describeHierarchyChildren(hierarchyMap, name) {
    if (!hierarchyMap.has(name)) {
      return [];
    }
    return hierarchyMap.get(name).children.slice();
  }

  function validateSteveAvatarRig(gltf) {
    const parserJson = gltf?.parser?.json || null;
    const nodes = Array.isArray(parserJson?.nodes) ? parserJson.nodes : [];
    const meshes = Array.isArray(parserJson?.meshes) ? parserJson.meshes : [];
    const hierarchyMap = buildHierarchyMap(nodes);

    const requiredNodes = [
      'SteveRoot',
      'Hips',
      'Torso',
      'HeadPivot',
      'Head',
      'LeftArm',
      'LeftSleeve',
      'LeftHand',
      'RightArm',
      'RightSleeve',
      'RightHand',
      'LeftLeg',
      'LeftThigh',
      'LeftBoot',
      'RightLeg',
      'RightThigh',
      'RightBoot',
      'Hair',
      'Fringe',
      'LeftEye',
      'RightEye',
    ];

    const missingNodes = requiredNodes.filter((name) => !hierarchyMap.has(name));

    const meshNameByIndex = new Map(
      meshes.map((mesh, index) => [index, typeof mesh?.name === 'string' ? mesh.name : null]),
    );

    const meshExpectations = new Map([
      ['Torso', 'CubeShirt'],
      ['Head', 'CubeSkin'],
      ['LeftSleeve', 'CubeShirt'],
      ['LeftHand', 'CubeSkin'],
      ['RightSleeve', 'CubeShirt'],
      ['RightHand', 'CubeSkin'],
      ['LeftThigh', 'CubeJeans'],
      ['LeftBoot', 'CubeBoot'],
      ['RightThigh', 'CubeJeans'],
      ['RightBoot', 'CubeBoot'],
      ['Hair', 'CubeHair'],
      ['Fringe', 'CubeHair'],
      ['LeftEye', 'CubeEye'],
      ['RightEye', 'CubeEye'],
    ]);

    const meshAssignments = {};
    const meshMismatches = [];
    meshExpectations.forEach((expectedMeshName, nodeName) => {
      const nodeEntry = hierarchyMap.get(nodeName) || null;
      const meshIndex = typeof nodeEntry?.node?.mesh === 'number' ? nodeEntry.node.mesh : null;
      const meshName = meshNameByIndex.get(meshIndex) || null;
      meshAssignments[nodeName] = meshName;
      if (expectedMeshName && meshName !== expectedMeshName) {
        meshMismatches.push({ node: nodeName, expected: expectedMeshName, actual: meshName });
      }
    });

    const hierarchyExpectations = new Map([
      ['SteveRoot', ['Hips']],
      ['Hips', ['Torso', 'LeftArm', 'RightArm', 'LeftLeg', 'RightLeg']],
      ['Torso', ['HeadPivot']],
      ['HeadPivot', ['Head', 'Hair', 'Fringe', 'LeftEye', 'RightEye']],
      ['LeftArm', ['LeftSleeve', 'LeftHand']],
      ['RightArm', ['RightSleeve', 'RightHand']],
      ['LeftLeg', ['LeftThigh', 'LeftBoot']],
      ['RightLeg', ['RightThigh', 'RightBoot']],
    ]);

    const hierarchyIssues = [];
    hierarchyExpectations.forEach((expectedChildren, nodeName) => {
      const actualChildren = describeHierarchyChildren(hierarchyMap, nodeName);
      expectedChildren.forEach((childName) => {
        if (!actualChildren.includes(childName)) {
          hierarchyIssues.push({ node: nodeName, child: childName, actualChildren });
        }
      });
    });

    const hierarchy = {};
    hierarchyMap.forEach((entry, name) => {
      hierarchy[name] = entry.children.slice();
    });

    const errors = [];
    if (!parserJson) {
      errors.push('GLTF parser JSON unavailable for validation.');
    }
    if (missingNodes.length) {
      errors.push(`Missing required nodes: ${missingNodes.join(', ')}`);
    }
    if (hierarchyIssues.length) {
      const issueDescriptions = hierarchyIssues.map(
        ({ node, child, actualChildren }) =>
          `${node} missing expected child ${child} (children: ${actualChildren.join(', ') || 'none'})`,
      );
      errors.push(...issueDescriptions);
    }
    if (meshMismatches.length) {
      meshMismatches.forEach(({ node, expected, actual }) => {
        errors.push(
          `${node} references mesh ${actual || 'unknown'} instead of expected ${expected}.`,
        );
      });
    }

    const metadata = {
      valid: errors.length === 0,
      nodes: requiredNodes,
      hierarchy,
      meshAssignments,
      meshExpectations: Object.fromEntries(meshExpectations),
      meshNameByIndex: Object.fromEntries(meshNameByIndex),
      missingNodes,
      hierarchyIssues,
      meshMismatches,
      errors,
    };

    if (!metadata.valid) {
      const reason = errors[0] || 'Unknown rig validation failure.';
      const error = new Error(`Steve avatar rig validation failed: ${reason}`);
      error.code = 'STEVE_RIG_VALIDATION_FAILED';
      error.metadata = metadata;
      throw error;
    }

    return metadata;
  }

  function disposeObject3D(object) {
    if (!object || typeof object.traverse !== 'function') return;
    object.traverse((child) => {
      if (child.isMesh) {
        if (Array.isArray(child.material)) {
          child.material.forEach((material) => material?.dispose?.());
        } else {
          child.material?.dispose?.();
        }
        child.geometry?.dispose?.();
      } else if (child.isSprite) {
        const material = child.material;
        if (material) {
          material.map?.dispose?.();
          material.dispose?.();
        }
      }
    });
  }

  const ITEM_DEFINITIONS = {
    'grass-block': {
      label: 'Grass Block',
      icon: '🟩',
      placeable: true,
      description: 'Surface block with a soil base — perfect for bridging gaps.',
      textureKeys: ['grass', 'dirt'],
      materialKeys: ['grass', 'dirt'],
    },
    dirt: {
      label: 'Soil Chunk',
      icon: '🟫',
      placeable: true,
      description: 'Packed earth used for scaffolding and quick terrain fixes.',
      textureKeys: ['dirt'],
      materialKeys: ['dirt'],
    },
    stone: {
      label: 'Stone Brick',
      icon: '⬜',
      placeable: true,
      description: 'Dense masonry ideal for sturdy portal frames.',
      textureKeys: ['stone'],
      materialKeys: ['stone'],
    },
    stick: {
      label: 'Stick',
      icon: '🪵',
      placeable: false,
      description: 'Basic handle carved from wood — anchors most tools.',
      textureKeys: [],
      materialKeys: [],
    },
    'stone-pickaxe': {
      label: 'Stone Pickaxe',
      icon: '⛏️',
      placeable: false,
      equipment: true,
      description: 'Reliable pickaxe that cracks tougher ores and rails.',
      textureKeys: ['stone'],
      materialKeys: ['stone'],
    },
    'portal-charge': {
      label: 'Portal Charge',
      icon: '🌀',
      placeable: false,
      description: 'Volatile energy cell required to ignite the portal.',
      textureKeys: [],
      materialKeys: ['portal'],
    },
    'eternal-ingot': {
      label: 'Eternal Ingot',
      icon: '🔥',
      placeable: false,
      description: 'Legendary alloy that stabilises the Netherite rail network.',
      textureKeys: [],
      materialKeys: [],
    },
  };
  const DIMENSION_BADGE_SYMBOLS = {
    origin: '🌱',
    rock: '🪨',
    stone: '⛏️',
    tar: '⚫',
    marble: '🏛️',
    netherite: '🔥',
  };
  const DIMENSION_BADGE_SYNONYMS = {
    origin: ['origin', 'grass', 'plains'],
    rock: ['rock', 'basalt', 'ore'],
    stone: ['stone', 'bastion', 'fortress'],
    tar: ['tar', 'marsh', 'swamp'],
    marble: ['marble', 'temple', 'atrium'],
    netherite: ['nether', 'netherite', 'inferno'],
  };
  const DEFAULT_DIMENSION_BADGE_SYMBOL = '🌀';

  const DIMENSION_THEME = [
    {
      id: 'origin',
      name: 'Origin Grassland',
      palette: {
        grass: '#69c368',
        dirt: '#b07a42',
        stone: '#9d9d9d',
        rails: '#c9a14d',
      },
      fog: '#87ceeb',
      sky: '#87ceeb',
      sun: '#ffffff',
      hemi: '#bddcff',
      gravity: 1,
      speedMultiplier: 1,
      description:
        'Gentle plains with forgiving gravity. Harvest and craft to stabilise the portal frame.',
    },
    {
      id: 'rock',
      name: 'Rock Frontier',
      palette: {
        grass: '#7b858a',
        dirt: '#5d6468',
        stone: '#3b4248',
        rails: '#e0b072',
      },
      fog: '#65727c',
      sky: '#4d565f',
      sun: '#f6f1d9',
      hemi: '#5b748a',
      gravity: 1.35,
      speedMultiplier: 0.92,
      description:
        'Heavier steps and denser air. Keep momentum up and beware of zombies charging along the rails.',
    },
    {
      id: 'stone',
      name: 'Stone Bastion',
      palette: {
        grass: '#a0a8ad',
        dirt: '#6c7479',
        stone: '#525a60',
        rails: '#d7b16f',
      },
      fog: '#6f7b84',
      sky: '#5d6870',
      sun: '#f0e8d2',
      hemi: '#70808a',
      gravity: 1.18,
      speedMultiplier: 0.9,
      description:
        'Fortified cliffs that demand precise jumps. Blocks are dense but reward extra portal charge fragments.',
    },
    {
      id: 'tar',
      name: 'Tar Marsh',
      palette: {
        grass: '#3c3a45',
        dirt: '#2d2b33',
        stone: '#1f1e25',
        rails: '#ffb347',
      },
      fog: '#1f1a21',
      sky: '#261c2f',
      sun: '#ffb347',
      hemi: '#45364d',
      gravity: 0.85,
      speedMultiplier: 1.1,
      description:
        'Low gravity swamp. Use the extra lift to hop across gaps while night creatures emerge from the mist.',
    },
    {
      id: 'marble',
      name: 'Marble Heights',
      palette: {
        grass: '#f3f6fb',
        dirt: '#d7dce5',
        stone: '#c0c7d4',
        rails: '#ffd27f',
      },
      fog: '#cfd7e4',
      sky: '#e3e8f4',
      sun: '#ffffff',
      hemi: '#d5deef',
      gravity: 0.95,
      speedMultiplier: 1.18,
      description:
        'Floating terraces of marble that accelerate explorers. Keep your footing while rails twist in the breeze.',
    },
    {
      id: 'netherite',
      name: 'Netherite Terminus',
      palette: {
        grass: '#4c1f24',
        dirt: '#321016',
        stone: '#14070a',
        rails: '#ff7043',
      },
      fog: '#160607',
      sky: '#1a0304',
      sun: '#ff7043',
      hemi: '#471414',
      gravity: 1.15,
      speedMultiplier: 1,
      description:
        'Final gauntlet of collapsing rails. Activate the portal swiftly to claim the Eternal Ingot.',
    },
  ].map((theme) => {
    const manifest = DIMENSION_ASSET_MANIFEST[theme.id] || null;
    const terrainProfile = DIMENSION_TERRAIN_PROFILES[theme.id] || DEFAULT_TERRAIN_PROFILE;
    const themed = { ...theme, assetManifest: manifest, terrainProfile };
    ensureDimensionThemeManifestCoverage(themed);
    return themed;
  });

  function pseudoRandom(x, z) {
    const value = Math.sin(x * 127.1 + z * 311.7) * 43758.5453;
    return value - Math.floor(value);
  }

  function hashStringToSeed(value) {
    const str = String(value ?? '');
    let hash = 0;
    for (let i = 0; i < str.length; i += 1) {
      hash = (hash * 31 + str.charCodeAt(i)) >>> 0;
    }
    return hash || 1;
  }

  function createHeightmapMatrix(size, fill = 0) {
    const dimension = Math.max(0, Math.floor(size));
    return Array.from({ length: dimension }, () => Array(dimension).fill(fill));
  }

  function cloneHeightmapMatrix(matrix) {
    if (!Array.isArray(matrix)) {
      return [];
    }
    return matrix.map((row) => (Array.isArray(row) ? row.slice() : []));
  }

  function validateHeightmapMatrix(matrix, expectedSize) {
    if (!Array.isArray(matrix)) {
      return { valid: false, reason: 'not-array' };
    }
    const size = Math.max(0, Math.floor(expectedSize));
    if (matrix.length !== size) {
      return { valid: false, reason: 'row-count-mismatch', received: matrix.length, expected: size };
    }
    for (let x = 0; x < matrix.length; x += 1) {
      const row = matrix[x];
      if (!Array.isArray(row)) {
        return { valid: false, reason: 'row-not-array', index: x };
      }
      if (row.length !== size) {
        return { valid: false, reason: 'column-count-mismatch', index: x, received: row.length, expected: size };
      }
      for (let z = 0; z < row.length; z += 1) {
        const value = row[z];
        if (!Number.isFinite(value)) {
          return { valid: false, reason: 'non-finite', index: x, column: z };
        }
      }
    }
    return { valid: true, matrix };
  }

  function createShuffledIndexOrder(length, seedSource) {
    const count = Math.max(0, Math.floor(length));
    const order = Array.from({ length: count }, (_, index) => index);
    if (count <= 1) {
      return order;
    }
    const baseSeed = hashStringToSeed(seedSource);
    for (let i = count - 1; i > 0; i -= 1) {
      const seedA = baseSeed + i * 23.917;
      const seedB = baseSeed * 0.318 + i * 11.137;
      const roll = pseudoRandom(seedA, seedB);
      const swapIndex = Math.floor(roll * (i + 1));
      const tmp = order[i];
      order[i] = order[swapIndex];
      order[swapIndex] = tmp;
    }
    return order;
  }

  function getItemDefinition(id) {
    if (!id) {
      return { label: 'Empty', icon: '·', placeable: false };
    }
    return (
      ITEM_DEFINITIONS[id] || {
        label: id,
        icon: '⬜',
        placeable: false,
        description: '',
        textureKeys: [],
        materialKeys: [],
      }
    );
  }

  function normaliseVisualKeyList(value) {
    if (!value) {
      return [];
    }
    if (Array.isArray(value)) {
      return value
        .map((entry) => (typeof entry === 'string' ? entry.trim() : ''))
        .filter((entry) => entry.length > 0);
    }
    if (typeof value === 'string') {
      const trimmed = value.trim();
      return trimmed ? [trimmed] : [];
    }
    return [];
  }

  function formatInventoryLabel(item, quantity) {
    const def = getItemDefinition(item);
    const count = Number.isFinite(quantity) ? quantity : 0;
    return `${def.icon} ${def.label}${count > 1 ? ` ×${count}` : ''}`;
  }

  function createHeartMarkup(status, previousStatus = null) {
    const health = Math.max(0, Math.round(status?.health ?? 0));
    const maxHealth = Math.max(2, Math.round(status?.maxHealth ?? FALLBACK_HEALTH));
    const totalHearts = Math.max(1, Math.ceil(maxHealth / 2));
    const fullHearts = Math.floor(health / 2);
    const hasHalfHeart = health % 2 === 1;
    const heartRows = [];
    const rows = Math.ceil(totalHearts / 5);
    const containerClasses = ['hud-hearts'];
    if (previousStatus) {
      const previousHealth = Math.max(0, Math.round(previousStatus.health ?? 0));
      if (health < previousHealth) {
        containerClasses.push('is-damaged');
      } else if (health > previousHealth) {
        containerClasses.push('is-healing');
      }
    }
    if (health <= Math.max(2, Math.floor(maxHealth * 0.25))) {
      containerClasses.push('is-critical');
    }
    for (let row = 0; row < rows; row += 1) {
      const rowPieces = [];
      for (let column = 0; column < 5; column += 1) {
        const index = row * 5 + column;
        if (index >= totalHearts) {
          break;
        }
        let stateClass = '';
        if (index >= fullHearts + (hasHalfHeart ? 1 : 0)) {
          stateClass = ' is-empty';
        } else if (index === fullHearts && hasHalfHeart) {
          stateClass = ' is-partial';
        }
        rowPieces.push(
          `<span class="heart-icon${stateClass}" style="--heart-index:${index}" aria-hidden="true"></span>`,
        );
      }
      heartRows.push(`<span class="hud-hearts__row">${rowPieces.join('')}</span>`);
    }
    const remainingHearts = health / 2;
    const precision = Number.isInteger(remainingHearts) ? 0 : 1;
    const label = `${remainingHearts.toLocaleString(undefined, {
      minimumFractionDigits: precision,
      maximumFractionDigits: precision,
    })} hearts remaining`;
    return `<div class="${containerClasses.join(' ')}" role="img" aria-label="${label}">${heartRows.join('')}</div>`;
  }

  function createBubbleMarkup(status, previousStatus = null) {
    const breath = Math.max(0, Math.round(status?.breath ?? 0));
    const maxBreath = Math.max(1, Math.round(status?.maxBreath ?? FALLBACK_BREATH));
    const totalBubbles = Math.max(1, Math.min(5, Math.ceil(maxBreath / 2)));
    const activeBubbles = Math.max(0, Math.min(totalBubbles, Math.ceil(breath / 2)));
    const hasPartialBubble = breath % 2 === 1 && activeBubbles > 0 && activeBubbles <= totalBubbles;
    const classes = ['hud-bubbles'];
    if (previousStatus) {
      const previousBreath = Math.max(0, Math.round(previousStatus.breath ?? 0));
      if (breath < previousBreath) {
        classes.push('is-losing');
      }
    }
    if ((status?.breathPercent ?? 100) <= 35) {
      classes.push('is-low');
    }
    const stack = [];
    for (let index = 0; index < totalBubbles; index += 1) {
      let stateClass = '';
      if (index >= activeBubbles) {
        stateClass = ' is-empty';
      } else if (index === activeBubbles - 1 && hasPartialBubble) {
        stateClass = ' is-partial';
      }
      stack.push(
        `<span class="bubble-indicator${stateClass}" style="--bubble-index:${index}" aria-hidden="true"></span>`,
      );
    }
    const percent = Math.max(0, Math.min(100, Math.round(status?.breathPercent ?? 0)));
    return `
      <div class="${classes.join(' ')}" role="img" aria-label="${percent}% breath remaining">
        <span class="hud-bubbles__frame">
          <span class="hud-bubbles__stack">${stack.join('')}</span>
        </span>
        <span class="hud-bubbles__value">${percent}%</span>
      </div>
    `.trim();
  }

  function escapeHtml(value) {
    return String(value)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  const simpleExperienceControlMap = (() => {
    const localListeners = new Set();
    const upstream =
      scope?.InfiniteRailsControls && typeof scope.InfiniteRailsControls === 'object'
        ? scope.InfiniteRailsControls
        : null;

    const getDefaultsSnapshot = () => {
      if (upstream && typeof upstream.defaults === 'function') {
        const defaults = upstream.defaults();
        if (defaults) {
          return cloneKeyBindingMap(defaults);
        }
      }
      return cloneKeyBindingMap(DEFAULT_KEY_BINDINGS);
    };

    let currentMapSource = null;
    if (upstream && typeof upstream.get === 'function') {
      currentMapSource = upstream.get();
    }
    if (!currentMapSource && scope && scope[CONTROL_MAP_GLOBAL_KEY]) {
      currentMapSource = scope[CONTROL_MAP_GLOBAL_KEY];
    }
    if (!currentMapSource && scope?.APP_CONFIG && typeof scope.APP_CONFIG === 'object') {
      currentMapSource = scope.APP_CONFIG.controlMap || null;
    }
    let currentMap = cloneKeyBindingMap(currentMapSource || DEFAULT_KEY_BINDINGS);

    const notify = (map) => {
      const snapshot = cloneKeyBindingMap(map || DEFAULT_KEY_BINDINGS);
      currentMap = snapshot;
      updateAmbientControlMap(snapshot);
      activeSimpleExperiences.forEach((instance) => applyControlMapToExperience(instance, snapshot));
      localListeners.forEach((listener) => {
        if (typeof listener !== 'function') {
          return;
        }
        try {
          listener(cloneKeyBindingMap(snapshot));
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Control map listener failed.', error);
          }
        }
      });
    };

    notify(currentMap);

    if (upstream && typeof upstream.subscribe === 'function') {
      upstream.subscribe((map) => {
        if (map) {
          notify(map);
        }
      });
    }

    return {
      get() {
        return cloneKeyBindingMap(currentMap);
      },
      defaults() {
        return getDefaultsSnapshot();
      },
      apply(update, options = {}) {
        if (upstream && typeof upstream.apply === 'function') {
          const result = upstream.apply(update, options);
          if (result) {
            notify(result);
            return cloneKeyBindingMap(result);
          }
          return null;
        }
        if (!update || typeof update !== 'object') {
          return null;
        }
        const entries = {};
        let hasEntries = false;
        Object.entries(update).forEach(([action, value]) => {
          if (typeof action !== 'string' || !action.trim()) {
            return;
          }
          const trimmedAction = action.trim();
          if (typeof value === 'string' || Array.isArray(value)) {
            const keys = normaliseKeyBindingValue(value);
            if (Array.isArray(value) && !keys.length) {
              entries[trimmedAction] = [];
              hasEntries = true;
              return;
            }
            if (keys.length) {
              entries[trimmedAction] = keys;
              hasEntries = true;
            }
          }
        });
        if (!hasEntries) {
          return null;
        }
        const merged = cloneKeyBindingMap(currentMap);
        Object.entries(entries).forEach(([action, keys]) => {
          merged[action] = [...keys];
        });
        notify(merged);
        return cloneKeyBindingMap(merged);
      },
      reset(options = {}) {
        if (upstream && typeof upstream.reset === 'function') {
          const result = upstream.reset(options);
          if (result) {
            notify(result);
            return cloneKeyBindingMap(result);
          }
          return null;
        }
        const defaults = getDefaultsSnapshot();
        notify(defaults);
        return cloneKeyBindingMap(defaults);
      },
      subscribe(listener) {
        if (typeof listener !== 'function') {
          return () => {};
        }
        localListeners.add(listener);
        try {
          listener(cloneKeyBindingMap(currentMap));
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Control map listener failed during subscription.', error);
          }
        }
        return () => {
          localListeners.delete(listener);
        };
      },
    };
  })();

  class SimpleExperience {
    constructor(options) {
      if (!options || !options.canvas) {
        throw new Error('SimpleExperience requires a target canvas element.');
      }
      const appConfig =
        scope?.APP_CONFIG && typeof scope.APP_CONFIG === 'object' ? scope.APP_CONFIG : null;
      const THREE = scope?.THREE_GLOBAL || null;
      const resolvedThree = THREE || scope?.THREE || null;
      if (!resolvedThree) {
        throw new Error('Three.js is required for the simplified experience.');
      }
      this.THREE = resolvedThree;
      if (resolvedThree?.Cache && resolvedThree.Cache.enabled !== true) {
        resolvedThree.Cache.enabled = true;
        resolvedThree.Cache.autoClear = false;
      }
      this.canvas = options.canvas;
      this.ui = options.ui || {};
      this.developerOverlayWarningIssued = false;
      this.victoryBannerEl = this.ui.victoryBanner || null;
      this.victoryCelebrationEl = this.ui.victoryCelebration || null;
      this.victoryConfettiEl = this.ui.victoryConfetti || null;
      this.victoryFireworksEl = this.ui.victoryFireworks || null;
      this.victoryMessageEl = this.ui.victoryMessageEl || null;
      this.victoryStatsEl = this.ui.victoryStatsEl || null;
      this.victoryShareButton = this.ui.victoryShareButton || null;
      this.victoryCloseButton = this.ui.victoryCloseButton || null;
      this.victoryShareStatusEl = this.ui.victoryShareStatusEl || null;
      this.apiBaseUrl = normaliseApiBaseUrl(options.apiBaseUrl || null);
      this.playerDisplayName = (options.playerName || '').trim() || 'Explorer';
      this.defaultPlayerName = this.playerDisplayName;
      this.playerGoogleId = null;
      this.playerEmail = null;
      this.playerAvatarUrl = null;
      this.playerLocation = null;
      this.playerLocationLabel = 'Location hidden';
      this.playerBreathCapacity = FALLBACK_BREATH;
      this.playerBreath = this.playerBreathCapacity;
      this.identityStorageKey = options.identityStorageKey || IDENTITY_STORAGE_KEY;
      this.identityHydrating = false;
      this.locationRequestCooldownSeconds = Math.max(
        15,
        Number.isFinite(options.locationRequestCooldownSeconds)
          ? Number(options.locationRequestCooldownSeconds)
          : 45,
      );
      this.lastLocationRequestAt = 0;
      this.pendingLocationRequest = null;
      this.deviceLabel = this.describeDevice();
      this.scene = null;
      this.worldRoot = null;
      this.camera = null;
      this.cameraFrustumHeight = 6;
      this.cameraFieldOfView = 60;
      this.renderer = null;
      this.sunLight = null;
      this.hemiLight = null;
      this.moonLight = null;
      this.ambientLight = null;
      this.daySkyColor = new THREE.Color('#87ceeb');
      this.nightSkyColor = new THREE.Color('#0b1738');
      this.duskSkyColor = new THREE.Color('#ff9a64');
      this.dayFogColor = new THREE.Color('#87ceeb');
      this.nightFogColor = new THREE.Color('#0f182f');
      this.daySunColor = new THREE.Color('#fff4cc');
      this.nightMoonColor = new THREE.Color('#8ea2ff');
      this.dayGroundColor = new THREE.Color('#3e4e2a');
      this.nightGroundColor = new THREE.Color('#101522');
      this.tmpColorA = new THREE.Color();
      this.tmpColorB = new THREE.Color();
      this.terrainGroup = null;
      this.railsGroup = null;
      this.portalGroup = null;
      this.zombieGroup = null;
      this.portalMechanics = PORTAL_MECHANICS;
      this.playerRig = null;
      this.playerChunkKey = null;
      this.playerPhysicsBody = null;
      this.playerPhysicsRadius = 0.6;
      this.playerPhysicsHeight = PLAYER_EYE_HEIGHT + 0.4;
      this.playerPhysicsCenterOffset = -PLAYER_EYE_HEIGHT * 0.5;
      this.cameraBoom = null;
      this.handGroup = null;
      this.handMaterials = [];
      this.handMaterialsDynamic = true;
      this.handModelLoaded = false;
      this.leftHandGroup = null;
      this.rightHandGroup = null;
      this.handItemAnchor = null;
      this.equippedItemMesh = null;
      this.equippedItemId = null;
      this.equippedItemQuantity = 0;
      this.pendingEquippedItemId = null;
      this.portalShaderFallbackActive = false;
      this.portalFallbackPulse = 0;
      this.lightingFallbackPending = false;
      this.lightingFallbackActive = false;
      this.playerAvatar = null;
      this.playerMixer = null;
      this.playerIdleAction = null;
      this.playerAnimationRig = null;
      this.playerAvatarLoaded = false;
      this.handSwingStrength = 0;
      this.handSwingTimer = 0;
      this.modelPromises = new Map();
      this.loadedModels = new Map();
      this.dimensionLootCache = new Map();
      this.dimensionLootOrders = new Map();
      this.dimensionLootOrderOffsets = new Map();
      this.ensureDimensionLootTablesLoaded();
      this.dimensionBadgeSymbols = DIMENSION_BADGE_SYMBOLS;
      this.scoreboardListEl = this.ui.scoreboardListEl || null;
      this.scoreboardStatusEl = this.ui.scoreboardStatusEl || null;
      this.refreshScoresButton = this.ui.refreshScoresButton || null;
      this.scoreboardContainer = this.scoreboardListEl?.closest('#leaderboardTable') || null;
      this.scoreboardEmptyEl =
        (typeof document !== 'undefined' && document.getElementById('leaderboardEmptyMessage')) || null;
      this.scoreboardPollIntervalSeconds = 45;
      this.scoreboardPollTimer = 0;
      this.scoreboardStorageKey = options.scoreboardStorageKey || SCOREBOARD_STORAGE_KEY;
      this.scoreSyncQueueKey = options.scoreSyncQueueKey || SCORE_SYNC_QUEUE_STORAGE_KEY;
      this.scoreSyncQueue = this.restoreScoreSyncQueue();
      const docRef = typeof document !== 'undefined' ? document : null;
      this.scorePanelEl = this.ui.scorePanelEl || docRef?.getElementById('scorePanel') || null;
      this.scoreMetricElements = {
        recipes: this.ui.scoreRecipesEl || null,
        dimensions: this.ui.scoreDimensionsEl || null,
        portal: this.ui.scorePortalsEl || null,
        combat: this.ui.scoreCombatEl || null,
        loot: this.ui.scoreLootEl || null,
      };
      this.scoreSyncWarningEl = this.ui.scoreSyncWarningEl || null;
      this.scoreSyncWarningMessageEl = this.ui.scoreSyncWarningMessageEl || null;
      this.scoreMetricFlashTimers = new Map();
      this.lastPlayerStatusSnapshot = null;
      this.craftingScoreEvents = 0;
      this.dimensionScoreEvents = 0;
      this.portalScoreEvents = 0;
      this.combatScoreEvents = 0;
      this.lootScoreEvents = 0;
      this.lastScoreboardFetch = 0;
      this.offlineSyncActive = false;
      this.lastOfflineSyncHintAt = 0;
      this.offlineSyncHintCooldownMs = 16000;
      this.lastPublishedStateSignature = null;
      this.hotbarEl = this.ui.hotbarEl || null;
      this.handOverlayEl = this.ui.handOverlayEl || null;
      this.handOverlayIconEl = this.ui.handOverlayIconEl || null;
      this.handOverlayLabelEl = this.ui.handOverlayLabelEl || null;
      this.playerHintEl = this.ui.playerHintEl || null;
      this.pointerHintEl = this.ui.pointerHintEl || null;
      this.footerEl = this.ui.footerEl || null;
      this.footerScoreEl = this.ui.footerScoreEl || null;
      this.footerDimensionEl = this.ui.footerDimensionEl || null;
      this.footerStatusEl = this.ui.footerStatusEl || null;
      this.assetRecoveryOverlayEl = this.ui.assetRecoveryOverlay || null;
      this.assetRecoveryDialogEl = this.ui.assetRecoveryDialogEl || null;
      this.assetRecoveryTitleEl = this.ui.assetRecoveryTitleEl || null;
      this.assetRecoveryMessageEl = this.ui.assetRecoveryMessageEl || null;
      this.assetRecoveryActionsEl = this.ui.assetRecoveryActionsEl || null;
      this.assetRecoveryRetryButton = this.ui.assetRecoveryRetryButton || null;
      this.assetRecoveryReloadButton = this.ui.assetRecoveryReloadButton || null;
      this.startButtonEl = this.ui.startButton || null;
      this.openTutorialButton = this.ui.openTutorialButton || null;
      this.openGuideButton = this.ui.openGuideButton || null;
      this.guideModalEl = this.ui.guideModal || null;
      this.guideCloseButtons = Array.isArray(this.ui.guideCloseButtons)
        ? this.ui.guideCloseButtons.filter(Boolean)
        : [];
      this.guideScrollContainer = this.ui.guideScrollContainer || null;
      this.guideCardEl = this.ui.guideCardEl || null;
      this.guidePrevButton = this.ui.guidePrevButton || null;
      this.guideNextButton = this.ui.guideNextButton || null;
      this.guideDotsContainer = this.ui.guideDotsContainer || null;
      this.guideDotButtons = [];
      this.guideSlides = GAME_GUIDE_SLIDES;
      this.activeGuideIndex = 0;
      this.lastGuideTrigger = null;
      this.guideModalVisible = false;
      this.introModalEl = this.ui.introModal || null;
      if (this.introModalEl && this.introModalEl.hidden !== true) {
        activateOverlayIsolation(this.introModalEl);
      }
      this.hudRootEl = this.ui.hudRootEl || null;
      this.pointerHintActive = false;
      this.pointerHintHideTimer = null;
      this.pointerHintAutoDismissTimer = null;
      this.pointerHintLastMessage = '';
      this.pointerLockFallbackActive = false;
      this.pointerLockWarningShown = false;
      this.pointerLockFallbackNoticeShown = false;
      this.pointerLockFallbackMessageActive = false;
      this.pointerLockRetryTimer = null;
      this.pointerLockRetryAttempts = 0;
      this.pointerLockBlockWarningIssued = false;
      this.pointerFallbackDragging = false;
      this.pointerFallbackLast = null;
      this.pointerFallbackButton = null;
      this.firstRunTutorialEl = this.ui?.firstRunTutorial || null;
      this.firstRunTutorialBackdrop = this.ui?.firstRunTutorialBackdrop || null;
      this.firstRunTutorialCloseButton = this.ui?.firstRunTutorialCloseButton || null;
      this.firstRunTutorialPrimaryButton = this.ui?.firstRunTutorialPrimaryButton || null;
      this.firstRunTutorialMoveDetail = this.ui?.firstRunTutorialMoveDetail || null;
      this.firstRunTutorialGatherDetail = this.ui?.firstRunTutorialGatherDetail || null;
      this.firstRunTutorialCraftDetail = this.ui?.firstRunTutorialCraftDetail || null;
      this.firstRunTutorialIssuesEl = this.ui?.firstRunTutorialIssues || null;
      this.firstRunTutorialIssuesListEl = this.ui?.firstRunTutorialIssuesList || null;
      this.firstRunTutorialNoteEl = this.ui?.firstRunTutorialNote || null;
      this.firstRunTutorialControlsBound = false;
      this.firstRunTutorialHideTimer = null;
      this.firstRunTutorialMarkOnDismiss = false;
      this.firstRunTutorialShowBriefingOnDismiss = false;
      this.renderedFrameCount = 0;
      this.blankFrameDetectionState = {
        enabled: true,
        samples: 0,
        clearFrameMatches: 0,
        triggered: false,
      };
      this.firstRunTutorialSeenCache = null;
      this.onFirstRunTutorialClose = this.handleFirstRunTutorialClose.bind(this);
      this.onFirstRunTutorialKeyDown = this.handleFirstRunTutorialKeyDown.bind(this);
      this.majorIssueLog = [];
      this.majorIssueKeys = new Set();
      this.assetFailureNotices = new Set();
      this.eventFailureNotices = new Set();
      this.eventBindingFailureNotices = new Set();
      this.eventBindingFailures = [];
      this.gameplayAtomicVersion = 0;
      this.lastGameplayInstabilityReason = null;
      this.aiAttachmentFailureAnnounced = false;
      this.boundEventDisposers = [];
      this.boundEventRecords = [];
      this.onOpenCraftingSearchClick = () => this.toggleCraftingSearch(true);
      this.onCloseCraftingSearchClick = () => this.toggleCraftingSearch(false);
      this.lastHintMessage = '';
      this.craftingModal = this.ui.craftingModal || null;
      this.craftSequenceEl = this.ui.craftSequenceEl || null;
      this.craftingInventoryEl = this.ui.craftingInventoryEl || null;
      this.craftSuggestionsEl = this.ui.craftSuggestionsEl || null;
      this.craftButton = this.ui.craftButton || null;
      this.clearCraftButton = this.ui.clearCraftButton || null;
      this.craftLauncherButton = this.ui.craftLauncherButton || null;
      this.closeCraftingButton = this.ui.closeCraftingButton || null;
      this.craftingSearchPanel = this.ui.craftingSearchPanel || null;
      this.craftingSearchInput = this.ui.craftingSearchInput || null;
      this.craftingSearchResultsEl = this.ui.craftingSearchResultsEl || null;
      this.craftingHelperEl = this.ui.craftingHelperEl || null;
      this.craftingHelperTitleEl = this.ui.craftingHelperTitleEl || null;
      this.craftingHelperDescriptionEl = this.ui.craftingHelperDescriptionEl || null;
      this.craftingHelperMatchesEl = this.ui.craftingHelperMatchesEl || null;
      this.craftingHelperOverride = null;
      this.openCraftingSearchButton = this.ui.openCraftingSearchButton || null;
      this.closeCraftingSearchButton = this.ui.closeCraftingSearchButton || null;
      this.inventoryModal = this.ui.inventoryModal || null;
      this.inventoryGridEl = this.ui.inventoryGridEl || null;
      this.inventorySortButton = this.ui.inventorySortButton || null;
      this.inventoryOverflowEl = this.ui.inventoryOverflowEl || null;
      this.closeInventoryButton = this.ui.closeInventoryButton || null;
      const openInventorySource = this.ui.openInventoryButtons || [];
      this.openInventoryButtons = Array.isArray(openInventorySource)
        ? openInventorySource
        : Array.from(openInventorySource);
      this.hotbarExpandButton = this.ui.hotbarExpandButton || null;
      this.extendedInventoryEl = this.ui.extendedInventoryEl || null;
      this.hotbarExpanded = false;
      this.activeHotbarDrag = null;
      this.activeHotbarPointerDrag = null;
      this.ignoreNextHotbarClick = false;
      this.columns = new Map();
      this.heightMap = Array.from({ length: WORLD_SIZE }, () => Array(WORLD_SIZE).fill(0));
      this.blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      this.railGeometry = new THREE.BoxGeometry(BLOCK_SIZE * 0.9, BLOCK_SIZE * 0.15, BLOCK_SIZE * 1.2);
      this.safeSpawnBoxGroup = null;
      this.totalWorldFailureActive = false;
      this.textureCache = new Map();
      this.defaultVoxelTexturePalettes = new Map();
      this.textureLoader = null;
      this.pendingTextureLoads = new Map();
      this.texturePackErrorCount = 0;
      this.texturePackNoticeShown = false;
      this.textureFallbackMissingKeys = new Set();
      this.textureRetryAttempts = new Map();
      this.textureRetryHandles = new Map();
      this.textureRetrySchedules = new Map();
      this.textureUpgradeTargets = new Map();
      this.texturePackUnavailable = false;
      const optionRetryMs = resolveTextureRetryIntervalMs(options || {});
      const configRetryMs = resolveTextureRetryIntervalMs(appConfig || {});
      this.texturePackRetryIntervalMs = optionRetryMs ?? configRetryMs ?? 60000;
      this.lastTextureFallbackMessage = '';
      this.texturePackErrorNoticeThreshold = Math.max(
        1,
        Number.isFinite(options.texturePackErrorNoticeThreshold)
          ? Math.floor(options.texturePackErrorNoticeThreshold)
          : TEXTURE_PACK_ERROR_NOTICE_THRESHOLD,
      );
      this.minColumnHeight = MIN_COLUMN_HEIGHT;
      const requestedMaxColumnHeight = Number.isFinite(options.maxColumnHeight)
        ? Math.floor(options.maxColumnHeight)
        : MAX_COLUMN_HEIGHT;
      this.maxColumnHeight = Math.max(this.minColumnHeight, requestedMaxColumnHeight);
      const minVoxelBudget = WORLD_SIZE * WORLD_SIZE * this.minColumnHeight;
      const requestedVoxelBudget = Number.isFinite(options.maxTerrainVoxels)
        ? Math.max(0, Math.floor(options.maxTerrainVoxels))
        : DEFAULT_TERRAIN_VOXEL_CAP;
      const maxTerrainCap = Math.min(MAX_TERRAIN_VOXELS, DEFAULT_TERRAIN_VOXEL_CAP);
      this.maxTerrainVoxels = Math.max(
        minVoxelBudget,
        Math.min(requestedVoxelBudget, maxTerrainCap),
      );
      this.baseTerrainConfig = {
        minColumnHeight: this.minColumnHeight,
        maxColumnHeight: this.maxColumnHeight,
        voxelBudget: this.maxTerrainVoxels,
      };
      this.renderAccumulator = 0;
      this.frameStats = {
        fps: 0,
        framesSinceSample: 0,
        lastSampleTimestamp: 0,
        sampleWindowMs: 500,
      };
      this.renderActiveInterval = 1 / 60;
      this.renderIdleInterval = 1 / 30;
      this.renderIdleThresholdSeconds = 2.5;
      const now = typeof performance !== 'undefined' ? performance.now() : Date.now();
      this.lastInteractionTimeMs = now;
      this.lostGuidanceEl = this.ui.lostGuidanceBanner || null;
      this.lostGuidanceDismissButton = this.ui.lostGuidanceDismissButton || null;
      this.lostGuidanceMoveKeysEl = this.ui.lostGuidanceMoveKeys || null;
      this.lostGuidanceGatherKeysEl = this.ui.lostGuidanceGatherKeys || null;
      this.lostGuidanceCraftKeyEl = this.ui.lostGuidanceCraftKey || null;
      this.lostGuidancePortalKeysEl = this.ui.lostGuidancePortalKeys || null;
      this.lostGuidanceVisible = false;
      this.lostGuidanceDismissedUntilProgress = false;
      this.lostGuidanceAutoHideHandle = null;
      this.lostGuidanceLastProgressAt = now;
      this.lostGuidanceLastShowAt = 0;
      this.lostGuidanceShowCount = 0;
      const firstGuidanceThreshold = Number.isFinite(options.lostGuidanceFirstThresholdSeconds)
        ? options.lostGuidanceFirstThresholdSeconds
        : Number.isFinite(Number.parseFloat(options.lostGuidanceFirstThresholdSeconds))
          ? Number.parseFloat(options.lostGuidanceFirstThresholdSeconds)
          : 45;
      const repeatGuidanceThreshold = Number.isFinite(options.lostGuidanceRepeatThresholdSeconds)
        ? options.lostGuidanceRepeatThresholdSeconds
        : Number.isFinite(Number.parseFloat(options.lostGuidanceRepeatThresholdSeconds))
          ? Number.parseFloat(options.lostGuidanceRepeatThresholdSeconds)
          : 90;
      const cooldownSeconds = Number.isFinite(options.lostGuidanceCooldownSeconds)
        ? options.lostGuidanceCooldownSeconds
        : Number.isFinite(Number.parseFloat(options.lostGuidanceCooldownSeconds))
          ? Number.parseFloat(options.lostGuidanceCooldownSeconds)
          : 35;
      this.lostGuidanceFirstThresholdSeconds = Math.max(20, firstGuidanceThreshold);
      this.lostGuidanceRepeatThresholdSeconds = Math.max(
        this.lostGuidanceFirstThresholdSeconds,
        repeatGuidanceThreshold,
      );
      this.lostGuidanceCooldownSeconds = Math.max(20, cooldownSeconds);
      this.onLostGuidanceDismiss = this.handleLostGuidanceDismiss.bind(this);
      this.lazyAssetLoading = options.lazyAssetLoading !== false;
      this.lazyModelWarmupQueue = [];
      this.lazyModelWarmupHandle = null;
      this.assetLoadBudgetMs = Number.isFinite(options.assetLoadBudgetMs)
        ? Math.max(500, options.assetLoadBudgetMs)
        : 3000;
      this.assetLoadTimers = {
        textures: new Map(),
        models: new Map(),
      };
      this.assetDelayHandles = {
        textures: new Map(),
        models: new Map(),
      };
      this.assetDelayIndicatorThresholdMs = Number.isFinite(options.assetDelayIndicatorThresholdMs)
        ? Math.max(1000, options.assetDelayIndicatorThresholdMs)
        : 1000;
      this.assetLoadLog = [];
      this.criticalAssetAvailabilityPromise = null;
      this.lastCriticalAssetAvailabilitySummary = null;
      this.criticalAssetPreloadPromise = null;
      this.criticalAssetPreloadFailed = false;
      this.criticalAssetPreloadComplete = false;
      this.enforceAssetPreloadStrictness = false;
      this.assetFailureCounts = new Map();
      this.assetRetryState = new Map();
      this.assetRecoveryPendingKeys = new Set();
      this.assetRecoveryPromptActive = false;
      this.assetRecoveryControlsBound = false;
      this.assetDelayNotices = new Set();
      this.assetRetryLimit = Number.isFinite(options.assetRetryLimit)
        ? Math.max(1, Math.floor(options.assetRetryLimit))
        : 3;
      this.assetRetryBackoffMs = Number.isFinite(options.assetRetryBackoffMs)
        ? Math.max(100, Math.floor(options.assetRetryBackoffMs))
        : 700;
      this.assetRetryBackoffMaxMs = Number.isFinite(options.assetRetryBackoffMaxMs)
        ? Math.max(this.assetRetryBackoffMs, Math.floor(options.assetRetryBackoffMaxMs))
        : 4000;
      this.assetRecoveryPromptThreshold = Math.max(
        2,
        Number.isFinite(options.assetRecoveryPromptThreshold)
          ? Math.floor(options.assetRecoveryPromptThreshold)
          : 2,
      );
      this.onAssetRecoveryRetryClick = (event) => {
        if (event?.preventDefault) {
          event.preventDefault();
        }
        this.handleAssetRecoveryRetry();
      };
      this.onAssetRecoveryReloadClick = (event) => {
        if (event?.preventDefault) {
          event.preventDefault();
        }
        this.handleAssetRecoveryReload();
      };
      this.bindAssetRecoveryControls();
      this.materials = this.createMaterials();
      this.defaultKeyBindings = cloneKeyBindingMap(DEFAULT_KEY_BINDINGS);
      this.configKeyBindingOverrides = normaliseKeyBindingMap(appConfig?.keyBindings) || null;
      this.optionKeyBindingOverrides = normaliseKeyBindingMap(options.keyBindings) || null;
      this.controlMapBase = cloneKeyBindingMap(simpleExperienceControlMap.get());
      this.baseKeyBindings = mergeKeyBindingMaps(
        this.defaultKeyBindings,
        this.controlMapBase,
        this.configKeyBindingOverrides,
        this.optionKeyBindingOverrides,
      );
      this.keyBindings = this.buildKeyBindings({ includeStored: true });
      this.ensureMovementBindingsConfigured();
      this.keys = new Set();
      this.velocity = new THREE.Vector3();
      this.tmpForward = new THREE.Vector3();
      this.tmpRight = new THREE.Vector3();
      this.tmpVector = new THREE.Vector3();
      this.tmpVector2 = new THREE.Vector3();
      this.tmpVector3 = new THREE.Vector3();
      this.tmpVector4 = new THREE.Vector3();
      this.mobCollisionVector = new THREE.Vector3();
      this.mobCollisionVector2 = new THREE.Vector3();
      this.tmpQuaternion = new THREE.Quaternion();
      this.movementBindingDiagnostics = {
        pending: false,
        triggeredAt: 0,
        timeoutMs: 650,
        noticeThrottleMs: 1500,
        lastNoticeAt: 0,
        initialPosition: new THREE.Vector3(),
        initialAvatarPosition: new THREE.Vector3(),
        anchorProbe: new THREE.Vector3(),
        avatarProbe: new THREE.Vector3(),
        key: null,
        source: null,
      };
      this.cameraBaseOffset = new THREE.Vector3();
      this.cameraShakeOffset = new THREE.Vector3();
      this.cameraShakeRotation = new THREE.Euler();
      this.cameraShakeNoise = new THREE.Vector3();
      this.cameraShakeDuration = 0;
      this.cameraShakeTime = 0;
      this.cameraShakeIntensity = 0;
      this.cameraPerspective = 'first';
      this.firstPersonCameraOffset = new THREE.Vector3(0, 0.08, 0.04);
      this.thirdPersonCameraOffset = new THREE.Vector3(0, 0.8, 3.4);
      this.sessionToken = 0;
      this.activeSessionId = 0;
      this.playerHeadAttachment = null;
      this.unloadBeaconSent = false;
      this.pointerLocked = false;
      this.yaw = Math.PI;
      this.pitch = 0;
      // Begin the day/night cycle at mid-day so the HUD daylight bar starts at 50%.
      this.elapsed = DAY_LENGTH_SECONDS * 0.5;
      this.health = FALLBACK_HEALTH;
      this.score = 0;
      this.scoreBreakdown = {
        recipes: 0,
        dimensions: 0,
        portal: 0,
        loot: 0,
        exploration: 0,
        combat: 0,
        misc: 0,
        penalties: 0,
      };
      this.blocksMined = 0;
      this.blocksPlaced = 0;
      this.portalBlocksPlaced = 0;
      this.portalActivated = false;
      this.portalReady = false;
      this.portalMesh = null;
      this.portalActivations = 0;
      this.portalHintShown = false;
      this.portalState = null;
      this.portalIgnitionLog = this.portalShaderFallbackActive
        ? [PORTAL_SHADER_FALLBACK_ANNOUNCEMENT]
        : [];
      this.dimensionLifecycleHooks = {
        exit: new Set(),
        enter: new Set(),
        ready: new Set(),
      };
      this.portalStatusState = 'inactive';
      if (this.portalShaderFallbackActive) {
        this.portalStatusMessage = PORTAL_SHADER_FALLBACK_ANNOUNCEMENT;
        this.portalStatusLabel = 'Portal Fallback';
      } else {
        this.portalStatusMessage = '';
        this.portalStatusLabel = '';
      }
      this.portalStatusFlashTimer = null;
      this.dimensionIntroAutoHideTimer = null;
      this.dimensionIntroFadeTimer = null;
      this.victoryAchieved = false;
      this.currentDimensionIndex = 0;
      this.dimensionSettings = DIMENSION_THEME[0];
      this.dimensionTerrainProfile = this.dimensionSettings?.terrainProfile || DEFAULT_TERRAIN_PROFILE;
      this.applyTerrainProfileToCaps(this.dimensionTerrainProfile);
      this.chestGroup = null;
      this.chests = [];
      this.activeChestId = null;
      this.chestPulseTime = 0;
      this.lastChestHintAt = 0;
      this.currentSpeed = PLAYER_BASE_SPEED;
      this.gravityScale = this.dimensionSettings.gravity;
      this.verticalVelocity = 0;
      this.isGrounded = false;
      this.portalAnchor = new THREE.Vector3(0, 0, -WORLD_SIZE * 0.45);
      this.initialHeightMap = [];
      this.portalAnchorGrid = this.computePortalAnchorGrid();
      this.portalFrameLayout = this.createPortalFrameLayout();
      this.portalFrameSlots = new Map();
      this.portalGhostMeshes = new Map();
      this.portalPreviewSummary = null;
      this.portalFrameRequiredCount = PORTAL_BLOCK_REQUIREMENT;
      this.portalFrameInteriorValid = false;
      this.portalFrameFootprintValid = false;
      this.portalFrameValidationMessage = '';
      this.portalFrameHighlightMeshes = new Set();
      this.portalHiddenInterior = [];
      this.portalFootprintObstructed = false;
      this.portalFootprintObstructionSummary = '';
      this.portalDebugBypassObstructions = false;
      this.challengeGroup = null;
      this.railSegments = [];
      this.crumblingRails = [];
      this.netheriteChallengePlanned = false;
      this.netheriteChallengeActive = false;
      this.netheriteChallengeTimer = 0;
      this.netheriteCollapseInterval = 3.5;
      this.netheriteNextCollapse = 0;
      this.netheriteCollapseIndex = 0;
      this.netheriteCountdownSeconds = 45;
      this.netheriteCountdownDisplay = Infinity;
      this.netheriteFailureAnnounced = false;
      this.eternalIngot = null;
      this.eternalIngotCollected = false;
      this.eternalIngotSpin = 0;
      this.eternalIngotBaseY = 0;
      this.terrainChunkSize = 8;
      this.terrainChunkGroups = [];
      this.terrainChunkMap = new Map();
      this.dirtyTerrainChunks = new Set();
      this.navigationMeshes = new Map();
      this.dirtyNavigationChunks = new Set();
      this.navigationMeshGeneration = 0;
      this.navigationMeshBuildCounter = 0;
      this.navigationMeshSummary = { chunkCount: 0, walkableCells: 0, reason: 'init', updatedAt: 0 };
      this.aiMovementWarningLog = new Map();
      this.navigationMeshMaintenanceHandle = null;
      this.navigationMeshMaintenanceCancel = null;
      this.navigationMeshMaintenanceReason = null;
      this.chunkFrustum = new THREE.Frustum();
      this.chunkFrustumMatrix = new THREE.Matrix4();
      this.terrainCullingAccumulator = 0;
      this.terrainCullingInterval = 0.08;
      this.lastCullingCameraPosition = new THREE.Vector3();
      this.lastCullingCameraQuaternion = new THREE.Quaternion();
      this.lastCullingCameraValid = false;
      this.debugChunkCulling = this.detectChunkDebugFlag();
      this.lastCullingDebugLog = 0;
      this.zombies = [];
      this.lastZombieSpawn = 0;
      this.zombieIdCounter = 0;
      this.zombieGeometry = null;
      this.golems = [];
      this.golemGroup = null;
      this.lastGolemSpawn = 0;
      this.scoreboardUtils = window.ScoreboardUtils || null;
      this.scoreEntries = [];
      this.restoredScoreEntryIdentifiers = new Set();
      this.pendingRestoredScoreMerge = false;
      this.scoreboardCacheExpired = false;
      this.restoreScoreboardEntries();
      this.sessionId =
        (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
          ? crypto.randomUUID()
          : `run-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`);
      this.scoreSyncInFlight = false;
      this.pendingScoreSyncReason = null;
      this.lastScoreSyncAt = 0;
      this.scoreSyncCooldownSeconds = 6;
      this.scoreboardHydrated = false;
      this.scoreSyncHeartbeat = 0;
      this.scoreboardOffline = false;
      this.localLeaderboardActive = false;
      this.portalFrameGeometryVertical = null;
      this.portalFrameGeometryHorizontal = null;
      this.portalPlaneGeometry = null;
      this.daylightIntensity = 1;
      this.raycaster = new THREE.Raycaster();
      this.hotbar = Array.from({ length: HOTBAR_SLOTS }, () => ({ item: null, quantity: 0 }));
      this.selectedHotbarIndex = 0;
      this.satchel = new Map();
      this.respawnInventorySnapshot = null;
      this.refreshEquippedItem();
      this.captureRespawnInventorySnapshot();
      this.craftingState = {
        sequence: [],
        unlocked: new Map(),
        searchTerm: '',
      };
      this.craftingRecipes = this.createCraftingRecipes();
      this.craftedRecipes = new Set();
      this.craftingValidationModule = null;
      this.craftingValidationModuleResolved = false;
      this.restorePersistentUnlocks();
      this.restoreIdentitySnapshot();
      this.animationFrame = null;
      this.modelPreloadHandle = null;
      this.modelPreloadUsingIdle = false;
      this.briefingAutoHideTimer = null;
      this.briefingFadeTimer = null;
      this.victoryHideTimer = null;
      this.victoryCelebrationActive = false;
      this.victorySummary = null;
      this.victoryShareBusy = false;
      this.victoryEffectTimers = [];
      this.started = false;
      this.lastStatePublish = 0;
      this.prevTime = null;
      this.mobileControlsRoot = this.ui.mobileControls || null;
      this.virtualJoystickEl = this.ui.virtualJoystick || null;
      this.virtualJoystickThumb = this.ui.virtualJoystickThumb || null;
      this.mobileControlsActive = false;
      this.lastControlUiSyncContext = null;
      this.lastControlUiSyncSnapshots = null;
      this.touchButtonStates = { up: false, down: false, left: false, right: false };
      this.joystickVector = new THREE.Vector2();
      this.joystickPointerId = null;
      this.joystickMovementEngaged = false;
      this.touchLookPointerId = null;
      this.touchLookLast = null;
      this.touchActionStart = 0;
      this.touchActionPending = false;
      this.touchJumpRequested = false;
      this.mobileControlDisposers = [];
      this.isTouchPreferred = this.detectTouchPreferred();
      this.pointerPreferenceObserver = null;
      this.detachPointerPreferenceObserver = null;
      this.prefersReducedMotion = this.detectReducedMotion();
      this.audio = this.createAudioController();
      this.activeAmbientTrack = null;
      this.hudInteractionTimeout = null;
      this.hudInteractionActive = false;
      this.onPointerLockChange = this.handlePointerLockChange.bind(this);
      this.onPointerLockError = this.handlePointerLockError.bind(this);
      this.onMouseUp = this.handleMouseUp.bind(this);
      this.onMouseMove = this.handleMouseMove.bind(this);
      this.onKeyDown = this.handleKeyDown.bind(this);
      this.onKeyUp = this.handleKeyUp.bind(this);
      this.onResize = this.handleResize.bind(this);
      this.onMouseDown = this.handleMouseDown.bind(this);
      this.preventContextMenu = (event) => event.preventDefault();
      this.onDismissBriefing = this.handleBriefingDismiss.bind(this);
      this.onJoystickPointerDown = this.handleJoystickPointerDown.bind(this);
      this.onJoystickPointerMove = this.handleJoystickPointerMove.bind(this);
      this.onJoystickPointerUp = this.handleJoystickPointerUp.bind(this);
      this.onTouchButtonPress = this.handleTouchButtonPress.bind(this);
      this.onTouchButtonRelease = this.handleTouchButtonRelease.bind(this);
      this.onPortalButton = this.handlePortalButton.bind(this);
      this.onTouchLookPointerDown = this.handleTouchLookPointerDown.bind(this);
      this.onTouchLookPointerMove = this.handleTouchLookPointerMove.bind(this);
      this.onTouchLookPointerUp = this.handleTouchLookPointerUp.bind(this);
      this.onHotbarClick = this.handleHotbarClick.bind(this);
      this.onExtendedInventoryClick = this.handleExtendedInventoryClick.bind(this);
      this.onHotbarDragStart = this.handleHotbarDragStart.bind(this);
      this.onHotbarDragEnter = this.handleHotbarDragEnter.bind(this);
      this.onHotbarDragOver = this.handleHotbarDragOver.bind(this);
      this.onHotbarDragLeave = this.handleHotbarDragLeave.bind(this);
      this.onHotbarDrop = this.handleHotbarDrop.bind(this);
      this.onHotbarDragEnd = this.handleHotbarDragEnd.bind(this);
      this.onHotbarPointerDown = this.handleHotbarPointerDown.bind(this);
      this.onHotbarPointerEnter = this.handleHotbarPointerEnter.bind(this);
      this.onHotbarPointerLeave = this.handleHotbarPointerLeave.bind(this);
      this.onHotbarPointerUp = this.handleHotbarPointerUp.bind(this);
      this.onHotbarPointerCancel = this.handleHotbarPointerCancel.bind(this);
      this.onCanvasWheel = this.handleCanvasWheel.bind(this);
      this.onCraftButton = this.handleCraftButton.bind(this);
      this.onClearCraft = this.handleClearCraft.bind(this);
      this.onOpenCrafting = this.handleOpenCrafting.bind(this);
      this.onCloseCrafting = this.handleCloseCrafting.bind(this);
      this.onCraftSequenceClick = this.handleCraftSequenceClick.bind(this);
      this.onCraftSuggestionClick = this.handleCraftSuggestionClick.bind(this);
      this.onCraftSearchInput = this.handleCraftSearchInput.bind(this);
      this.onInventorySort = this.handleInventorySort.bind(this);
      this.onInventoryToggle = this.handleInventoryToggle.bind(this);
      this.onCraftingInventoryClick = this.handleCraftingInventoryClick.bind(this);
      this.onCraftingInventoryFocus = this.handleCraftingInventoryFocus.bind(this);
      this.onCraftingInventoryBlur = this.handleCraftingInventoryBlur.bind(this);
      this.onCraftSuggestionFocus = this.handleCraftSuggestionFocus.bind(this);
      this.onCraftSuggestionBlur = this.handleCraftSuggestionBlur.bind(this);
      this.onCraftSequenceFocus = this.handleCraftSequenceFocus.bind(this);
      this.onCraftSequenceBlur = this.handleCraftSequenceBlur.bind(this);
      this.onOpenTutorial = this.handleOpenTutorial.bind(this);
      this.onOpenGuide = this.handleOpenGuide.bind(this);
      this.onCloseGuide = this.handleCloseGuide.bind(this);
      this.onGuideModalClick = this.handleGuideModalClick.bind(this);
      this.onGuidePrev = this.handleGuidePrev.bind(this);
      this.onGuideNext = this.handleGuideNext.bind(this);
      this.onGuideDotActivate = this.handleGuideDotActivate.bind(this);
      this.onGuideKeyDown = this.handleGuideKeyDown.bind(this);
      this.onVictoryReplay = this.handleVictoryReplay.bind(this);
      this.onVictoryClose = this.handleVictoryClose.bind(this);
      this.onVictoryShare = this.handleVictoryShare.bind(this);
      this.onBeforeUnload = this.handleBeforeUnload.bind(this);
      this.onNetworkOnline = this.handleNetworkOnline.bind(this);
      this.onPointerPreferenceChange = this.handlePointerPreferenceChange.bind(this);
      this.onGlobalPointerDown = this.handleGlobalPointerDown.bind(this);
      this.onGlobalTouchStart = this.handleGlobalTouchStart.bind(this);
      this.onCraftingModalBackdrop = (event) => {
        if (event?.target === this.craftingModal) {
          this.handleCloseCrafting(event);
        }
      };
      this.rendererUnavailable = false;
      this.contextLost = false;
      this.webglEventsBound = false;
      this.rendererFailureMessage = '';
      this.onWebglContextLost = this.handleWebglContextLost.bind(this);
      this.onWebglContextRestored = this.handleWebglContextRestored.bind(this);
      this.isTabVisible =
        typeof document === 'undefined' ||
        document.visibilityState === 'visible' ||
        document.visibilityState === 'prerender';
      this.onVisibilityChange = this.handleVisibilityChange.bind(this);
      this.eventsBound = false;
      this.onCanvasPointerLock = this.handleCanvasPointerLockRequest.bind(this);
      this.setupGuideUi();
      this.setupTutorialUi();
      this.setupLostGuidanceUi();
      this.pendingHeightmapStream = null;
      this.heightmapStreamState = 'idle';
      this.heightmapStreamFailureCount = 0;
      this.heightmapStreamLastError = null;
      this.seededHeightmapCache = new Map();
      this.lastTerrainBuildSummary = null;
      this.lastScenePopulationSummary = null;
      this.lastScenePopulationSummaryContext = null;
    }

    emitGameEvent(type, detail = {}) {
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      if (!scope || typeof scope.dispatchEvent !== 'function' || typeof CustomEvent !== 'function') {
        return;
      }
      try {
        scope.dispatchEvent(
          new CustomEvent(`infinite-rails:${type}`, {
            detail: {
              mode: 'simple',
              timestamp: Date.now(),
              ...detail,
            },
          }),
        );
      } catch (error) {
        if (typeof console !== 'undefined') {
          console.debug('Failed to dispatch simple experience event', type, error);
        }
        if (typeof this.markGameplayInstability === 'function') {
          this.markGameplayInstability('event-dispatch-error');
        }
      }
    }

    markGameplayInstability(reason = 'asset-state-change') {
      const current = Number.isFinite(this.gameplayAtomicVersion) ? this.gameplayAtomicVersion : 0;
      const next = current + 1;
      this.gameplayAtomicVersion = next;
      if (typeof reason === 'string' && reason.trim().length) {
        this.lastGameplayInstabilityReason = reason.trim();
      } else {
        this.lastGameplayInstabilityReason = reason ?? null;
      }
      return next;
    }

    isAssetStateStable() {
      if (this.criticalAssetPreloadFailed) {
        return false;
      }
      if (this.assetRecoveryPromptActive) {
        return false;
      }
      return true;
    }

    captureAtomicSegments(segments = {}) {
      const snapshot = {};
      if (segments.score) {
        snapshot.score = {
          total: Number.isFinite(this.score) ? this.score : 0,
          breakdown: cloneScoreBreakdown(this.scoreBreakdown),
          events: {
            crafting: this.craftingScoreEvents ?? 0,
            dimension: this.dimensionScoreEvents ?? 0,
            portal: this.portalScoreEvents ?? 0,
            combat: this.combatScoreEvents ?? 0,
            loot: this.lootScoreEvents ?? 0,
          },
          pendingReason: this.pendingScoreSyncReason ?? null,
        };
      }
      if (segments.inventory) {
        snapshot.inventory = {
          hotbar: cloneHotbarSlots(this.hotbar),
          satchel: cloneSatchelEntries(this.satchel),
          selectedHotbarIndex: Number.isInteger(this.selectedHotbarIndex) ? this.selectedHotbarIndex : 0,
          hotbarExpanded: this.hotbarExpanded === true,
        };
      }
      if (segments.dimension) {
        snapshot.dimension = {
          currentIndex: Number.isFinite(this.currentDimensionIndex) ? this.currentDimensionIndex : 0,
          settings: this.dimensionSettings,
          terrainProfile: this.dimensionTerrainProfile,
          gravityScale: this.gravityScale,
          portalState: this.portalState ? { ...this.portalState } : null,
          portalActivated: this.portalActivated === true,
          portalActivations: Number.isFinite(this.portalActivations) ? this.portalActivations : 0,
          portalReady: this.portalReady === true,
          victoryAchieved: this.victoryAchieved === true,
        };
      }
      return snapshot;
    }

    restoreAtomicSegments(snapshot, segments = {}) {
      if (!snapshot || typeof snapshot !== 'object') {
        return;
      }
      if (segments.score && snapshot.score) {
        this.score = Number.isFinite(snapshot.score.total) ? snapshot.score.total : this.score;
        this.scoreBreakdown = cloneScoreBreakdown(snapshot.score.breakdown);
        if (snapshot.score.events) {
          this.craftingScoreEvents = snapshot.score.events.crafting ?? this.craftingScoreEvents ?? 0;
          this.dimensionScoreEvents = snapshot.score.events.dimension ?? this.dimensionScoreEvents ?? 0;
          this.portalScoreEvents = snapshot.score.events.portal ?? this.portalScoreEvents ?? 0;
          this.combatScoreEvents = snapshot.score.events.combat ?? this.combatScoreEvents ?? 0;
          this.lootScoreEvents = snapshot.score.events.loot ?? this.lootScoreEvents ?? 0;
        }
        this.pendingScoreSyncReason = snapshot.score.pendingReason ?? this.pendingScoreSyncReason ?? null;
        if (typeof this.updateHud === 'function') {
          try {
            this.updateHud({ reason: 'atomic-rollback' });
          } catch (error) {
            console.debug('HUD refresh failed during atomic rollback.', error);
          }
        }
      }
      if (segments.inventory && snapshot.inventory) {
        this.hotbar = cloneHotbarSlots(snapshot.inventory.hotbar);
        this.satchel = new Map(snapshot.inventory.satchel || []);
        this.selectedHotbarIndex = Number.isInteger(snapshot.inventory.selectedHotbarIndex)
          ? snapshot.inventory.selectedHotbarIndex
          : 0;
        this.hotbarExpanded = snapshot.inventory.hotbarExpanded === true;
        try {
          this.updateInventoryUi();
          this.refreshEquippedItem();
        } catch (error) {
          console.debug('Inventory refresh failed during atomic rollback.', error);
        }
      }
      if (segments.dimension && snapshot.dimension) {
        this.currentDimensionIndex = Number.isFinite(snapshot.dimension.currentIndex)
          ? snapshot.dimension.currentIndex
          : this.currentDimensionIndex;
        this.dimensionSettings = snapshot.dimension.settings ?? this.dimensionSettings;
        this.dimensionTerrainProfile = snapshot.dimension.terrainProfile ?? this.dimensionTerrainProfile;
        this.gravityScale = snapshot.dimension.gravityScale ?? this.gravityScale;
        this.portalState = snapshot.dimension.portalState ? { ...snapshot.dimension.portalState } : null;
        this.portalActivated = snapshot.dimension.portalActivated === true;
        this.portalActivations = Number.isFinite(snapshot.dimension.portalActivations)
          ? snapshot.dimension.portalActivations
          : this.portalActivations;
        this.portalReady = snapshot.dimension.portalReady === true;
        this.victoryAchieved = snapshot.dimension.victoryAchieved === true;
        try {
          this.applyTerrainProfileToCaps(this.dimensionTerrainProfile);
        } catch (error) {
          console.debug('Failed to restore terrain profile during atomic rollback.', error);
        }
        try {
          this.refreshPortalState();
          this.updateDimensionInfoPanel?.();
          this.updateFooterSummary?.();
        } catch (error) {
          console.debug('Failed to refresh dimension state during atomic rollback.', error);
        }
      }
    }

    withGameplayAtomicSnapshot(segments, operation, options = {}) {
      const scopeLabel =
        typeof options.scope === 'string' && options.scope.trim().length ? options.scope.trim() : 'gameplay';
      const enforceStability = options.failOnAssetInstability !== false;
      if (enforceStability && !this.isAssetStateStable()) {
        throw createAtomicAbortError('asset-instability', `Cannot mutate ${scopeLabel} while assets are unstable.`, {
          scope: scopeLabel,
          reason: this.lastGameplayInstabilityReason ?? null,
        });
      }
      const snapshot = this.captureAtomicSegments(segments);
      const startVersion = Number.isFinite(this.gameplayAtomicVersion) ? this.gameplayAtomicVersion : 0;
      const handleCommit = (result) => {
        const endVersion = Number.isFinite(this.gameplayAtomicVersion) ? this.gameplayAtomicVersion : startVersion;
        if (enforceStability && endVersion !== startVersion) {
          const error = createAtomicAbortError(
            'asset-instability',
            `Aborted ${scopeLabel} due to asset instability detected mid-flight.`,
            {
              scope: scopeLabel,
              startVersion,
              endVersion,
              reason: this.lastGameplayInstabilityReason ?? null,
            },
          );
          this.restoreAtomicSegments(snapshot, segments);
          throw error;
        }
        if (typeof options.onCommit === 'function') {
          try {
            options.onCommit(result);
          } catch (hookError) {
            console.debug('Atomic commit hook failed.', hookError);
          }
        }
        return result;
      };
      const handleFailure = (error) => {
        this.restoreAtomicSegments(snapshot, segments);
        if (typeof options.onRollback === 'function') {
          try {
            options.onRollback(error);
          } catch (hookError) {
            console.debug('Atomic rollback hook failed.', hookError);
          }
        }
        throw error;
      };
      let result;
      try {
        result = operation();
      } catch (error) {
        return handleFailure(error);
      }
      if (result && typeof result.then === 'function') {
        return result.then((value) => handleCommit(value), (error) => handleFailure(error));
      }
      return handleCommit(result);
    }

    start() {
      if (this.started || this.rendererUnavailable) return;
      if (this.criticalAssetPreloadFailed) {
        const failureMessage = this.rendererFailureMessage || 'Critical assets failed to load. Reload to try again.';
        this.presentRendererFailure(failureMessage, { stage: 'asset-load' });
        return;
      }
      if (!this.verifyWebglSupport()) {
        return;
      }
      this.sessionToken += 1;
      this.activeSessionId = this.sessionToken;
      const sessionId = this.activeSessionId;
      this.cameraPerspective = 'first';
      this.resetPlayerCharacterState();
      this.resetLostGuidance('start');
      this.started = true;
      this.unloadBeaconSent = false;
      this.rendererUnavailable = false;
      this.contextLost = false;
      this.clearVictoryEffectTimers();
      this.hideVictoryCelebration(true);
      this.hideVictoryBanner();
      this.victorySummary = null;
      this.victoryCelebrationActive = false;
      this.victoryShareBusy = false;
      try {
        this.setupScene();
        this.queueCharacterPreload();
        this.loadFirstPersonArms(sessionId);
        this.initializeScoreboardUi();
        this.applyDimensionSettings(this.currentDimensionIndex);
        this.primeAmbientAudio();
        this.buildTerrain();
        this.populateSceneAfterTerrain({ reason: 'start' });
        this.buildRails();
        this.refreshPortalState();
        this.attachPlayerToSimulation();
        this.evaluateBossChallenge();
        this.bindEvents();
        this.initializeMobileControls();
        this.updatePointerHintForInputMode();
        this.showDesktopPointerTutorialHint();
        this.updateHud();
        this.revealDimensionIntro(this.dimensionSettings, { duration: 6200, intent: 'arrival' });
        this.refreshCraftingUi();
        this.hideIntro();
        const tutorialShown = this.maybeShowFirstRunTutorial();
        if (!tutorialShown) {
          this.showBriefingOverlay();
        }
        this.autoCaptureLocation({ updateOnFailure: true }).catch((error) => {
          console.warn('Location capture failed', error);
        });
        this.updateLocalScoreEntry('start');
        this.loadScoreboard();
        this.exposeDebugInterface();
        this.renderFrame(performance.now());
        this.emitGameEvent('started', { summary: this.createRunSummary('start') });
        this.publishStateSnapshot('started');
        this.logEngineBootDiagnostics({ status: 'success', phase: 'start' });
        this.lastStatePublish = 0;
      } catch (error) {
        const failureMessage = 'Renderer initialisation failed. Check your browser console for details.';
        this.presentRendererFailure(failureMessage, {
          error,
        });
        this.started = false;
        const errorMessage =
          typeof error?.message === 'string' && error.message.trim().length
            ? error.message.trim()
            : failureMessage;
        this.emitGameEvent('start-error', {
          message: failureMessage,
          errorMessage,
          errorName: typeof error?.name === 'string' && error.name.trim().length ? error.name.trim() : undefined,
          stack: typeof error?.stack === 'string' && error.stack.trim().length ? error.stack.trim() : undefined,
          stage: 'startup',
        });
        this.publishStateSnapshot('start-error');
        this.logEngineBootDiagnostics({ status: 'error', phase: 'start', error });
      }
    }

    summariseRequiredSceneNodes() {
      const scene = this.scene || null;
      const summary = {
        steve: { present: false, placeholder: false, nodeName: null, attached: false },
        ground: { present: false, attached: false, terrainGroupChildren: 0 },
        blocks: { present: false, attached: false, meshCount: 0, sampleChunk: null },
        mobs: {
          present: false,
          zombieCount: 0,
          golemCount: 0,
          total: 0,
          groups: { zombieAttached: false, golemAttached: false },
        },
        allPresent: false,
        missing: [],
      };
      if (!scene) {
        summary.missing.push('steve', 'ground', 'mob', 'block');
        return summary;
      }
      const isAttachedToScene = (object) => {
        let current = object;
        while (current) {
          if (current === scene) {
            return true;
          }
          current = current.parent || null;
        }
        return false;
      };

      const candidateAvatars = [];
      if (this.playerAvatar) {
        candidateAvatars.push(this.playerAvatar);
      }
      if (this.playerRig && Array.isArray(this.playerRig.children)) {
        for (const child of this.playerRig.children) {
          if (
            child &&
            (child.name === 'PlayerAvatar' ||
              child.name === 'PlayerAvatarPlaceholder' ||
              child.userData?.placeholderKey === 'steve')
          ) {
            candidateAvatars.push(child);
          }
        }
      }
      const avatar = candidateAvatars.find((node) => isAttachedToScene(node)) || candidateAvatars[0] || null;
      if (avatar) {
        summary.steve.nodeName = avatar.name || null;
        summary.steve.placeholder = Boolean(avatar.userData?.placeholder);
        summary.steve.attached = isAttachedToScene(avatar);
        summary.steve.present = summary.steve.attached;
      }

      const terrainGroup = this.terrainGroup || null;
      if (terrainGroup) {
        summary.ground.terrainGroupChildren = Array.isArray(terrainGroup.children)
          ? terrainGroup.children.length
          : 0;
        summary.ground.attached = isAttachedToScene(terrainGroup);
        summary.ground.present = summary.ground.attached && summary.ground.terrainGroupChildren > 0;
      }

      const chunkGroups = Array.isArray(this.terrainChunkGroups) ? this.terrainChunkGroups : [];
      let referenceChunk = null;
      let totalBlockMeshes = 0;
      for (const chunk of chunkGroups) {
        if (!chunk) {
          continue;
        }
        const children = Array.isArray(chunk.children) ? chunk.children : [];
        let chunkMeshCount = 0;
        for (const child of children) {
          if (child?.isMesh) {
            chunkMeshCount += 1;
          }
        }
        if (chunkMeshCount > 0) {
          totalBlockMeshes += chunkMeshCount;
          if (!referenceChunk) {
            referenceChunk = chunk;
          }
        }
      }
      summary.blocks.meshCount = totalBlockMeshes;
      if (referenceChunk) {
        summary.blocks.sampleChunk = referenceChunk.name || referenceChunk.userData?.chunkKey || null;
        summary.blocks.attached = isAttachedToScene(referenceChunk);
        summary.blocks.present = summary.blocks.attached;
      } else if (terrainGroup) {
        const terrainChildren = Array.isArray(terrainGroup.children) ? terrainGroup.children : [];
        let detectedMesh = terrainChildren.find((child) => child?.isMesh) || null;
        if (!detectedMesh && typeof terrainGroup.traverse === 'function') {
          terrainGroup.traverse((child) => {
            if (detectedMesh || child === terrainGroup) {
              return;
            }
            if (child?.isMesh) {
              detectedMesh = child;
            }
          });
        }
        if (detectedMesh) {
          summary.blocks.attached = isAttachedToScene(detectedMesh);
          summary.blocks.present = summary.blocks.attached;
          summary.blocks.sampleChunk = detectedMesh.name || terrainGroup.name || 'TerrainGroup';
          if (!summary.blocks.meshCount) {
            summary.blocks.meshCount = 1;
          }
        }
      }

      const zombieGroup = this.zombieGroup || null;
      const golemGroup = this.golemGroup || null;
      const zombieCount = Array.isArray(zombieGroup?.children) ? zombieGroup.children.length : 0;
      const golemCount = Array.isArray(golemGroup?.children) ? golemGroup.children.length : 0;
      summary.mobs.zombieCount = zombieCount;
      summary.mobs.golemCount = golemCount;
      summary.mobs.total = zombieCount + golemCount;
      summary.mobs.groups.zombieAttached = zombieGroup ? isAttachedToScene(zombieGroup) : false;
      summary.mobs.groups.golemAttached = golemGroup ? isAttachedToScene(golemGroup) : false;
      summary.mobs.present =
        (zombieCount > 0 && summary.mobs.groups.zombieAttached) ||
        (golemCount > 0 && summary.mobs.groups.golemAttached);

      if (!summary.steve.present) summary.missing.push('steve');
      if (!summary.ground.present) summary.missing.push('ground');
      if (!summary.mobs.present) summary.missing.push('mob');
      if (!summary.blocks.present) summary.missing.push('block');

      summary.allPresent = summary.missing.length === 0;
      return summary;
    }

    reportMissingSceneObjects(summary, context = {}) {
      if (!summary || summary.allPresent) {
        return;
      }
      const reasonRaw = typeof context.reason === 'string' ? context.reason.trim() : '';
      const reason = reasonRaw.length ? reasonRaw : 'scene-population';
      const errors = Array.isArray(context.errors) ? context.errors : [];
      const errorMap = new Map();
      for (const entry of errors) {
        if (!entry || typeof entry.asset !== 'string') {
          continue;
        }
        if (!errorMap.has(entry.asset)) {
          errorMap.set(entry.asset, entry.error || null);
        }
      }
      const missingKeys = Array.isArray(summary.missing) ? summary.missing : [];
      if (!missingKeys.length) {
        return;
      }
      const summaryKeyMap = { steve: 'steve', ground: 'ground', block: 'blocks', mob: 'mobs' };
      const assetNameMap = {
        steve: 'player-avatar',
        ground: 'terrain-ground',
        block: 'terrain-blocks',
        mob: 'mob-actors',
      };
      for (const missingKey of missingKeys) {
        const asset = assetNameMap[missingKey] || missingKey;
        const summaryKey = summaryKeyMap[missingKey] || missingKey;
        const snapshot = summary[summaryKey] ?? null;
        const capturedError =
          errorMap.get(asset) ?? errorMap.get(summaryKey) ?? errorMap.get(missingKey) ?? null;
        const detail = {
          asset,
          reason,
          missingKey,
          snapshot,
        };
        if (capturedError) {
          detail.error = normaliseLiveDiagnosticError(capturedError);
        }
        if (typeof console !== 'undefined' && typeof console.error === 'function') {
          console.error(`Scene object missing — ${asset}`, detail);
        }
        if (typeof notifyLiveDiagnostics === 'function') {
          notifyLiveDiagnostics('scene', `Scene object missing — ${asset}`, detail, { level: 'error' });
        }
      }
    }

    logEngineBootDiagnostics(context = {}) {
      const consoleRef = typeof console !== 'undefined' ? console : null;
      if (!consoleRef || typeof consoleRef.log !== 'function') {
        return;
      }
      const status = context.status || (context.error ? 'error' : 'success');
      const phase = context.phase || 'start';
      const now = new Date();
      const bootDiagnosticsSnapshot = {
        timestamp: now.toISOString(),
        status,
        phase,
        sections: {
          engine: [],
          assets: [],
          models: [],
          ui: [],
        },
      };
      const appendBootDiagnostic = (section, severity, message, detail = null) => {
        const scope = typeof section === 'string' ? section.trim().toLowerCase() : '';
        if (!bootDiagnosticsSnapshot.sections[scope]) {
          return;
        }
        const entry = {
          severity: severity === 'error' || severity === 'warning' ? severity : 'ok',
          message:
            typeof message === 'string' && message.trim().length ? message.trim() : 'No additional details.',
          detail: null,
        };
        if (detail !== null && detail !== undefined) {
          if (typeof detail === 'string') {
            entry.detail = detail;
          } else if (typeof detail === 'number' || typeof detail === 'boolean') {
            entry.detail = detail;
          } else {
            try {
              entry.detail = JSON.parse(JSON.stringify(detail));
            } catch (error) {
              entry.detail = String(detail);
            }
          }
        }
        bootDiagnosticsSnapshot.sections[scope].push(entry);
      };
      const rootGroupOpen =
        typeof consoleRef.groupCollapsed === 'function'
          ? consoleRef.groupCollapsed.bind(consoleRef)
          : typeof consoleRef.group === 'function'
            ? consoleRef.group.bind(consoleRef)
            : null;
      const groupEnd = typeof consoleRef.groupEnd === 'function' ? consoleRef.groupEnd.bind(consoleRef) : null;
      const sectionGroupOpen =
        typeof consoleRef.groupCollapsed === 'function'
          ? consoleRef.groupCollapsed.bind(consoleRef)
          : typeof consoleRef.group === 'function'
            ? consoleRef.group.bind(consoleRef)
            : null;
      const printValue = (value) => {
        if (Array.isArray(value) && value.length > 0 && typeof consoleRef.table === 'function') {
          consoleRef.table(value);
          return;
        }
        if (value && typeof value === 'object') {
          consoleRef.log({ ...value });
          return;
        }
        consoleRef.log(value);
      };
      const logNestedArrays = (value) => {
        if (!value || typeof value !== 'object') {
          return;
        }
        if (Array.isArray(value)) {
          if (value.length > 0) {
            printValue(value);
          }
          return;
        }
        for (const nestedValue of Object.values(value)) {
          if (nestedValue && typeof nestedValue === 'object') {
            logNestedArrays(nestedValue);
          }
        }
      };
      const logSection = (title, payload) => {
        if (sectionGroupOpen) {
          sectionGroupOpen(title);
          printValue(payload);
          logNestedArrays(payload);
          if (groupEnd) {
            groupEnd();
          }
        } else {
          consoleRef.log(`${title}:`, payload);
        }
      };
      const label = `Engine boot diagnostics — ${status}${phase ? ` (${phase})` : ''}`;
      if (rootGroupOpen) {
        rootGroupOpen(label);
      } else {
        consoleRef.log(label);
      }

      const assetTimers = this.assetLoadTimers || {};
      const pendingAssetTimers = Object.entries(assetTimers).map(([kind, map]) => ({
        kind,
        pending: map instanceof Map ? map.size : 0,
      }));
      const recentLoads = typeof this.getAssetLoadLog === 'function'
        ? this.getAssetLoadLog(5).map((entry) => ({
            kind: entry.kind,
            key: entry.key,
            status: entry.status,
            durationMs: Number.isFinite(entry.duration) ? Math.round(entry.duration) : null,
            completedAt: entry.timestamp ?? null,
          }))
        : [];
      const assetFailureEntries =
        this.assetFailureCounts instanceof Map
          ? Array.from(this.assetFailureCounts.entries()).map(([key, count]) => ({ key, failures: count }))
          : [];
      const assetStatus = {
        timestamp: now.toISOString(),
        pendingLoads: pendingAssetTimers,
        recentLoads,
        recovery: {
          pendingKeys: Array.from(this.assetRecoveryPendingKeys || []),
          promptActive: Boolean(this.assetRecoveryPromptActive),
          delayNotices: Array.from(this.assetDelayNotices || []),
        },
      };

      const loadedModelKeys =
        this.loadedModels instanceof Map ? Array.from(this.loadedModels.keys()).slice(-5) : [];
      const pendingModelKeys =
        this.modelPromises instanceof Map ? Array.from(this.modelPromises.keys()).slice(0, 5) : [];
      const modelStatus = {
        loadedCount: this.loadedModels instanceof Map ? this.loadedModels.size : 0,
        pendingCount: this.modelPromises instanceof Map ? this.modelPromises.size : 0,
        warmupQueue: Array.isArray(this.lazyModelWarmupQueue) ? this.lazyModelWarmupQueue.length : 0,
        handModelLoaded: Boolean(this.handModelLoaded),
        playerAvatarLoaded: this.playerAvatarLoaded === true,
        sampleLoaded: loadedModelKeys,
        samplePending: pendingModelKeys,
      };

      const requiredSceneNodes =
        typeof this.summariseRequiredSceneNodes === 'function' ? this.summariseRequiredSceneNodes() : null;

      if (requiredSceneNodes) {
        const missingLabel = requiredSceneNodes.missing?.length
          ? requiredSceneNodes.missing.join(', ')
          : 'none';
        const logLabel = requiredSceneNodes.allPresent
          ? 'Scene graph validation — required nodes located.'
          : `Scene graph validation failed — missing required nodes: ${missingLabel}.`;
        const payload = { requiredNodes: requiredSceneNodes };
        if (requiredSceneNodes.allPresent) {
          if (typeof consoleRef?.info === 'function') {
            consoleRef.info(logLabel, payload);
          } else {
            consoleRef.log?.(logLabel, payload);
          }
        } else if (typeof consoleRef?.error === 'function') {
          consoleRef.error(logLabel, payload);
        } else {
          consoleRef.warn?.(logLabel, payload);
        }
      }

      const sceneStatus = {
        rendererReady: Boolean(this.renderer && !this.rendererUnavailable),
        sceneChildren: this.scene?.children?.length ?? 0,
        worldChildren: this.worldRoot?.children?.length ?? 0,
        terrainColumns: this.columns instanceof Map ? this.columns.size : 0,
        terrainMeshes: this.terrainGroup?.children?.length ?? 0,
        railSegments: this.railsGroup?.children?.length ?? 0,
        portalElements: this.portalGroup?.children?.length ?? 0,
        zombieActors: Array.isArray(this.zombies) ? this.zombies.length : 0,
        golemActors: Array.isArray(this.golems) ? this.golems.length : 0,
      };
      if (requiredSceneNodes) {
        sceneStatus.requiredNodes = requiredSceneNodes;
      }

      const controlStatus = {
        pointerLocked: Boolean(this.pointerLocked),
        pointerFallbackActive: Boolean(this.pointerLockFallbackActive),
        pointerFallbackNotice: Boolean(this.pointerLockFallbackNoticeShown),
        keyBindingCount: this.keyBindings ? Object.keys(this.keyBindings).length : 0,
        mobileControlsActive: Boolean(this.mobileControlsActive),
        touchPreferred: Boolean(this.isTouchPreferred),
        boundEvents: Array.isArray(this.boundEventRecords) ? this.boundEventRecords.length : 0,
        bindingFailures: Array.isArray(this.eventBindingFailures) ? this.eventBindingFailures.length : 0,
        cameraPerspective: this.cameraPerspective ?? null,
      };

      const navigationMeshes = this.navigationMeshes instanceof Map ? this.navigationMeshes : null;
      const navigationSummary = this.navigationMeshSummary || {};
      let zombieDiagnostics = null;
      if (typeof this.getZombieAIDiagnostics === 'function') {
        try {
          zombieDiagnostics = this.getZombieAIDiagnostics();
        } catch (diagnosticError) {
          consoleRef.debug?.('Failed to gather zombie AI diagnostics for boot log.', diagnosticError);
        }
      }
      const aiStatus = {
        navmesh: {
          trackedChunks: navigationMeshes ? navigationMeshes.size : 0,
          generation: this.navigationMeshGeneration ?? 0,
          chunkCount: navigationSummary.chunkCount ?? (navigationMeshes ? navigationMeshes.size : 0),
          walkableCells: navigationSummary.walkableCells ?? 0,
          lastUpdatedAt: navigationSummary.updatedAt ?? null,
          lastReason: navigationSummary.reason ?? null,
        },
        zombies: zombieDiagnostics
          ? {
              activeCount: zombieDiagnostics.activeCount ?? 0,
              activeChunks: Array.isArray(zombieDiagnostics.navigation?.activeChunks)
                ? zombieDiagnostics.navigation.activeChunks
                : [],
              lastSpawnAt: zombieDiagnostics.lastSpawnAt ?? null,
              timeSinceLastSpawn: zombieDiagnostics.timeSinceLastSpawn ?? null,
            }
          : null,
      };

      const doc = typeof document !== 'undefined' ? document : null;
      const portalStateText = this.ui?.portalStatusStateText?.textContent;
      const portalDetailText = this.ui?.portalStatusDetailText?.textContent;
      const uiStatus = {
        hudActive: doc?.body?.classList?.contains?.('game-active') ?? false,
        introHidden: this.ui?.introModal ? Boolean(this.ui.introModal.hidden) : null,
        briefingVisible: this.playerHintEl ? this.playerHintEl.hidden === false : null,
        tutorialVisible: this.firstRunTutorialEl ? this.firstRunTutorialEl.hidden === false : null,
        pointerHintActive: Boolean(this.pointerHintActive),
        pointerHintMessage: this.pointerHintLastMessage || null,
        mobileControlsVisible: this.mobileControlsRoot ? this.mobileControlsRoot.hidden === false : null,
        scoreboardStatus:
          this.scoreboardStatusEl && typeof this.scoreboardStatusEl.textContent === 'string'
            ? this.scoreboardStatusEl.textContent.trim()
            : null,
        portalStatus: portalStateText && typeof portalStateText === 'string' ? portalStateText.trim() : null,
        portalDetail: portalDetailText && typeof portalDetailText === 'string' ? portalDetailText.trim() : null,
      };

      let bootError = null;
      if (context.error) {
        const errorMessage =
          typeof context.error.message === 'string' && context.error.message.trim().length
            ? context.error.message.trim()
            : String(context.error);
        const errorName =
          typeof context.error.name === 'string' && context.error.name.trim().length
            ? context.error.name.trim()
            : context.error.constructor?.name ?? 'Error';
        bootError = {
          name: errorName,
          message: errorMessage,
          stack: typeof context.error.stack === 'string'
            ? context.error.stack
                .split('\n')
                .slice(0, 6)
                .join('\n')
            : null,
        };
      }
      const errorStatus = {
        status,
        phase,
        rendererUnavailable: Boolean(this.rendererUnavailable),
        assetFailures: assetFailureEntries,
        assetNotices: Array.from(this.assetFailureNotices || []),
        eventNotices: Array.from(this.eventFailureNotices || []),
        bootError,
      };

      const assetPendingTotal = assetStatus.pendingLoads.reduce((total, entry) => {
        const pending = Number.isFinite(entry?.pending) ? entry.pending : 0;
        return total + pending;
      }, 0);
      const assetRecoveryPendingCount = Array.isArray(assetStatus.recovery?.pendingKeys)
        ? assetStatus.recovery.pendingKeys.length
        : 0;
      const assetSummaryParts = [];
      if (assetPendingTotal > 0) {
        assetSummaryParts.push(
          `${assetPendingTotal} pending load${assetPendingTotal === 1 ? '' : 's'}`,
        );
      }
      if (assetRecoveryPendingCount > 0) {
        assetSummaryParts.push(
          `Recovery pending for ${assetRecoveryPendingCount} key${assetRecoveryPendingCount === 1 ? '' : 's'}`,
        );
      }
      if (recentLoads.length > 0) {
        assetSummaryParts.push(`Recent loads logged: ${recentLoads.length}`);
      }
      const assetSummaryDetail = assetSummaryParts.length ? assetSummaryParts.join(' • ') : null;
      const assetSummarySeverity =
        assetFailureEntries.length > 0
          ? 'error'
          : assetPendingTotal > 0 || assetStatus.recovery.promptActive
            ? 'warning'
            : 'ok';
      appendBootDiagnostic(
        'assets',
        assetSummarySeverity,
        assetFailureEntries.length > 0
          ? 'Asset streaming encountered failures.'
          : assetPendingTotal > 0
            ? 'Asset streaming in progress.'
            : 'Assets initialised successfully.',
        assetSummaryDetail,
      );
      if (assetStatus.recovery.promptActive) {
        appendBootDiagnostic('assets', 'warning', 'Asset recovery prompt displayed to the player.');
      }
      const recoveryKeys = Array.isArray(assetStatus.recovery.pendingKeys)
        ? assetStatus.recovery.pendingKeys.filter((key) => typeof key === 'string' && key.trim().length)
        : [];
      if (recoveryKeys.length > 0) {
        appendBootDiagnostic(
          'assets',
          'warning',
          'Asset recovery pending for specific resources.',
          recoveryKeys.slice(0, 6),
        );
      }
      const assetDelayNotices = Array.isArray(assetStatus.recovery.delayNotices)
        ? assetStatus.recovery.delayNotices
        : [];
      assetDelayNotices.forEach((notice) => {
        if (typeof notice === 'string' && notice.trim().length) {
          appendBootDiagnostic('assets', 'warning', notice.trim());
        }
      });
      assetFailureEntries.forEach((entry) => {
        const label = typeof entry?.key === 'string' && entry.key.trim().length ? entry.key.trim() : 'Unknown asset';
        const attempts = Number.isFinite(entry?.failures) ? entry.failures : null;
        const message =
          attempts && attempts > 1
            ? `${label} failed to load ${attempts} times.`
            : `${label} failed to load.`;
        appendBootDiagnostic('assets', 'error', message);
      });
      (errorStatus.assetNotices || []).forEach((notice) => {
        if (typeof notice === 'string' && notice.trim().length) {
          appendBootDiagnostic('assets', 'warning', notice.trim());
        }
      });

      const modelSummaryParts = [];
      if (Number.isFinite(modelStatus.loadedCount)) {
        modelSummaryParts.push(`${modelStatus.loadedCount} loaded`);
      }
      if (Number.isFinite(modelStatus.pendingCount) && modelStatus.pendingCount > 0) {
        modelSummaryParts.push(`${modelStatus.pendingCount} pending`);
      }
      if (Number.isFinite(modelStatus.warmupQueue) && modelStatus.warmupQueue > 0) {
        modelSummaryParts.push(`Warmup queue: ${modelStatus.warmupQueue}`);
      }
      const modelSummaryDetail = modelSummaryParts.length ? modelSummaryParts.join(' • ') : null;
      const modelSummarySeverity =
        modelStatus.pendingCount > 0 || !modelStatus.playerAvatarLoaded || !modelStatus.handModelLoaded
          ? 'warning'
          : 'ok';
      appendBootDiagnostic(
        'models',
        modelSummarySeverity,
        modelSummarySeverity === 'ok' ? 'Model pipeline ready.' : 'Model pipeline warming up.',
        modelSummaryDetail,
      );
      if (!modelStatus.playerAvatarLoaded) {
        appendBootDiagnostic('models', 'warning', 'Player avatar model not yet loaded.');
      }
      if (!modelStatus.handModelLoaded) {
        appendBootDiagnostic('models', 'warning', 'Hand model not yet loaded.');
      }
      const pendingModelKeysList = Array.isArray(modelStatus.samplePending)
        ? modelStatus.samplePending.filter((key) => typeof key === 'string' && key.trim().length)
        : [];
      if (pendingModelKeysList.length > 0) {
        appendBootDiagnostic('models', 'warning', 'Pending model keys detected.', pendingModelKeysList.slice(0, 6));
      }
      if (requiredSceneNodes && requiredSceneNodes.missing?.length) {
        appendBootDiagnostic(
          'models',
          'error',
          'Scene graph validation failed — required nodes missing.',
          requiredSceneNodes.missing,
        );
      }

      const scoreboardStatusText =
        typeof uiStatus.scoreboardStatus === 'string' ? uiStatus.scoreboardStatus.trim() : '';
      const scoreboardOffline = scoreboardStatusText.toLowerCase().includes('offline');
      const pointerFallbackActive = Boolean(controlStatus.pointerFallbackActive);
      const bindingFailureCount = Number.isFinite(controlStatus.bindingFailures)
        ? controlStatus.bindingFailures
        : 0;
      const portalDetailIssue =
        typeof uiStatus.portalDetail === 'string' && /fail|error|stalled|offline/i.test(uiStatus.portalDetail);
      const uiSummaryParts = [];
      if (typeof uiStatus.portalStatus === 'string' && uiStatus.portalStatus.trim().length) {
        uiSummaryParts.push(`Portal: ${uiStatus.portalStatus.trim()}`);
      }
      if (scoreboardStatusText.length) {
        uiSummaryParts.push(`Scoreboard: ${scoreboardStatusText}`);
      }
      const uiSummaryDetail = uiSummaryParts.length ? uiSummaryParts.join(' • ') : null;
      const uiSummarySeverity =
        scoreboardOffline || pointerFallbackActive || bindingFailureCount > 0 || portalDetailIssue ? 'warning' : 'ok';
      appendBootDiagnostic(
        'ui',
        uiSummarySeverity,
        uiSummarySeverity === 'ok' ? 'Interface ready.' : 'Interface reporting degraded state.',
        uiSummaryDetail,
      );
      if (pointerFallbackActive) {
        appendBootDiagnostic('ui', 'warning', 'Pointer lock fallback active.');
      }
      if (controlStatus.pointerFallbackNotice) {
        appendBootDiagnostic('ui', 'warning', 'Pointer lock fallback notice shown to the player.');
      }
      if (bindingFailureCount > 0) {
        appendBootDiagnostic(
          'ui',
          'warning',
          `Input binding failures detected (${bindingFailureCount}).`,
        );
      }
      if (scoreboardOffline && scoreboardStatusText.length) {
        appendBootDiagnostic('ui', 'warning', scoreboardStatusText);
      }
      if (portalDetailIssue && typeof uiStatus.portalDetail === 'string') {
        appendBootDiagnostic('ui', 'warning', 'Portal status reported an issue.', uiStatus.portalDetail);
      }

      const engineSummaryParts = [`Phase: ${phase}`];
      if (bootError?.name || bootError?.message) {
        const errorLabel = `${bootError?.name ?? 'Error'}${bootError?.message ? `: ${bootError.message}` : ''}`;
        engineSummaryParts.push(errorLabel);
      }
      if (errorStatus.rendererUnavailable) {
        engineSummaryParts.push('Renderer unavailable flag set.');
      }
      const engineSummaryDetail = engineSummaryParts.filter(Boolean).join(' • ') || null;
      const engineSummarySeverity = status === 'error' || errorStatus.rendererUnavailable ? 'error' : 'ok';
      appendBootDiagnostic(
        'engine',
        engineSummarySeverity,
        engineSummarySeverity === 'error' ? 'Engine initialisation failed.' : 'Engine initialised successfully.',
        engineSummaryDetail,
      );
      if (bootError?.stack) {
        appendBootDiagnostic('engine', 'error', 'Boot error stack captured.', bootError.stack);
      }
      (errorStatus.eventNotices || []).forEach((notice) => {
        if (typeof notice === 'string' && notice.trim().length) {
          appendBootDiagnostic('engine', 'warning', notice.trim());
        }
      });

      logSection('Asset status', assetStatus);
      logSection('Model status', modelStatus);
      logSection('Scene objects', sceneStatus);
      logSection('Controls', controlStatus);
      logSection('AI navmesh', aiStatus);
      logSection('UI states', uiStatus);
      logSection('Errors', errorStatus);

      this.lastBootDiagnostics = bootDiagnosticsSnapshot;
      const globalScopeRef =
        typeof globalThis !== 'undefined'
          ? globalThis
          : typeof window !== 'undefined'
            ? window
            : typeof global !== 'undefined'
              ? global
              : null;
      const bootDiagnosticsApi = globalScopeRef?.InfiniteRails?.bootDiagnostics ?? null;
      if (bootDiagnosticsApi && typeof bootDiagnosticsApi.update === 'function') {
        try {
          bootDiagnosticsApi.update(bootDiagnosticsSnapshot);
        } catch (publishError) {
          consoleRef.debug?.('Failed to publish boot diagnostics snapshot.', publishError);
        }
      }

      if (rootGroupOpen && groupEnd) {
        groupEnd();
      }
    }

    primeAmbientAudio() {
      this.activeAmbientTrack = null;
      if (!this.audio || typeof this.audio !== 'object') {
        return;
      }
      const { audio } = this;
      if (typeof audio.resumeContextIfNeeded === 'function') {
        try {
          audio.resumeContextIfNeeded();
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Unable to resume audio context.', error);
          }
        }
      }
      if (typeof audio.has === 'function' && typeof audio.play === 'function') {
        const themeTracks = Array.isArray(this.dimensionSettings?.ambientTracks)
          ? this.dimensionSettings.ambientTracks
              .map((name) => (typeof name === 'string' ? name.trim() : ''))
              .filter(Boolean)
          : null;
        const candidates = themeTracks && themeTracks.length ? themeTracks : DEFAULT_AMBIENT_TRACKS;
        const selectedTrack = candidates.find((name) => {
          try {
            return audio.has(name);
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Ambient audio availability check failed.', error);
            }
            return false;
          }
        });
        if (selectedTrack) {
          this.activeAmbientTrack = selectedTrack;
          try {
            audio.play(selectedTrack, { loop: true, volume: 0.32 });
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Unable to start ambient audio playback.', error);
            }
          }
        }
      }
      this.triggerWelcomeCue();
    }

    reportAudioError(detail = {}, options = {}) {
      const now = Date.now();
      const baseMessage =
        typeof options.message === 'string' && options.message.trim().length
          ? options.message.trim()
          : typeof detail.message === 'string' && detail.message.trim().length
            ? detail.message.trim()
            : 'Audio playback failed.';
      const message = ensureAudioFallbackMessage(baseMessage);
      const payload = {
        message,
        requestedName: detail.requestedName ?? null,
        resolvedName: detail.resolvedName ?? null,
        code: typeof detail.code === 'string' ? detail.code : 'playback-error',
        missingSample: detail.missingSample === true,
        fallbackActive: detail.fallbackActive === true,
        timestamp: now,
      };
      if (detail.detail !== undefined) {
        payload.detail = detail.detail;
      }
      const error = detail.error || null;
      if (error) {
        if (typeof error.message === 'string' && error.message.trim().length) {
          payload.errorMessage = error.message;
        }
        if (typeof error.name === 'string' && error.name.trim().length) {
          payload.errorName = error.name;
        }
        if (typeof error.code !== 'undefined') {
          payload.errorCode = error.code;
        }
      }
      if (runtimeScope && typeof runtimeScope.dispatchEvent === 'function') {
        const EventCtor =
          typeof runtimeScope.CustomEvent === 'function'
            ? runtimeScope.CustomEvent
            : typeof CustomEvent === 'function'
              ? CustomEvent
              : null;
        if (EventCtor) {
          try {
            runtimeScope.dispatchEvent(new EventCtor('infinite-rails:audio-error', { detail: payload }));
          } catch (eventError) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Unable to dispatch audio error event.', eventError);
            }
          }
        }
      }
      const logDetail = {
        requestedName: payload.requestedName,
        resolvedName: payload.resolvedName,
        code: payload.code,
        missingSample: payload.missingSample,
        fallbackActive: payload.fallbackActive,
      };
      if (payload.detail && typeof payload.detail === 'object') {
        logDetail.detail = payload.detail;
      }
      notifyLiveDiagnostics('audio', message, logDetail, {
        level: options.level || (payload.missingSample ? 'warning' : 'error'),
        timestamp: now,
      });
      return payload;
    }

    presentAudioFallbackOverlay(message, detail = {}) {
      displayAudioFallbackOverlay(message, detail);
    }

    triggerWelcomeCue() {
      const audio = this.audio;
      if (!audio || typeof audio !== 'object' || typeof audio.play !== 'function') {
        return;
      }
      let welcomeAvailable = null;
      if (typeof audio.has === 'function') {
        try {
          welcomeAvailable = Boolean(audio.has('welcome'));
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Welcome audio availability check failed.', error);
          }
        }
      }
      let resolvedName = null;
      if (typeof audio._resolve === 'function') {
        try {
          const resolved = audio._resolve('welcome');
          resolvedName = typeof resolved === 'string' && resolved.trim().length ? resolved : null;
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Welcome audio alias resolution failed.', error);
          }
        }
      }
      try {
        audio.play('welcome', { volume: welcomeAvailable === false ? 0.7 : 0.55 });
      } catch (error) {
        const baseMessage =
          typeof error?.message === 'string' && error.message.trim().length
            ? error.message.trim()
            : 'Welcome audio cue failed to play.';
        const detail = {
          requestedName: 'welcome',
          resolvedName,
          missingSample: welcomeAvailable === false,
          fallbackActive: true,
          code: 'welcome-playback-error',
          error,
          detail: {
            code: 'welcome-playback-error',
            requestedName: 'welcome',
            resolvedName,
            missingSample: welcomeAvailable === false,
          },
        };
        const eventDetail = this.reportAudioError(detail, { message: baseMessage });
        this.presentAudioFallbackOverlay(eventDetail.message, detail);
        return;
      }
      if (welcomeAvailable === false) {
        const baseMessage = resolvedName
          ? `Welcome audio cue is unavailable — falling back to "${resolvedName}".`
          : 'Missing audio sample "welcome" detected during startup.';
        this.reportAudioError(
          {
            requestedName: 'welcome',
            resolvedName,
            missingSample: true,
            fallbackActive: true,
            code: 'missing-sample',
            detail: {
              code: 'missing-sample',
              requestedName: 'welcome',
              resolvedName,
              missingSample: true,
            },
          },
          { message: baseMessage, level: 'warning' },
        );
      }
    }

    hideIntro() {
      const { introModal, startButton, hudRootEl } = this.ui;
      if (introModal) {
        introModal.hidden = true;
        introModal.style.display = 'none';
        setInertState(introModal, true);
        releaseOverlayIsolation(introModal);
      }
      if (startButton) {
        startButton.disabled = true;
        startButton.setAttribute('tabindex', '-1');
        startButton.blur();
      }
      if (hudRootEl) {
        document.body.classList.add('game-active');
      }
      this.focusGameViewport();
    }

    setupGuideUi() {
      if (this.guideModalEl) {
        const visible = this.guideModalEl.hidden === false;
        this.guideModalVisible = visible;
        safelySetAriaHidden(this.guideModalEl, !visible);
        if (!visible) {
          setInertState(this.guideModalEl, true);
          releaseOverlayIsolation(this.guideModalEl);
        } else {
          activateOverlayIsolation(this.guideModalEl);
        }
        if (!this.guideModalEl.dataset.simpleGuideBound) {
          this.addSafeEventListener(this.guideModalEl, 'click', this.onGuideModalClick, {
            context: 'handling game guide backdrop',
          });
          this.addSafeEventListener(this.guideModalEl, 'keydown', this.onGuideKeyDown, {
            context: 'navigating game guide',
          });
          this.guideModalEl.dataset.simpleGuideBound = 'true';
        }
      }
      if (!Array.isArray(this.guideCloseButtons)) {
        this.guideCloseButtons = [];
      }
      if (this.openGuideButton && !this.openGuideButton.dataset.simpleGuideBound) {
        this.addSafeEventListener(this.openGuideButton, 'click', this.onOpenGuide, {
          context: 'opening game guide',
        });
        this.openGuideButton.dataset.simpleGuideBound = 'true';
      }
      this.guideCloseButtons.forEach((button) => {
        if (!button || button.dataset.simpleGuideBound) {
          return;
        }
        this.addSafeEventListener(button, 'click', this.onCloseGuide, {
          context: 'closing game guide',
        });
        button.dataset.simpleGuideBound = 'true';
      });
      if (this.guidePrevButton && !this.guidePrevButton.dataset.simpleGuideBound) {
        this.addSafeEventListener(this.guidePrevButton, 'click', this.onGuidePrev, {
          context: 'showing previous guide slide',
        });
        this.guidePrevButton.dataset.simpleGuideBound = 'true';
      }
      if (this.guideNextButton && !this.guideNextButton.dataset.simpleGuideBound) {
        this.addSafeEventListener(this.guideNextButton, 'click', this.onGuideNext, {
          context: 'showing next guide slide',
        });
        this.guideNextButton.dataset.simpleGuideBound = 'true';
      }
      this.renderGuideCard(this.activeGuideIndex ?? 0, {
        rebuildDots: true,
        scrollToTop: false,
        silent: true,
      });
      this.updateGuideAria();
    }

    setupTutorialUi() {
      this.refreshFirstRunTutorialContent();
      this.updateTutorialTriggerState();
      if (this.openTutorialButton && !this.openTutorialButton.dataset.simpleTutorialBound) {
        this.addSafeEventListener(this.openTutorialButton, 'click', this.onOpenTutorial, {
          context: 'toggling tutorial overlay',
        });
        this.openTutorialButton.dataset.simpleTutorialBound = 'true';
        if (!this.openTutorialButton.hasAttribute('aria-pressed')) {
          this.openTutorialButton.setAttribute('aria-pressed', 'false');
        }
      }
    }

    setupLostGuidanceUi() {
      this.refreshLostGuidanceContent();
      const banner = this.lostGuidanceEl;
      if (banner) {
        banner.hidden = true;
        banner.classList.remove('is-visible');
        safelySetAriaHidden(banner, true);
      }
      if (this.lostGuidanceDismissButton && !this.lostGuidanceDismissButton.dataset.simpleLostBound) {
        this.addSafeEventListener(this.lostGuidanceDismissButton, 'click', this.onLostGuidanceDismiss, {
          context: 'dismissing lost guidance',
        });
        this.lostGuidanceDismissButton.dataset.simpleLostBound = 'true';
      }
    }

    updateTutorialTriggerState() {
      if (!this.openTutorialButton) {
        return;
      }
      const visible = this.firstRunTutorialEl ? this.firstRunTutorialEl.hidden === false : false;
      this.openTutorialButton.setAttribute('aria-pressed', visible ? 'true' : 'false');
    }

    getGuideSlides() {
      return Array.isArray(this.guideSlides) ? this.guideSlides : [];
    }

    resolveGuideItemKeys(item) {
      if (!item) {
        return [];
      }
      let keys = [];
      if (typeof item.resolveKeys === 'function') {
        const resolved = item.resolveKeys(this);
        if (Array.isArray(resolved)) {
          keys = resolved;
        } else if (typeof resolved === 'string') {
          keys = [resolved];
        }
      } else if (Array.isArray(item.keys)) {
        keys = item.keys;
      } else if (typeof item.keys === 'string') {
        keys = [item.keys];
      }
      const seen = new Set();
      const output = [];
      keys.forEach((value) => {
        if (typeof value !== 'string') {
          return;
        }
        const label = value.trim();
        if (!label || seen.has(label)) {
          return;
        }
        seen.add(label);
        output.push(label);
      });
      return output;
    }

    renderGuideCard(index, options = {}) {
      if (!this.guideCardEl) {
        this.updateGuideDots({ rebuild: options?.rebuildDots === true });
        return;
      }
      const { rebuildDots = false, scrollToTop = true, silent = false } = options ?? {};
      const slides = this.getGuideSlides();
      if (!slides.length) {
        this.guideCardEl.textContent = 'Game guide unavailable.';
        this.updateGuideDots({ rebuild: rebuildDots });
        return;
      }
      const count = slides.length;
      const normalized = ((index % count) + count) % count;
      this.activeGuideIndex = normalized;
      const slide = slides[normalized];
      const card = this.guideCardEl;
      card.innerHTML = '';
      if (slide?.id) {
        card.dataset.guideId = slide.id;
      } else {
        delete card.dataset.guideId;
      }
      card.setAttribute('data-guide-index', String(normalized));
      if (slide?.title) {
        card.setAttribute('aria-label', `${slide.title} (${normalized + 1} of ${count})`);
      } else {
        card.removeAttribute('aria-label');
      }
      const header = document.createElement('div');
      header.className = 'guide-card__header';
      if (slide?.icon) {
        const iconEl = document.createElement('span');
        iconEl.className = 'guide-card__icon';
        const glyph = document.createElement('span');
        glyph.textContent = slide.icon;
        glyph.setAttribute('aria-hidden', 'true');
        iconEl.appendChild(glyph);
        header.appendChild(iconEl);
      }
      const headerBody = document.createElement('div');
      if (slide?.label) {
        const labelEl = document.createElement('span');
        labelEl.className = 'guide-card__label';
        labelEl.textContent = slide.label;
        headerBody.appendChild(labelEl);
      }
      if (slide?.title) {
        const titleEl = document.createElement('h3');
        titleEl.className = 'guide-card__title';
        titleEl.textContent = slide.title;
        headerBody.appendChild(titleEl);
      }
      if (slide?.description) {
        const descriptionEl = document.createElement('p');
        descriptionEl.className = 'guide-card__description';
        descriptionEl.textContent = slide.description;
        headerBody.appendChild(descriptionEl);
      }
      header.appendChild(headerBody);
      card.appendChild(header);

      const sections =
        typeof slide?.sections === 'function'
          ? slide.sections(this)
          : Array.isArray(slide?.sections)
            ? slide.sections
            : [];
      if (sections.length) {
        const columns = document.createElement('div');
        columns.className = 'guide-card__columns';
        sections.forEach((section) => {
          if (!section) {
            return;
          }
          const { items = [], title } = section;
          if (!Array.isArray(items) || !items.length) {
            return;
          }
          const sectionEl = document.createElement('section');
          sectionEl.className = 'guide-card__list';
          if (title) {
            const heading = document.createElement('h4');
            heading.textContent = title;
            sectionEl.appendChild(heading);
          }
          const listEl = document.createElement('ul');
          items.forEach((item) => {
            if (!item) {
              return;
            }
            const entry = document.createElement('li');
            entry.className = 'guide-card__control';
            if (item.label) {
              const caption = document.createElement('p');
              caption.className = 'guide-card__caption';
              caption.textContent = item.label;
              entry.appendChild(caption);
            }
            const keyLabels = this.resolveGuideItemKeys(item);
            if (keyLabels.length) {
              const keyList = document.createElement('div');
              keyList.className = 'guide-card__control-keys';
              keyLabels.forEach((label) => {
                const kbd = document.createElement('kbd');
                kbd.textContent = label;
                keyList.appendChild(kbd);
              });
              entry.appendChild(keyList);
            }
            if (item.description) {
              const detail = document.createElement('p');
              detail.className = 'guide-card__tip';
              detail.textContent = item.description;
              entry.appendChild(detail);
            }
            listEl.appendChild(entry);
          });
          sectionEl.appendChild(listEl);
          columns.appendChild(sectionEl);
        });
        card.appendChild(columns);
      }
      if (slide?.footer) {
        const footer = document.createElement('p');
        footer.className = 'guide-card__caption';
        footer.textContent = slide.footer;
        card.appendChild(footer);
      }
      this.updateGuideDots({ rebuild: rebuildDots });
      this.updateGuideNavigationState();
      if (scrollToTop) {
        this.scrollGuideToTop();
      }
      if (!silent) {
        card.setAttribute('data-updated-at', String(Date.now()));
      }
    }

    updateGuideDots(options = {}) {
      if (!this.guideDotsContainer) {
        return;
      }
      const slides = this.getGuideSlides();
      if (!slides.length) {
        this.guideDotsContainer.innerHTML = '';
        this.guideDotButtons = [];
        return;
      }
      const rebuild = Boolean(options?.rebuild) || this.guideDotButtons.length !== slides.length;
      if (rebuild) {
        this.guideDotsContainer.innerHTML = '';
        this.guideDotButtons = slides.map((slide, index) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.dataset.guideIndex = String(index);
          button.setAttribute(
            'aria-label',
            `${slide?.title ?? 'Guide card'} (${index + 1} of ${slides.length})`,
          );
          this.addSafeEventListener(button, 'click', this.onGuideDotActivate, {
            context: 'activating guide slide via dot',
          });
          this.guideDotsContainer.appendChild(button);
          return button;
        });
      }
      this.guideDotButtons.forEach((button, index) => {
        if (!button) {
          return;
        }
        const isActive = index === this.activeGuideIndex;
        button.setAttribute('data-active', isActive ? 'true' : 'false');
        if (isActive) {
          button.setAttribute('aria-current', 'true');
        } else {
          button.removeAttribute('aria-current');
        }
      });
    }

    updateGuideNavigationState() {
      const slides = this.getGuideSlides();
      const count = slides.length || 1;
      if (this.guidePrevButton) {
        const prevIndex = ((this.activeGuideIndex - 1 + count) % count + count) % count;
        this.guidePrevButton.dataset.targetIndex = String(prevIndex);
        const title = slides[prevIndex]?.title ?? 'Previous guide card';
        this.guidePrevButton.setAttribute('aria-label', `Previous: ${title} (${prevIndex + 1} of ${count})`);
      }
      if (this.guideNextButton) {
        const nextIndex = (this.activeGuideIndex + 1) % count;
        this.guideNextButton.dataset.targetIndex = String(nextIndex);
        const title = slides[nextIndex]?.title ?? 'Next guide card';
        this.guideNextButton.setAttribute('aria-label', `Next: ${title} (${nextIndex + 1} of ${count})`);
      }
    }

    updateGuideAria() {
      if (this.openGuideButton) {
        this.openGuideButton.setAttribute('aria-expanded', this.guideModalVisible ? 'true' : 'false');
      }
    }

    scrollGuideToTop() {
      if (!this.guideScrollContainer) {
        return;
      }
      try {
        if (typeof this.guideScrollContainer.scrollTo === 'function') {
          this.guideScrollContainer.scrollTo({ top: 0, behavior: 'instant' });
          return;
        }
      } catch (error) {
        if (typeof console !== 'undefined' && typeof console.debug === 'function') {
          console.debug('Guide scroll reset failed; falling back to scrollTop.', error);
        }
      }
      this.guideScrollContainer.scrollTop = 0;
    }

    toggleGuideModal(visible, options = {}) {
      if (!this.guideModalEl) {
        return;
      }
      const nextVisible = Boolean(visible);
      if (nextVisible === this.guideModalVisible && !options?.force) {
        return;
      }
      if (nextVisible) {
        this.renderGuideCard(this.activeGuideIndex ?? 0, { rebuildDots: true, scrollToTop: true });
        this.guideModalEl.hidden = false;
        setInertState(this.guideModalEl, false);
        activateOverlayIsolation(this.guideModalEl);
        safelySetAriaHidden(this.guideModalEl, false);
        if (typeof document !== 'undefined' && typeof document.exitPointerLock === 'function') {
          document.exitPointerLock();
        }
        this.scrollGuideToTop();
        const focusTarget =
          options?.focusTarget || this.guideCloseButtons?.[0] || this.guidePrevButton || this.guideCardEl;
        if (focusTarget && typeof focusTarget.focus === 'function') {
          focusTarget.focus({ preventScroll: true });
        }
      } else {
        const doc =
          (typeof document !== 'undefined' ? document : null) ||
          this.guideModalEl?.ownerDocument ||
          null;
        const restoreCandidate =
          options?.returnFocus === false ? null : this.lastGuideTrigger || this.openGuideButton;
        const restore =
          restoreCandidate &&
          typeof restoreCandidate.focus === 'function' &&
          !(typeof this.guideModalEl.contains === 'function' && this.guideModalEl.contains(restoreCandidate))
            ? restoreCandidate
            : null;
        let focusHandled = false;
        if (doc?.activeElement && this.guideModalEl.contains?.(doc.activeElement)) {
          if (restore) {
            restore.focus({ preventScroll: true });
          } else {
            this.focusGameViewport();
          }
          focusHandled = true;
        }
        this.guideModalEl.hidden = true;
        setInertState(this.guideModalEl, true);
        releaseOverlayIsolation(this.guideModalEl);
        const fallbackFocus = restore
          ? () => {
              try {
                restore.focus({ preventScroll: true });
              } catch (error) {
                restore.focus();
              }
            }
          : () => {
              this.focusGameViewport();
              return true;
            };
        safelySetAriaHidden(this.guideModalEl, true, { fallbackFocus });
        if (!focusHandled) {
          if (restore) {
            restore.focus({ preventScroll: true });
          } else {
            this.focusGameViewport();
          }
        }
      }
      this.guideModalVisible = nextVisible;
      this.updateGuideAria();
    }

    showGuideSlide(index, options = {}) {
      const slides = this.getGuideSlides();
      if (!slides.length) {
        return;
      }
      const count = slides.length;
      const normalized = ((index % count) + count) % count;
      const rebuildDots = Boolean(options?.rebuildDots);
      const scrollToTop = options?.scrollToTop !== false;
      this.renderGuideCard(normalized, { rebuildDots, scrollToTop });
      if (options?.focusTarget && typeof options.focusTarget.focus === 'function') {
        options.focusTarget.focus({ preventScroll: true });
      }
    }

    handleOpenTutorial(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      const visible = this.firstRunTutorialEl ? this.firstRunTutorialEl.hidden === false : false;
      if (visible) {
        const markSeen = this.firstRunTutorialMarkOnDismiss;
        const showBriefingAfter = this.firstRunTutorialShowBriefingOnDismiss;
        this.hideFirstRunTutorial({ markSeen, showBriefingAfter });
        return;
      }
      this.showFirstRunTutorial({ autoFocus: true });
    }

    handleOpenGuide(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      const trigger = event?.currentTarget || event?.target || this.openGuideButton;
      this.lastGuideTrigger = trigger && typeof trigger.focus === 'function' ? trigger : this.openGuideButton;
      this.toggleGuideModal(true, { focusTarget: this.guideCloseButtons?.[0] || null });
    }

    handleCloseGuide(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      this.toggleGuideModal(false);
    }

    handleGuideModalClick(event) {
      if (!this.guideModalVisible) {
        return;
      }
      if (event?.target === this.guideModalEl) {
        this.toggleGuideModal(false);
      }
    }

    handleGuidePrev(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      this.showGuideSlide(this.activeGuideIndex - 1, { scrollToTop: true });
    }

    handleGuideNext(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      this.showGuideSlide(this.activeGuideIndex + 1, { scrollToTop: true });
    }

    handleGuideDotActivate(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      const target = event?.currentTarget || event?.target || null;
      const rawIndex = target?.dataset?.guideIndex ?? '-1';
      const index = Number.parseInt(rawIndex, 10);
      if (!Number.isInteger(index) || index < 0) {
        return;
      }
      this.showGuideSlide(index, { scrollToTop: true });
    }

    handleGuideKeyDown(event) {
      if (!this.guideModalVisible || !event) {
        return;
      }
      const key = event.key || event.code;
      switch (key) {
        case 'Escape':
        case 'Esc':
          event.preventDefault();
          this.toggleGuideModal(false);
          break;
        case 'ArrowLeft':
        case 'Left':
          event.preventDefault();
          this.showGuideSlide(this.activeGuideIndex - 1, { scrollToTop: false });
          break;
        case 'ArrowRight':
        case 'Right':
          event.preventDefault();
          this.showGuideSlide(this.activeGuideIndex + 1, { scrollToTop: false });
          break;
        case 'Home':
          event.preventDefault();
          this.showGuideSlide(0, { scrollToTop: true });
          break;
        case 'End':
          event.preventDefault();
          this.showGuideSlide(this.getGuideSlides().length - 1, { scrollToTop: true });
          break;
        default:
      }
    }

    focusGameViewport(options = {}) {
      const doc = typeof document !== 'undefined' ? document : null;
      if (!doc) {
        return false;
      }
      const {
        preventScroll = true,
        preferCanvas = true,
        preferredTarget = null,
        fallbackSelectors = [
          '[data-focus-default]',
          '[data-focus-target]',
          'button:not([disabled])',
          '[href]',
          '[tabindex]:not([tabindex="-1"])',
        ],
      } = typeof options === 'object' && options ? options : {};
      const hudRoot = this.hudRootEl || this.ui?.hudRootEl || null;
      const focusTargets = [];
      if (preferredTarget && typeof preferredTarget.focus === 'function') {
        focusTargets.push(preferredTarget);
      }
      if (preferCanvas && this.canvas && typeof this.canvas.focus === 'function') {
        focusTargets.push(this.canvas);
      }
      if (hudRoot) {
        if (typeof hudRoot.getAttribute === 'function' && hudRoot.getAttribute('tabindex') === null) {
          hudRoot.setAttribute('tabindex', '-1');
        }
        if (typeof hudRoot.querySelector === 'function') {
          for (const selector of fallbackSelectors) {
            if (!selector) {
              continue;
            }
            const candidate = hudRoot.querySelector(selector);
            if (candidate && typeof candidate.focus === 'function') {
              focusTargets.push(candidate);
              break;
            }
          }
        }
        focusTargets.push(hudRoot);
      }
      const attempted = new Set();
      const tryFocus = (element) => {
        if (!element || typeof element.focus !== 'function' || attempted.has(element)) {
          return false;
        }
        attempted.add(element);
        try {
          if (preventScroll) {
            element.focus({ preventScroll: true });
          } else {
            element.focus();
          }
          return true;
        } catch (error) {
          try {
            element.focus();
            return true;
          } catch (nestedError) {
            return false;
          }
        }
      };
      for (const element of focusTargets) {
        if (tryFocus(element)) {
          return true;
        }
      }
      if (!preferCanvas && this.canvas && typeof this.canvas.focus === 'function') {
        if (tryFocus(this.canvas)) {
          return true;
        }
      }
      return false;
    }

    bindFirstRunTutorialControls() {
      if (this.firstRunTutorialControlsBound) {
        return;
      }
      if (this.firstRunTutorialCloseButton) {
        this.firstRunTutorialCloseButton.addEventListener('click', this.onFirstRunTutorialClose);
      }
      if (this.firstRunTutorialPrimaryButton) {
        this.firstRunTutorialPrimaryButton.addEventListener('click', this.onFirstRunTutorialClose);
      }
      if (this.firstRunTutorialEl) {
        this.firstRunTutorialEl.addEventListener('keydown', this.onFirstRunTutorialKeyDown);
      }
      if (this.firstRunTutorialBackdrop) {
        this.firstRunTutorialBackdrop.addEventListener('click', this.onFirstRunTutorialClose);
      }
      this.firstRunTutorialControlsBound = true;
    }

    hasSeenFirstRunTutorial() {
      if (this.firstRunTutorialSeenCache === true) {
        return true;
      }
      if (this.firstRunTutorialSeenCache === false) {
        return false;
      }
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      if (!scope?.localStorage) {
        this.firstRunTutorialSeenCache = false;
        return false;
      }
      try {
        const stored = scope.localStorage.getItem(FIRST_RUN_TUTORIAL_STORAGE_KEY);
        const seen = stored === '1' || stored === 'true';
        this.firstRunTutorialSeenCache = seen;
        return seen;
      } catch (error) {
        if (typeof console !== 'undefined' && console.debug) {
          console.debug('Unable to read first run tutorial preference from storage.', error);
        }
        this.firstRunTutorialSeenCache = false;
        return false;
      }
    }

    markFirstRunTutorialSeen() {
      this.firstRunTutorialSeenCache = true;
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      if (!scope?.localStorage) {
        return;
      }
      try {
        scope.localStorage.setItem(FIRST_RUN_TUTORIAL_STORAGE_KEY, '1');
      } catch (error) {
        if (typeof console !== 'undefined' && console.debug) {
          console.debug('Unable to persist first run tutorial preference.', error);
        }
      }
    }

    recordMajorIssue(message, context = {}) {
      const trimmed = typeof message === 'string' ? message.trim() : '';
      if (!trimmed) {
        return;
      }
      if (!Array.isArray(this.majorIssueLog)) {
        this.majorIssueLog = [];
      }
      if (!(this.majorIssueKeys instanceof Set)) {
        this.majorIssueKeys = new Set();
      }
      const scopeRaw = typeof context.scope === 'string' ? context.scope.trim().toLowerCase() : '';
      const codeRaw = typeof context.code === 'string' ? context.code.trim().toLowerCase() : '';
      const keyParts = [];
      if (scopeRaw) {
        keyParts.push(scopeRaw);
      }
      if (codeRaw) {
        keyParts.push(codeRaw);
      }
      keyParts.push(trimmed.toLowerCase());
      const key = keyParts.join('|');
      if (this.majorIssueKeys.has(key)) {
        return;
      }
      this.majorIssueKeys.add(key);
      const entry = {
        key,
        scope: scopeRaw || null,
        code: codeRaw || null,
        message: trimmed,
        timestamp: Date.now(),
      };
      this.majorIssueLog.push(entry);
      const maxEntries = 12;
      if (this.majorIssueLog.length > maxEntries) {
        const removeCount = this.majorIssueLog.length - maxEntries;
        const removed = this.majorIssueLog.splice(0, removeCount);
        removed.forEach((item) => {
          if (item?.key) {
            this.majorIssueKeys.delete(item.key);
          }
        });
      }
      if (this.firstRunTutorialEl && this.firstRunTutorialEl.hidden === false) {
        this.refreshFirstRunTutorialErrors();
      }
    }

    clearMajorIssues(scope) {
      const scopeKey = typeof scope === 'string' ? scope.trim().toLowerCase() : '';
      if (!scopeKey || !Array.isArray(this.majorIssueLog) || this.majorIssueLog.length === 0) {
        return;
      }
      const remaining = [];
      for (const entry of this.majorIssueLog) {
        if (entry?.scope === scopeKey) {
          if (entry?.key) {
            this.majorIssueKeys.delete(entry.key);
          }
          continue;
        }
        remaining.push(entry);
      }
      this.majorIssueLog = remaining;
      if (this.firstRunTutorialEl && this.firstRunTutorialEl.hidden === false) {
        this.refreshFirstRunTutorialErrors();
      }
    }

    formatMajorIssueScope(scope) {
      if (typeof scope !== 'string' || !scope.trim()) {
        return '';
      }
      const normalised = scope.trim().toLowerCase();
      const mapping = {
        renderer: 'Renderer',
        assets: 'Assets',
        asset: 'Assets',
        leaderboard: 'Leaderboard',
        network: 'Network',
        input: 'Input',
      };
      if (mapping[normalised]) {
        return mapping[normalised];
      }
      return normalised.charAt(0).toUpperCase() + normalised.slice(1);
    }

    getMajorIssueEntries(limit = 4) {
      if (!Array.isArray(this.majorIssueLog) || this.majorIssueLog.length === 0) {
        return [];
      }
      const count = Number.isFinite(limit) && limit > 0 ? Math.floor(limit) : this.majorIssueLog.length;
      return this.majorIssueLog.slice(-count);
    }

    refreshFirstRunTutorialErrors() {
      const container = this.firstRunTutorialIssuesEl || null;
      const listEl = this.firstRunTutorialIssuesListEl || null;
      if (!container || !listEl) {
        return;
      }
      const entries = this.getMajorIssueEntries(4);
      if (!entries.length) {
        container.hidden = true;
        container.dataset.visible = 'false';
        safelySetAriaHidden(container, true);
        listEl.textContent = '';
        return;
      }
      const doc = listEl.ownerDocument || (typeof document !== 'undefined' ? document : null);
      if (!doc || typeof doc.createDocumentFragment !== 'function') {
        return;
      }
      const fragment = doc.createDocumentFragment();
      entries.forEach((entry) => {
        if (!entry || !entry.message) {
          return;
        }
        const item = doc.createElement('li');
        const scopeLabel = this.formatMajorIssueScope(entry.scope);
        item.textContent = scopeLabel ? `${scopeLabel} — ${entry.message}` : entry.message;
        fragment.appendChild(item);
      });
      listEl.textContent = '';
      listEl.appendChild(fragment);
      container.hidden = false;
      container.dataset.visible = 'true';
      safelySetAriaHidden(container, false);
    }

    refreshFirstRunTutorialContent() {
      const moveDetail = this.firstRunTutorialMoveDetail || null;
      const gatherDetail = this.firstRunTutorialGatherDetail || null;
      const craftDetail = this.firstRunTutorialCraftDetail || null;
      const noteEl = this.firstRunTutorialNoteEl || null;
      if (!moveDetail && !gatherDetail && !craftDetail && !noteEl) {
        this.refreshFirstRunTutorialErrors();
        this.refreshLostGuidanceContent();
        return;
      }
      const prefersTouch = Boolean(this.isTouchPreferred);
      if (prefersTouch) {
        if (moveDetail) {
          moveDetail.innerHTML =
            'Drag the <strong>left joystick</strong> or tap the arrow pads to travel, and swipe the viewport to look around.';
        }
        if (gatherDetail) {
          gatherDetail.innerHTML =
            'Tap the <strong>✦</strong> action button or the highlighted object to harvest resources and trigger switches.';
        }
        if (craftDetail) {
          craftDetail.innerHTML =
            'Tap the <strong>hammer</strong> icon to craft. Place blocks with the <strong>✦</strong> action button while aiming and ignite portals with the <strong>⧉</strong> control.';
        }
        if (noteEl) {
          noteEl.innerHTML = 'Need a refresher later? Tap the <strong>How to Play</strong> button in the HUD anytime.';
        }
        this.refreshFirstRunTutorialErrors();
        this.refreshLostGuidanceContent();
        return;
      }
      const movementKeys = formatKeyListForSentence(
        this.getCombinedActionLabels(MOVEMENT_ACTIONS, { limitPerAction: 1 }),
        { fallback: 'W, A, S, or D' },
      );
      const interactKeys = formatKeyListForSentence(this.getActionKeyLabels('interact', { limit: 3 }), { fallback: 'F' });
      const craftingKeys = formatKeyListForSentence(this.getActionKeyLabels('toggleCrafting', { limit: 2 }), {
        fallback: 'E',
      });
      const placeKeys = formatKeyListForSentence(this.getActionKeyLabels('placeBlock', { limit: 2 }), { fallback: 'Q' });
      const portalKeys = formatKeyListForSentence(this.getActionKeyLabels('buildPortal', { limit: 2 }), { fallback: 'R' });
      const tutorialKeys = formatKeyListForSentence(this.getActionKeyLabels('toggleTutorial', { limit: 2 }), {
        fallback: '?',
      });
      if (moveDetail) {
        moveDetail.innerHTML = `Use <strong>${movementKeys}</strong> to travel, and move the mouse to survey the realm.`;
      }
      if (gatherDetail) {
        gatherDetail.innerHTML = `Face a resource tile, then press <strong>${interactKeys}</strong> or click to harvest, open chests, and trigger switches.`;
      }
      if (craftDetail) {
        craftDetail.innerHTML = `Tap the <strong>hammer</strong> icon or press <strong>${craftingKeys}</strong> to craft. Place blocks with <strong>${placeKeys}</strong> and ignite portals with <strong>${portalKeys}</strong>.`;
      }
      if (noteEl) {
        noteEl.innerHTML = `Need a refresher later? Press <strong>${tutorialKeys}</strong> or use the <strong>How to Play</strong> button in the HUD.`;
      }
      this.refreshFirstRunTutorialErrors();
      this.refreshLostGuidanceContent();
    }

    refreshLostGuidanceContent() {
      const banner = this.lostGuidanceEl;
      if (!banner) {
        return;
      }
      const prefersTouch = this.detectTouchPreferred();
      const moveEl = this.lostGuidanceMoveKeysEl;
      const gatherEl = this.lostGuidanceGatherKeysEl;
      const craftEl = this.lostGuidanceCraftKeyEl;
      const portalEl = this.lostGuidancePortalKeysEl;
      if (prefersTouch) {
        if (moveEl) {
          moveEl.textContent = 'Left joystick · Swipe';
        }
        if (gatherEl) {
          gatherEl.textContent = 'Tap ✦ · Tap blocks';
        }
        if (craftEl) {
          craftEl.textContent = 'Hammer button';
        }
        if (portalEl) {
          portalEl.textContent = '✦ to place · ⧉ to ignite';
        }
        return;
      }
      if (moveEl) {
        moveEl.textContent = this.getMovementKeySummary({ joiner: ' · ', fallback: 'W · A · S · D' });
      }
      if (gatherEl) {
        const gatherKeys = [];
        const jumpLabel = this.getActionKeyLabels('jump', { limit: 1 })?.[0];
        if (jumpLabel) {
          gatherKeys.push(jumpLabel);
        }
        gatherKeys.push('Click');
        this.getActionKeyLabels('interact', { limit: 2 }).forEach((label) => {
          if (label && !gatherKeys.includes(label)) {
            gatherKeys.push(label);
          }
        });
        gatherEl.textContent = gatherKeys.length ? gatherKeys.join(' · ') : 'Space · Click · F';
      }
      if (craftEl) {
        const craftLabel = this.getActionKeyLabels('toggleCrafting', { limit: 1 })?.[0] || 'E';
        craftEl.textContent = craftLabel;
      }
      if (portalEl) {
        const placeLabel = this.getActionKeyLabels('placeBlock', { limit: 1 })?.[0] || 'Q';
        const igniteLabel = this.getActionKeyLabels('buildPortal', { limit: 1 })?.[0] || 'R';
        portalEl.textContent = `${placeLabel} · ${igniteLabel}`;
      }
    }

    maybeShowFirstRunTutorial() {
      if (!this.firstRunTutorialEl) {
        return false;
      }
      if (this.hasSeenFirstRunTutorial()) {
        return false;
      }
      this.showFirstRunTutorial({ markSeenOnDismiss: true, autoFocus: true, showBriefingAfter: true });
      return true;
    }

    showFirstRunTutorial({ markSeenOnDismiss = false, autoFocus = false, showBriefingAfter = false } = {}) {
      const overlay = this.firstRunTutorialEl;
      if (!overlay) {
        return false;
      }
      this.refreshFirstRunTutorialContent();
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      if (scope && this.firstRunTutorialHideTimer) {
        scope.clearTimeout(this.firstRunTutorialHideTimer);
        this.firstRunTutorialHideTimer = null;
      }
      this.bindFirstRunTutorialControls();
      overlay.hidden = false;
      setInertState(overlay, false);
      activateOverlayIsolation(overlay);
      overlay.setAttribute('data-visible', 'true');
      this.firstRunTutorialMarkOnDismiss = !!markSeenOnDismiss;
      this.firstRunTutorialShowBriefingOnDismiss = !!showBriefingAfter;
      const body = typeof document !== 'undefined' ? document.body : null;
      if (body?.classList) {
        body.classList.add('first-run-tutorial-active');
      }
      this.updateTutorialTriggerState();
      const raf =
        typeof requestAnimationFrame === 'function'
          ? requestAnimationFrame
          : scope?.requestAnimationFrame ?? null;
      if (typeof raf === 'function') {
        raf(() => {
          overlay.classList.add('is-visible');
        });
      } else {
        overlay.classList.add('is-visible');
      }
      if (autoFocus && this.firstRunTutorialPrimaryButton) {
        const focusTarget = this.firstRunTutorialPrimaryButton;
        const timerHost = scope ?? (typeof globalThis !== 'undefined' ? globalThis : null);
        const focus = () => {
          try {
            focusTarget.focus({ preventScroll: true });
          } catch (error) {
            try {
              focusTarget.focus();
            } catch (nestedError) {
              if (typeof console !== 'undefined' && console.debug) {
                console.debug('Unable to focus tutorial primary action.', nestedError);
              }
            }
          }
        };
        if (timerHost?.setTimeout) {
          timerHost.setTimeout(focus, 80);
        } else {
          focus();
        }
      }
      return true;
    }

    hideFirstRunTutorial({ markSeen = false, showBriefingAfter = false } = {}) {
      const overlay = this.firstRunTutorialEl;
      if (!overlay) {
        if (markSeen) {
          this.markFirstRunTutorialSeen();
        }
        if (showBriefingAfter) {
          this.showBriefingOverlay();
        }
        this.updateTutorialTriggerState();
        return false;
      }
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      if (scope && this.firstRunTutorialHideTimer) {
        scope.clearTimeout(this.firstRunTutorialHideTimer);
        this.firstRunTutorialHideTimer = null;
      }
      overlay.classList.remove('is-visible');
      overlay.setAttribute('data-visible', 'false');
      const body = typeof document !== 'undefined' ? document.body : null;
      const finalise = () => {
        overlay.hidden = true;
        setInertState(overlay, true);
        releaseOverlayIsolation(overlay);
        if (body?.classList) {
          body.classList.remove('first-run-tutorial-active');
        }
        if (showBriefingAfter) {
          this.showBriefingOverlay();
        } else {
          this.focusGameViewport();
        }
        this.firstRunTutorialHideTimer = null;
        this.updateTutorialTriggerState();
      };
      if (scope?.setTimeout) {
        this.firstRunTutorialHideTimer = scope.setTimeout(finalise, 220);
      } else {
        finalise();
      }
      if (markSeen) {
        this.markFirstRunTutorialSeen();
      }
      this.firstRunTutorialMarkOnDismiss = false;
      this.firstRunTutorialShowBriefingOnDismiss = false;
      return true;
    }

    handleFirstRunTutorialClose(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      const markSeen = this.firstRunTutorialMarkOnDismiss;
      const showBriefingAfter = this.firstRunTutorialShowBriefingOnDismiss;
      this.hideFirstRunTutorial({ markSeen, showBriefingAfter });
    }

    handleFirstRunTutorialKeyDown(event) {
      if (!event) {
        return;
      }
      const { key } = event;
      if (key === 'Escape' || key === 'Esc') {
        if (event.preventDefault) {
          event.preventDefault();
        }
        const markSeen = this.firstRunTutorialMarkOnDismiss;
        const showBriefingAfter = this.firstRunTutorialShowBriefingOnDismiss;
        this.hideFirstRunTutorial({ markSeen, showBriefingAfter });
      }
    }

    handleLostGuidanceDismiss(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      this.hideLostGuidance({ manual: true });
      this.focusGameViewport();
    }

    showLostGuidance(reason = 'idle') {
      const banner = this.lostGuidanceEl;
      if (!banner || this.lostGuidanceVisible) {
        return false;
      }
      if (this.firstRunTutorialEl && this.firstRunTutorialEl.hidden === false) {
        return false;
      }
      this.refreshLostGuidanceContent();
      banner.hidden = false;
      safelySetAriaHidden(banner, false);
      // Force layout so the transition fires when toggled rapidly.
      void banner.offsetWidth;
      banner.classList.add('is-visible');
      this.lostGuidanceVisible = true;
      this.lostGuidanceDismissedUntilProgress = false;
      const now = this.getHighResTimestamp();
      this.lostGuidanceLastShowAt = now;
      this.lostGuidanceShowCount += 1;
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      if (scope) {
        if (this.lostGuidanceAutoHideHandle) {
          scope.clearTimeout(this.lostGuidanceAutoHideHandle);
        }
        this.lostGuidanceAutoHideHandle = scope.setTimeout(() => {
          this.hideLostGuidance({ reason: 'timeout' });
        }, 12000);
      }
      return true;
    }

    hideLostGuidance({ manual = false, immediate = false, reason = 'auto' } = {}) {
      const banner = this.lostGuidanceEl;
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      if (scope && this.lostGuidanceAutoHideHandle) {
        scope.clearTimeout(this.lostGuidanceAutoHideHandle);
        this.lostGuidanceAutoHideHandle = null;
      }
      if (!banner) {
        if (manual) {
          this.lostGuidanceDismissedUntilProgress = true;
          this.lostGuidanceLastShowAt = this.getHighResTimestamp();
        }
        return false;
      }
      if (!this.lostGuidanceVisible) {
        if (manual) {
          this.lostGuidanceDismissedUntilProgress = true;
          this.lostGuidanceLastShowAt = this.getHighResTimestamp();
        }
        return false;
      }
      const setHidden = () => {
        banner.hidden = true;
        safelySetAriaHidden(banner, true);
      };
      banner.classList.remove('is-visible');
      if (immediate) {
        setHidden();
      } else if (scope && typeof scope.setTimeout === 'function') {
        scope.setTimeout(setHidden, 160);
      } else {
        setHidden();
      }
      this.lostGuidanceVisible = false;
      if (manual) {
        this.lostGuidanceDismissedUntilProgress = true;
        this.lostGuidanceLastShowAt = this.getHighResTimestamp();
      }
      return true;
    }

    resetLostGuidance(reason = 'reset') {
      if (this.lostGuidanceEl) {
        this.hideLostGuidance({ immediate: true, reason: 'reset' });
      }
      const now = this.getHighResTimestamp();
      this.lostGuidanceLastProgressAt = now;
      if (reason === 'start') {
        this.lostGuidanceShowCount = 0;
      }
      this.lostGuidanceDismissedUntilProgress = false;
    }

    showBriefingOverlay() {
      const briefing = this.ui?.gameBriefing;
      if (!briefing) return;
      const timerHost = typeof window !== 'undefined' ? window : globalThis;
      timerHost.clearTimeout(this.briefingAutoHideTimer);
      timerHost.clearTimeout(this.briefingFadeTimer);
      briefing.hidden = false;
      setInertState(briefing, false);
      activateOverlayIsolation(briefing);
      requestAnimationFrame(() => {
        briefing.classList.add('is-visible');
      });
      const dismissButton = this.ui?.dismissBriefingButton;
      if (dismissButton) {
        dismissButton.disabled = false;
        dismissButton.addEventListener('click', this.onDismissBriefing, { once: true });
      }
      this.briefingAutoHideTimer = timerHost.setTimeout(() => {
        this.hideBriefingOverlay();
      }, 5000);
    }

    handleBriefingDismiss(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      this.hideBriefingOverlay(true);
    }

    hideBriefingOverlay(force = false) {
      const briefing = this.ui?.gameBriefing;
      if (!briefing) return;
      const timerHost = typeof window !== 'undefined' ? window : globalThis;
      timerHost.clearTimeout(this.briefingAutoHideTimer);
      if (!briefing.classList.contains('is-visible')) {
        briefing.hidden = true;
        setInertState(briefing, true);
        releaseOverlayIsolation(briefing);
        this.focusGameViewport();
        return;
      }
      briefing.classList.remove('is-visible');
      setInertState(briefing, true);
      const duration = force ? 120 : 280;
      this.briefingFadeTimer = timerHost.setTimeout(() => {
        briefing.hidden = true;
        releaseOverlayIsolation(briefing);
        this.focusGameViewport();
      }, duration);
    }

    showPointerHint(message) {
      if (!this.pointerHintEl) return;
      this.cancelPointerHintAutoHide();
      if (this.detectTouchPreferred()) {
        this.hidePointerHint(true);
        return;
      }
      const text =
        (typeof message === 'string' && message.trim()) || this.getPointerTutorialMessage();
      if (this.pointerHintEl.textContent !== text) {
        this.pointerHintEl.textContent = text;
      }
      this.pointerHintEl.hidden = false;
      // Force a reflow so the transition triggers reliably when toggling classes quickly.
      void this.pointerHintEl.offsetWidth;
      this.pointerHintEl.classList.add('is-visible');
      this.pointerHintActive = true;
      this.pointerHintLastMessage = text;
      if (this.pointerHintHideTimer) {
        clearTimeout(this.pointerHintHideTimer);
        this.pointerHintHideTimer = null;
      }
    }

    hidePointerHint(immediate = false) {
      if (!this.pointerHintEl) return;
      this.cancelPointerHintAutoHide();
      if (!this.pointerHintActive && !immediate) {
        return;
      }
      const el = this.pointerHintEl;
      const finalize = () => {
        el.hidden = true;
        el.removeEventListener('transitionend', finalize);
        this.pointerHintLastMessage = '';
      };
      el.classList.remove('is-visible');
      this.pointerHintActive = false;
      if (this.pointerHintHideTimer) {
        clearTimeout(this.pointerHintHideTimer);
        this.pointerHintHideTimer = null;
      }
      if (immediate) {
        el.hidden = true;
        this.pointerHintLastMessage = '';
        return;
      }
      el.addEventListener('transitionend', finalize, { once: true });
      this.pointerHintHideTimer = setTimeout(finalize, 340);
    }

    updatePointerHintForInputMode(message) {
      if (!this.pointerHintEl) return;
      if (this.detectTouchPreferred()) {
        this.hidePointerHint(true);
        return;
      }
      const override = typeof message === 'string' ? message : null;
      if (this.pointerLockFallbackActive) {
        const fallbackMessage = override || this.getPointerLockFallbackMessage();
        if (!this.pointerHintActive || this.pointerHintLastMessage !== fallbackMessage) {
          this.showPointerHint(fallbackMessage);
        }
        return;
      }
      if (this.getPointerLockElement() === this.canvas) {
        this.hidePointerHint();
        this.pointerHintLastMessage = '';
        return;
      }
      if (!override && this.pointerHintActive && this.pointerHintLastMessage) {
        // Avoid re-triggering the animation if the hint is already visible with the same text.
        return;
      }
      this.showPointerHint(override || this.pointerHintLastMessage || undefined);
    }

    cancelPointerHintAutoHide() {
      if (!this.pointerHintAutoDismissTimer) {
        return;
      }
      const scope = typeof window !== 'undefined' ? window : globalThis;
      scope.clearTimeout(this.pointerHintAutoDismissTimer);
      this.pointerHintAutoDismissTimer = null;
    }

    schedulePointerHintAutoHide(seconds = 5) {
      if (!Number.isFinite(seconds) || seconds <= 0) {
        return;
      }
      const scope = typeof window !== 'undefined' ? window : globalThis;
      this.cancelPointerHintAutoHide();
      this.pointerHintAutoDismissTimer = scope.setTimeout(() => {
        this.pointerHintAutoDismissTimer = null;
        this.hidePointerHint();
      }, seconds * 1000);
    }

    showDesktopPointerTutorialHint() {
      if (this.detectTouchPreferred()) {
        return;
      }
      if (this.pointerLocked) {
        return;
      }
      this.updatePointerHintForInputMode(this.getPointerTutorialMessage());
      this.schedulePointerHintAutoHide(5);
    }

    enablePointerLockFallback(reason = 'unavailable', error = null, options = {}) {
      const reasonDetail = typeof reason === 'string' && reason ? ` (${reason})` : '';
      const fallbackMessage =
        typeof options?.message === 'string' && options.message.trim() ? options.message.trim() : null;
      this.cancelPointerLockRetry();
      this.pointerLockRetryAttempts = 0;
      this.pointerLockBlockWarningIssued = false;
      if (this.pointerLockFallbackActive) {
        if (!this.pointerLockWarningShown) {
          this.pointerLockWarningShown = true;
          if (typeof console !== 'undefined') {
            if (error) {
              console.warn(
                `Pointer lock unavailable${reasonDetail}; continuing with drag-to-look fallback.${
                  reason === 'error' || reason === 'request-rejected'
                    ? ' Browser privacy settings or extensions may be blocking mouse capture.'
                    : ''
                }`,
                error
              );
            } else {
              console.warn(
                `Pointer lock unavailable${reasonDetail}; continuing with drag-to-look fallback.${
                  reason === 'error' || reason === 'request-rejected'
                    ? ' Browser privacy settings or extensions may be blocking mouse capture.'
                    : ''
                }`
              );
            }
          }
        }
        if (fallbackMessage) {
          this.showPointerLockFallbackNotice(fallbackMessage);
        } else if (!this.pointerLockFallbackMessageActive) {
          this.showPointerLockFallbackNotice();
        } else {
          const message = fallbackMessage || this.getPointerLockFallbackMessage();
          this.updatePointerHintForInputMode(message);
          this.schedulePointerHintAutoHide(8);
        }
        this.setHudInteractionState(true, { timeoutMs: 0 });
        return;
      }
      this.pointerLockFallbackActive = true;
      this.pointerLocked = false;
      this.endPointerFallbackDrag();
      if (!this.pointerLockWarningShown && typeof console !== 'undefined') {
        if (error) {
          console.warn(
            `Pointer lock unavailable${reasonDetail}; switching to drag-to-look fallback.${
              reason === 'error' || reason === 'request-rejected'
                ? ' Browser privacy settings or extensions may be blocking mouse capture.'
                : ''
            }`,
            error
          );
        } else {
          console.warn(
            `Pointer lock unavailable${reasonDetail}; switching to drag-to-look fallback.${
              reason === 'error' || reason === 'request-rejected'
                ? ' Browser privacy settings or extensions may be blocking mouse capture.'
                : ''
            }`
          );
        }
        this.pointerLockWarningShown = true;
      }
      this.emitGameEvent('pointer-lock-fallback', { reason });
      if (!this.pointerLockFallbackNoticeShown) {
        this.pointerLockFallbackNoticeShown = true;
        this.showPointerLockFallbackNotice(fallbackMessage || undefined);
      } else {
        const message = fallbackMessage || this.getPointerLockFallbackMessage();
        this.updatePointerHintForInputMode(message);
        this.schedulePointerHintAutoHide(8);
      }
      this.setHudInteractionState(true, { timeoutMs: 0 });
    }

    beginPointerFallbackDrag(event) {
      if (!this.pointerLockFallbackActive) {
        return;
      }
      if (event?.button !== 0 && event?.button !== 2 && event?.button !== 1) {
        return;
      }
      this.pointerFallbackDragging = true;
      this.pointerFallbackButton = event?.button ?? 0;
      this.pointerFallbackLast = { x: event?.clientX ?? 0, y: event?.clientY ?? 0 };
    }

    endPointerFallbackDrag() {
      this.pointerFallbackDragging = false;
      this.pointerFallbackLast = null;
      this.pointerFallbackButton = null;
      this.refreshHudInteractionState();
    }

    initializeScoreboardUi() {
      if (this.refreshScoresButton) {
        this.refreshScoresButton.addEventListener('click', () => {
          try {
            this.loadScoreboard({ force: true });
          } catch (error) {
            this.handleEventDispatchError('refreshing the leaderboard', error);
          }
        });
      }
      this.setScoreboardStatus('Preparing leaderboard…', { offline: false });
      if (this.hasQueuedScoreSyncEntries()) {
        this.showScoreSyncWarning(
          'Leaderboard offline — queued runs will sync once the connection returns.',
        );
        if (this.apiBaseUrl) {
          this.flushScoreSync(true);
        }
      } else {
        this.hideScoreSyncWarning();
      }
    }

    setScoreboardStatus(message, options = {}) {
      const offline =
        typeof options.offline === 'boolean' ? options.offline : this.scoreboardOffline === true;
      const trimmed = typeof message === 'string' && message.trim().length > 0 ? message.trim() : '';
      const scope =
        typeof window !== 'undefined'
          ? window
          : typeof globalThis !== 'undefined'
            ? globalThis
            : null;
      const identityApi = scope?.InfiniteRailsIdentity || scope?.InfiniteRails?.identity || null;
      let targetMessage = trimmed;
      if (!targetMessage && identityApi?.state?.scoreboardMessage) {
        targetMessage = identityApi.state.scoreboardMessage;
      }
      if (!targetMessage && this.scoreboardStatusEl?.textContent) {
        targetMessage = this.scoreboardStatusEl.textContent;
      }
      if (!targetMessage) {
        targetMessage = '';
      }
      this.scoreboardOffline = offline;
      if (identityApi && typeof identityApi.setScoreboardStatus === 'function') {
        identityApi.setScoreboardStatus(targetMessage, { offline });
        return;
      }
      if (this.scoreboardStatusEl) {
        this.scoreboardStatusEl.textContent = targetMessage;
        if (offline) {
          this.scoreboardStatusEl.dataset.offline = 'true';
        } else {
          delete this.scoreboardStatusEl.dataset.offline;
        }
      }
    }

    getNowTimestamp() {
      if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
        return performance.now();
      }
      return Date.now();
    }

    formatBackendEndpointSummary(context = {}) {
      if (!context || typeof context !== 'object') {
        return '';
      }
      if (typeof context.summary === 'string' && context.summary.trim().length) {
        return context.summary.trim();
      }
      const endpoint =
        typeof context.endpoint === 'string' && context.endpoint.trim().length
          ? context.endpoint.trim()
          : '';
      const method =
        typeof context.method === 'string' && context.method.trim().length
          ? context.method.trim().toUpperCase()
          : '';
      const status = Number.isFinite(context.status) ? context.status : null;
      const location = endpoint ? (method ? `${method} ${endpoint}` : endpoint) : '';
      if (location && status !== null) {
        return `${location} → status ${status}`;
      }
      if (location) {
        return location;
      }
      if (status !== null) {
        return `status ${status}`;
      }
      return '';
    }

    handleLeaderboardOffline(error, options = {}) {
      const forceLocalMode = options.forceLocalMode === true;
      if (!this.apiBaseUrl && !forceLocalMode) {
        return;
      }
      const source =
        typeof options.source === 'string' && options.source.trim().length
          ? options.source.trim()
          : 'sync';
      const providedReason =
        typeof options.reason === 'string' && options.reason.trim().length
          ? options.reason.trim()
          : null;
      const method =
        typeof options.method === 'string' && options.method.trim().length
          ? options.method.trim().toUpperCase()
          : typeof error?.method === 'string' && error.method.trim().length
            ? error.method.trim().toUpperCase()
            : null;
      const endpoint =
        typeof options.endpoint === 'string' && options.endpoint.trim().length
          ? options.endpoint.trim()
          : typeof error?.endpoint === 'string' && error.endpoint.trim().length
            ? error.endpoint.trim()
            : null;
      const statusCode = Number.isFinite(options.status)
        ? options.status
        : Number.isFinite(error?.status)
          ? error.status
          : null;
      const summary = this.formatBackendEndpointSummary({ method, endpoint, status: statusCode });
      const fallbackStatusMessage = summary
        ? `Leaderboard unreachable (${summary}) — progress saved locally.`
        : !this.apiBaseUrl && forceLocalMode
          ? 'Offline mode: connect an API to sync runs.'
          : 'Leaderboard offline — progress saved locally.';
      const statusMessage =
        typeof options.message === 'string' && options.message.trim().length
          ? options.message.trim()
          : fallbackStatusMessage;
      const fallbackHint = summary
        ? `Leaderboard unreachable (${summary}). Check your connection or API configuration.`
        : !this.apiBaseUrl && forceLocalMode
          ? 'Leaderboard API not configured — runs stored locally until a backend is connected.'
          : 'Leaderboard offline — progress saved locally. Check your connection or API configuration.';
      const hintMessage =
        typeof options.hint === 'string' && options.hint.trim().length ? options.hint.trim() : fallbackHint;
      this.persistScoreboardEntries();
      this.setScoreboardStatus(statusMessage, { offline: true });
      const now = this.getNowTimestamp();
      const shouldEmitEvent = !this.localLeaderboardActive;
      if (typeof this.showHint === 'function') {
        if (
          shouldEmitEvent ||
          !this.offlineSyncActive ||
          now - this.lastOfflineSyncHintAt >= this.offlineSyncHintCooldownMs
        ) {
          this.showHint(hintMessage);
          this.lastOfflineSyncHintAt = now;
        }
      }
      this.offlineSyncActive = true;
      this.localLeaderboardActive = true;
      const resolvedReason = providedReason || (!this.apiBaseUrl && forceLocalMode ? 'missing-backend' : null);
      const detail = {
        source,
        reason: resolvedReason,
        message: statusMessage,
      };
      if (summary) {
        detail.summary = summary;
      }
      if (endpoint) {
        detail.endpoint = endpoint;
      }
      if (method) {
        detail.method = method;
      }
      if (statusCode !== null) {
        detail.status = statusCode;
      }
      if (hintMessage && hintMessage.length) {
        detail.hint = hintMessage;
      }
      if (error) {
        const errorMessage =
          typeof error.message === 'string' && error.message.trim().length
            ? error.message.trim()
            : String(error);
        if (errorMessage) {
          detail.error = errorMessage;
        }
      }
      this.recordMajorIssue(statusMessage, {
        scope: 'leaderboard',
        code: detail.summary || detail.reason || detail.source || null,
      });
      if (shouldEmitEvent) {
        this.emitGameEvent('score-sync-offline', detail);
      }
      this.showScoreSyncWarning(statusMessage);
    }

    clearOfflineSyncNotice(source, options = {}) {
      const message =
        typeof options.message === 'string' && options.message.trim().length
          ? options.message.trim()
          : null;
      this.setScoreboardStatus(message, { offline: false });
      this.clearMajorIssues('leaderboard');
      if (this.hasQueuedScoreSyncEntries()) {
        const queuedMessage = message
          ? `${message} — syncing queued runs…`
          : 'Sync pending — queued runs will upload when the service responds.';
        this.showScoreSyncWarning(queuedMessage);
        if (this.apiBaseUrl && !this.scoreSyncInFlight) {
          this.flushScoreSync(true);
        }
      } else {
        this.hideScoreSyncWarning(message);
      }
      if (!this.offlineSyncActive) {
        return;
      }
      this.offlineSyncActive = false;
      this.lastOfflineSyncHintAt = 0;
      this.localLeaderboardActive = false;
      const detail = { source };
      if (typeof options.message === 'string' && options.message.trim().length) {
        detail.message = options.message.trim();
      }
      this.emitGameEvent('score-sync-restored', detail);
    }

    async loadScoreboard({ force = false } = {}) {
      if (!this.apiBaseUrl) {
        this.scoreboardPollTimer = 0;
        const statusMessage = force
          ? 'Offline mode: connect an API to sync runs.'
          : 'Local leaderboard active — set APP_CONFIG.apiBaseUrl to publish runs.';
        this.handleLeaderboardOffline(null, {
          source: 'load',
          reason: 'missing-backend',
          forceLocalMode: true,
          message: statusMessage,
          hint: 'Leaderboard API not configured — runs stored locally until a backend is connected.',
        });
        if (!this.scoreboardHydrated) {
          this.renderScoreboard();
          this.scoreboardHydrated = true;
        }
        return;
      }
      if (this.scoreSyncInFlight && !force) {
        return;
      }
      const baseUrl = this.apiBaseUrl.replace(/\/$/, '');
      const url = `${baseUrl}/scores`;
      this.lastScoreboardFetch = typeof performance !== 'undefined' ? performance.now() : Date.now();
      this.setScoreboardStatus('Syncing leaderboard…', { offline: false });
      if (this.refreshScoresButton) {
        this.refreshScoresButton.dataset.loading = 'true';
        this.refreshScoresButton.disabled = true;
        this.refreshScoresButton.setAttribute('aria-busy', 'true');
      }
      try {
        this.scoreSyncInFlight = true;
        const response = await fetch(url, {
          method: 'GET',
          headers: { Accept: 'application/json' },
          credentials: 'omit',
        });
        if (!response.ok) {
          const failure = new Error(`Leaderboard request failed with ${response.status}`);
          failure.status = response.status;
          failure.endpoint = url;
          failure.method = 'GET';
          throw failure;
        }
        let payload = null;
        try {
          payload = await response.json();
        } catch (parseError) {
          payload = null;
        }
        const incoming = Array.isArray(payload?.items)
          ? payload.items
          : Array.isArray(payload)
            ? payload
            : [];
        if (incoming.length) {
          this.mergeScoreEntries(incoming);
        } else {
          this.renderScoreboard();
        }
        let statusMessage;
        if (incoming.length) {
          statusMessage = 'Live multiverse rankings';
        } else {
          statusMessage = 'No public runs yet — forge the first legend!';
        }
        this.setScoreboardStatus(statusMessage, { offline: false });
        this.clearOfflineSyncNotice('load', { message: statusMessage });
        this.scoreboardHydrated = true;
        this.scoreboardPollTimer = 0;
      } catch (error) {
        const statusCode = Number.isFinite(error?.status) ? error.status : null;
        const summary = this.formatBackendEndpointSummary({ method: 'GET', endpoint: url, status: statusCode });
        console.warn('Failed to load scoreboard data', {
          error,
          endpoint: url,
          status: statusCode,
          summary,
        });
        this.handleLeaderboardOffline(error, {
          source: 'load',
          reason: 'score-fetch',
          message:
            summary && summary.length
              ? `Leaderboard unreachable (${summary}) — progress saved locally.`
              : undefined,
          hint:
            summary && summary.length
              ? `Leaderboard unreachable (${summary}). We'll display cached runs until the service returns.`
              : undefined,
          endpoint: url,
          method: 'GET',
          status: statusCode ?? undefined,
        });
        if (!this.scoreboardHydrated) {
          this.renderScoreboard();
          this.scoreboardHydrated = true;
        }
      } finally {
        this.scoreSyncInFlight = false;
        if (this.refreshScoresButton) {
          this.refreshScoresButton.dataset.loading = 'false';
          this.refreshScoresButton.disabled = false;
          this.refreshScoresButton.setAttribute('aria-busy', 'false');
        }
        this.scoreboardPollTimer = 0;
      }
    }

    updateScoreboardPolling(delta) {
      if (!this.apiBaseUrl) {
        return;
      }
      if (!this.scoreboardHydrated || this.scoreSyncInFlight) {
        return;
      }
      if (typeof document !== 'undefined' && document.hidden) {
        return;
      }
      this.scoreboardPollTimer += delta;
      if (this.scoreboardPollTimer < this.scoreboardPollIntervalSeconds) {
        return;
      }
      const now = typeof performance !== 'undefined' ? performance.now() : Date.now();
      const elapsedSinceFetch = this.lastScoreboardFetch ? (now - this.lastScoreboardFetch) / 1000 : Infinity;
      this.scoreboardPollTimer = 0;
      if (elapsedSinceFetch < this.scoreboardPollIntervalSeconds * 0.5) {
        return;
      }
      this.loadScoreboard();
    }

    updateLostGuidance(delta) {
      if (!this.lostGuidanceEl || !this.started || this.rendererUnavailable) {
        return;
      }
      if (this.victoryAchieved) {
        this.hideLostGuidance({ reason: 'victory', immediate: true });
        return;
      }
      const firstRunVisible = this.firstRunTutorialEl ? this.firstRunTutorialEl.hidden === false : false;
      if (firstRunVisible) {
        this.hideLostGuidance({ reason: 'tutorial' });
        return;
      }
      const briefingVisible = this.ui?.gameBriefing ? this.ui.gameBriefing.hidden === false : false;
      if (briefingVisible) {
        return;
      }
      if (this.lostGuidanceDismissedUntilProgress && !this.lostGuidanceVisible) {
        return;
      }
      const now = this.getHighResTimestamp();
      if (!Number.isFinite(this.lostGuidanceLastProgressAt)) {
        this.lostGuidanceLastProgressAt = now;
        return;
      }
      const idleSeconds = Math.max(0, (now - this.lostGuidanceLastProgressAt) / 1000);
      const threshold =
        this.lostGuidanceShowCount === 0
          ? this.lostGuidanceFirstThresholdSeconds
          : this.lostGuidanceRepeatThresholdSeconds;
      if (idleSeconds < threshold) {
        return;
      }
      const sinceLastShow = Math.max(0, (now - (this.lostGuidanceLastShowAt || 0)) / 1000);
      if (sinceLastShow < this.lostGuidanceCooldownSeconds) {
        return;
      }
      this.showLostGuidance('idle');
    }

    getStoredScoreboardEntries() {
      const emptySnapshot = { entries: [], expired: false, updatedAt: 0, legacy: false };
      if (typeof localStorage === 'undefined' || !this.scoreboardStorageKey) {
        return emptySnapshot;
      }
      try {
        const raw = localStorage.getItem(this.scoreboardStorageKey);
        if (!raw) {
          return emptySnapshot;
        }
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) {
          return { entries: parsed, expired: false, updatedAt: 0, legacy: true };
        }
        if (!parsed || typeof parsed !== 'object') {
          return emptySnapshot;
        }
        const entries = Array.isArray(parsed.entries) ? parsed.entries : [];
        const updatedAt = Number(parsed.updatedAt) || 0;
        if (entries.length && updatedAt) {
          const age = Date.now() - updatedAt;
          if (age > SCOREBOARD_CACHE_MAX_AGE_MS) {
            localStorage.removeItem(this.scoreboardStorageKey);
            return { entries: [], expired: true, updatedAt, legacy: false };
          }
        }
        return { entries, expired: false, updatedAt, legacy: false };
      } catch (error) {
        console.warn('Unable to load cached scoreboard snapshot', error);
        return emptySnapshot;
      }
    }

    persistScoreboardEntries() {
      if (typeof localStorage === 'undefined' || !this.scoreboardStorageKey) {
        return;
      }
      try {
        if (!Array.isArray(this.scoreEntries) || this.scoreEntries.length === 0) {
          localStorage.removeItem(this.scoreboardStorageKey);
          return;
        }
        const snapshotLimit = 25;
        const entries = this.scoreEntries
          .slice(0, snapshotLimit)
          .map((entry) => {
            if (!entry || typeof entry !== 'object') {
              return null;
            }
            const copy = { ...entry };
            delete copy.rank;
            delete copy.highlight;
            delete copy.isPlayer;
            return copy;
          })
          .filter(Boolean);
        if (!entries.length) {
          localStorage.removeItem(this.scoreboardStorageKey);
          return;
        }
        const snapshot = {
          version: 1,
          updatedAt: Date.now(),
          entries,
        };
        localStorage.setItem(this.scoreboardStorageKey, JSON.stringify(snapshot));
      } catch (error) {
        console.warn('Unable to persist scoreboard snapshot', error);
      }
    }

    restoreScoreboardEntries() {
      const stored = this.getStoredScoreboardEntries();
      this.scoreboardCacheExpired = stored.expired === true;
      this.restoredScoreEntryIdentifiers = new Set();
      const entries = Array.isArray(stored.entries) ? stored.entries : [];
      if (!entries.length) {
        this.pendingRestoredScoreMerge = false;
        return;
      }
      const utils = this.scoreboardUtils;
      const normalized = utils?.normalizeScoreEntries
        ? utils.normalizeScoreEntries(entries)
        : entries.slice();
      this.scoreEntries = normalized;
      normalized.forEach((entry) => {
        const identifier = this.getScoreEntryIdentifier(entry);
        if (identifier) {
          this.restoredScoreEntryIdentifiers.add(identifier);
        }
      });
      this.pendingRestoredScoreMerge = this.restoredScoreEntryIdentifiers.size > 0;
      this.renderScoreboard();
      this.persistScoreboardEntries();
    }

    normalizeQueuedScoreEntriesForIdentity(sourceIdentifiers) {
      if (!Array.isArray(this.scoreSyncQueue) || !this.scoreSyncQueue.length) {
        return false;
      }
      if (!this.playerGoogleId) {
        return false;
      }
      const googleIdentifier = this.getScoreEntryIdentifier({ id: this.playerGoogleId });
      if (!googleIdentifier) {
        return false;
      }
      const identifiers = new Set();
      const addIdentifier = (value) => {
        if (typeof value !== 'string') {
          return;
        }
        const trimmed = value.trim().toLowerCase();
        if (trimmed && trimmed !== googleIdentifier) {
          identifiers.add(trimmed);
        }
      };
      if (sourceIdentifiers) {
        if (typeof sourceIdentifiers.forEach === 'function') {
          sourceIdentifiers.forEach(addIdentifier);
        } else if (Array.isArray(sourceIdentifiers)) {
          sourceIdentifiers.forEach(addIdentifier);
        } else if (typeof sourceIdentifiers === 'string') {
          addIdentifier(sourceIdentifiers);
        }
      } else if (this.restoredScoreEntryIdentifiers && typeof this.restoredScoreEntryIdentifiers.forEach === 'function') {
        this.restoredScoreEntryIdentifiers.forEach(addIdentifier);
      }
      const sessionIdentifier = this.getScoreEntryIdentifier({ id: this.sessionId });
      if (sessionIdentifier) {
        addIdentifier(sessionIdentifier);
      }
      let queueChanged = false;
      const nextQueue = this.scoreSyncQueue.map((record) => {
        if (!record || typeof record !== 'object') {
          return record;
        }
        const entry = record.entry && typeof record.entry === 'object' ? record.entry : null;
        if (!entry) {
          return record;
        }
        const rawIdentifier =
          typeof record.identifier === 'string' && record.identifier.trim().length
            ? record.identifier.trim().toLowerCase()
            : this.getScoreEntryIdentifier(entry);
        const identifier = rawIdentifier || null;
        const shouldUpgrade = identifier && identifiers.has(identifier);
        const alreadyPlayer = identifier === googleIdentifier;
        if (!shouldUpgrade && !alreadyPlayer) {
          return record;
        }
        const nextEntry = { ...entry };
        let entryChanged = false;
        if (nextEntry.id !== this.playerGoogleId) {
          nextEntry.id = this.playerGoogleId;
          entryChanged = true;
        }
        if (nextEntry.playerId !== this.playerGoogleId) {
          nextEntry.playerId = this.playerGoogleId;
          entryChanged = true;
        }
        if (nextEntry.googleId !== this.playerGoogleId) {
          nextEntry.googleId = this.playerGoogleId;
          entryChanged = true;
        }
        const desiredName =
          typeof this.playerDisplayName === 'string' && this.playerDisplayName.trim().length
            ? this.playerDisplayName
            : nextEntry.name;
        if (desiredName && desiredName !== nextEntry.name) {
          nextEntry.name = desiredName;
          entryChanged = true;
        }
        const currentIdentifier =
          typeof record.identifier === 'string' && record.identifier.trim().length
            ? record.identifier.trim().toLowerCase()
            : null;
        if (!entryChanged && currentIdentifier === googleIdentifier) {
          return record;
        }
        queueChanged = true;
        return {
          ...record,
          entry: entryChanged ? nextEntry : entry,
          identifier: googleIdentifier,
        };
      });
      if (queueChanged) {
        this.scoreSyncQueue = nextQueue;
        this.persistScoreSyncQueue();
      }
      return queueChanged;
    }

    mergeRestoredLocalScoreEntriesWithIdentity() {
      if (!this.playerGoogleId) {
        return false;
      }
      const googleIdentifier = this.getScoreEntryIdentifier({ id: this.playerGoogleId });
      if (!googleIdentifier) {
        return false;
      }
      const identifiers = new Set();
      if (this.restoredScoreEntryIdentifiers && typeof this.restoredScoreEntryIdentifiers.forEach === 'function') {
        this.restoredScoreEntryIdentifiers.forEach((value) => {
          if (typeof value === 'string' && value && value !== googleIdentifier) {
            identifiers.add(value.trim().toLowerCase());
          }
        });
      }
      const sessionIdentifier = this.getScoreEntryIdentifier({ id: this.sessionId });
      if (sessionIdentifier && sessionIdentifier !== googleIdentifier) {
        identifiers.add(sessionIdentifier);
      }
      if (!identifiers.size) {
        this.scoreEntries.forEach((entry) => {
          if (this.isPlayerScoreEntry(entry)) {
            const identifier = this.getScoreEntryIdentifier(entry);
            if (identifier && identifier !== googleIdentifier) {
              identifiers.add(identifier);
            }
          }
        });
      }
      if (!identifiers.size) {
        this.pendingRestoredScoreMerge = false;
        this.restoredScoreEntryIdentifiers = new Set([googleIdentifier]);
        return this.normalizeQueuedScoreEntriesForIdentity([sessionIdentifier]);
      }
      let updated = false;
      const nextEntries = this.scoreEntries.map((entry) => {
        if (!entry || typeof entry !== 'object') {
          return entry;
        }
        const identifier = this.getScoreEntryIdentifier(entry);
        if (!identifier || identifier === googleIdentifier || !identifiers.has(identifier)) {
          return entry;
        }
        const next = {
          ...entry,
          id: this.playerGoogleId,
          playerId: this.playerGoogleId,
          googleId: this.playerGoogleId,
        };
        if (typeof next.name !== 'string' || !next.name.trim().length) {
          next.name = this.playerDisplayName;
        }
        updated = true;
        return next;
      });
      const queueUpdated = this.normalizeQueuedScoreEntriesForIdentity(identifiers);
      this.pendingRestoredScoreMerge = false;
      this.restoredScoreEntryIdentifiers = new Set([googleIdentifier]);
      if (!updated) {
        return queueUpdated;
      }
      const utils = this.scoreboardUtils;
      const normalized = utils?.normalizeScoreEntries
        ? utils.normalizeScoreEntries(nextEntries)
        : nextEntries.slice().sort((a, b) => (b.score ?? 0) - (a.score ?? 0));
      this.scoreEntries = normalized;
      this.persistScoreboardEntries();
      this.renderScoreboard();
      return true;
    }

    updateLocalScoreEntry(reason) {
      const entry = this.createRunSummary(reason);
      this.mergeScoreEntries([entry]);
      this.emitGameEvent('score-updated', { summary: entry });
      return entry;
    }

    restoreScoreSyncQueue() {
      if (typeof localStorage === 'undefined' || !this.scoreSyncQueueKey) {
        return [];
      }
      try {
        const raw = localStorage.getItem(this.scoreSyncQueueKey);
        if (!raw) {
          return [];
        }
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) {
          return [];
        }
        const records = parsed
          .map((item) => {
            if (!item || typeof item !== 'object') {
              return null;
            }
            const entry = item.entry && typeof item.entry === 'object' ? item.entry : null;
            if (!entry) {
              return null;
            }
            const clonedEntry = this.cloneScoreSyncEntry(entry);
            if (!clonedEntry) {
              return null;
            }
            const reason =
              typeof item.reason === 'string' && item.reason.trim().length ? item.reason.trim() : null;
            const identifier =
              typeof item.identifier === 'string' && item.identifier.trim().length
                ? item.identifier.trim().toLowerCase()
                : this.getScoreEntryIdentifier(clonedEntry);
            const queuedAt = Number.isFinite(item.queuedAt) ? item.queuedAt : Date.now();
            return {
              entry: clonedEntry,
              reason,
              identifier,
              queuedAt,
            };
          })
          .filter(Boolean);
        return records;
      } catch (error) {
        console.warn('Unable to restore queued leaderboard sync entries', error);
        return [];
      }
    }

    persistScoreSyncQueue() {
      if (typeof localStorage === 'undefined' || !this.scoreSyncQueueKey) {
        return;
      }
      try {
        if (!this.scoreSyncQueue || !this.scoreSyncQueue.length) {
          localStorage.removeItem(this.scoreSyncQueueKey);
          return;
        }
        const snapshot = this.scoreSyncQueue
          .map((record) => {
            if (!record || typeof record !== 'object' || !record.entry) {
              return null;
            }
            return {
              entry: record.entry,
              reason: record.reason ?? null,
              queuedAt: Number.isFinite(record.queuedAt) ? record.queuedAt : Date.now(),
              identifier: record.identifier ?? this.getScoreEntryIdentifier(record.entry),
            };
          })
          .filter(Boolean);
        if (!snapshot.length) {
          localStorage.removeItem(this.scoreSyncQueueKey);
          return;
        }
        localStorage.setItem(this.scoreSyncQueueKey, JSON.stringify(snapshot));
      } catch (error) {
        console.warn('Unable to persist queued leaderboard sync entries', error);
      }
    }

    cloneScoreSyncEntry(entry) {
      if (!entry || typeof entry !== 'object') {
        return null;
      }
      try {
        return JSON.parse(JSON.stringify(entry));
      } catch (error) {
        console.warn('Unable to clone leaderboard entry for queueing', error);
        return null;
      }
    }

    hasQueuedScoreSyncEntries() {
      return Array.isArray(this.scoreSyncQueue) && this.scoreSyncQueue.length > 0;
    }

    enqueueScoreSyncEntry(entry, options = {}) {
      if (!entry || typeof entry !== 'object') {
        return;
      }
      const cloned = this.cloneScoreSyncEntry(entry);
      if (!cloned) {
        return;
      }
      const reason =
        typeof options.reason === 'string' && options.reason.trim().length ? options.reason.trim() : null;
      const identifier = this.getScoreEntryIdentifier(cloned);
      const queuedAt = Date.now();
      const record = { entry: cloned, reason, identifier, queuedAt };
      if (!Array.isArray(this.scoreSyncQueue)) {
        this.scoreSyncQueue = [];
      }
      if (identifier) {
        const index = this.scoreSyncQueue.findIndex((item) => item?.identifier === identifier);
        if (index >= 0) {
          this.scoreSyncQueue[index] = record;
        } else {
          this.scoreSyncQueue.push(record);
        }
      } else {
        this.scoreSyncQueue.push(record);
      }
      if (this.scoreSyncQueue.length > SCORE_SYNC_QUEUE_LIMIT) {
        this.scoreSyncQueue.splice(0, this.scoreSyncQueue.length - SCORE_SYNC_QUEUE_LIMIT);
      }
      this.persistScoreSyncQueue();
    }

    shiftScoreSyncQueue() {
      if (!Array.isArray(this.scoreSyncQueue) || !this.scoreSyncQueue.length) {
        return null;
      }
      const record = this.scoreSyncQueue.shift();
      this.persistScoreSyncQueue();
      return record;
    }

    peekScoreSyncQueue() {
      if (!Array.isArray(this.scoreSyncQueue) || !this.scoreSyncQueue.length) {
        return null;
      }
      return this.scoreSyncQueue[0];
    }

    showScoreSyncWarning(message) {
      if (!this.scoreSyncWarningEl) {
        return;
      }
      const text =
        typeof message === 'string' && message.trim().length
          ? message.trim()
          : 'Leaderboard offline — runs stored locally until connection returns.';
      if (this.scoreSyncWarningMessageEl) {
        this.scoreSyncWarningMessageEl.textContent = text;
      } else {
        this.scoreSyncWarningEl.textContent = text;
      }
      this.scoreSyncWarningEl.hidden = false;
      this.scoreSyncWarningEl.setAttribute('data-visible', 'true');
    }

    hideScoreSyncWarning(message, options = {}) {
      if (!this.scoreSyncWarningEl) {
        return;
      }
      if (!options.force && this.hasQueuedScoreSyncEntries()) {
        return;
      }
      if (typeof message === 'string' && message.trim().length && this.scoreSyncWarningMessageEl) {
        this.scoreSyncWarningMessageEl.textContent = message.trim();
      }
      this.scoreSyncWarningEl.hidden = true;
      this.scoreSyncWarningEl.removeAttribute('data-visible');
    }

    createRunSummary(reason) {
      const entryId = this.playerGoogleId || this.sessionId;
      const locationLabel = this.playerLocationLabel || 'Location hidden';
      const locationPayload = this.playerLocation
        ? {
            latitude: this.playerLocation.latitude ?? null,
            longitude: this.playerLocation.longitude ?? null,
            accuracy: this.playerLocation.accuracy ?? null,
            label: this.playerLocation.label ?? locationLabel,
          }
        : null;
      const totalDimensions = DIMENSION_THEME.length;
      const unlockedCount = Math.max(1, this.currentDimensionIndex + 1);
      const safeCount = Math.min(unlockedCount, totalDimensions);
      const unlockedDimensions = DIMENSION_THEME.slice(0, safeCount).map((dimension) => {
        const name = typeof dimension?.name === 'string' ? dimension.name.trim() : '';
        if (name.length > 0) {
          return name;
        }
        const label = typeof dimension?.label === 'string' ? dimension.label.trim() : '';
        if (label.length > 0) {
          return label;
        }
        if (typeof dimension?.id === 'string' && dimension.id.trim().length > 0) {
          return dimension.id.trim();
        }
        return 'Unknown Dimension';
      });
      const activeDimensionLabel = (() => {
        const activeName = typeof this.dimensionSettings?.name === 'string' ? this.dimensionSettings.name.trim() : '';
        if (activeName.length > 0) {
          return activeName;
        }
        const activeLabel = typeof this.dimensionSettings?.label === 'string' ? this.dimensionSettings.label.trim() : '';
        if (activeLabel.length > 0) {
          return activeLabel;
        }
        const fallback = unlockedDimensions[unlockedDimensions.length - 1];
        if (typeof fallback === 'string' && fallback.trim().length > 0) {
          return fallback.trim();
        }
        const defaultName = typeof DIMENSION_THEME[0]?.name === 'string' ? DIMENSION_THEME[0].name.trim() : '';
        return defaultName || 'Unknown Dimension';
      })();
      const craftedRecipes = Array.from(this.craftedRecipes ?? []);
      const recipeCount = craftedRecipes.length;
      return {
        id: entryId,
        googleId: this.playerGoogleId ?? null,
        playerId: entryId,
        name: this.playerDisplayName,
        score: Math.round(this.score),
        dimensionCount: safeCount,
        dimensionTotal: totalDimensions,
        dimensionLabel: activeDimensionLabel,
        dimensions: unlockedDimensions,
        runTimeSeconds: Math.round(this.elapsed),
        inventoryCount: Math.max(0, this.getTotalInventoryCount()),
        location: locationPayload,
        locationLabel,
        device: this.deviceLabel,
        updatedAt: new Date().toISOString(),
        reason,
        eternalIngot: Boolean(this.eternalIngotCollected),
        recipeCount,
        recipes: craftedRecipes,
        recipePoints: Number(this.scoreBreakdown?.recipes ?? 0),
        dimensionPoints: Number(this.scoreBreakdown?.dimensions ?? 0),
        penalties: Number(this.scoreBreakdown?.penalties ?? 0),
        portalEvents: this.portalScoreEvents ?? 0,
        portalPoints: Number(this.scoreBreakdown?.portal ?? 0),
        combatEvents: this.combatScoreEvents ?? 0,
        combatPoints: Number(this.scoreBreakdown?.combat ?? 0),
        lootEvents: this.lootScoreEvents ?? 0,
        lootPoints: Number(this.scoreBreakdown?.loot ?? 0),
        craftingEvents: this.craftingScoreEvents ?? recipeCount,
        dimensionEvents: this.dimensionScoreEvents ?? 0,
        breakdown: this.getScoreBreakdownSnapshot(),
      };
    }

    mergeScoreEntries(entries) {
      const utils = this.scoreboardUtils;
      if (utils?.upsertScoreEntry && utils?.normalizeScoreEntries) {
        let next = this.scoreEntries.slice();
        for (const entry of entries) {
          next = utils.upsertScoreEntry(next, entry);
        }
        this.scoreEntries = utils.normalizeScoreEntries(next);
      } else {
        const combined = [...this.scoreEntries, ...entries];
        combined.sort((a, b) => (b.score ?? 0) - (a.score ?? 0));
        this.scoreEntries = combined;
      }
      this.persistScoreboardEntries();
      this.renderScoreboard();
    }

    getScoreEntryIdentifier(entry) {
      if (!entry || typeof entry !== 'object') {
        return null;
      }
      const candidate =
        entry.id ??
        entry.playerId ??
        entry.player_id ??
        entry.googleId ??
        entry.google_id ??
        entry.userId ??
        entry.user_id ??
        null;
      if (candidate === null || candidate === undefined) {
        return null;
      }
      const normalised = String(candidate).trim().toLowerCase();
      return normalised || null;
    }

    getPlayerScoreEntryIds() {
      const ids = [];
      const normalise = (value) => {
        if (value === null || value === undefined) {
          return null;
        }
        const normalised = String(value).trim().toLowerCase();
        return normalised || null;
      };
      const googleId = normalise(this.playerGoogleId);
      const sessionId = normalise(this.sessionId);
      if (googleId) ids.push(googleId);
      if (sessionId) ids.push(sessionId);
      return ids;
    }

    isPlayerScoreEntry(entry) {
      const ids = this.getPlayerScoreEntryIds();
      if (!ids.length) {
        return false;
      }
      const identifier = this.getScoreEntryIdentifier(entry);
      if (!identifier) {
        return false;
      }
      return ids.includes(identifier);
    }

    renderScoreboard() {
      if (!this.scoreboardListEl) return;
      const entries = this.scoreEntries.slice(0, 10);
      const utils = this.scoreboardUtils;
      const formatScore = utils?.formatScoreNumber
        ? utils.formatScoreNumber
        : (value) => Math.round(value ?? 0).toLocaleString();
      const formatRunTime = utils?.formatRunTime
        ? utils.formatRunTime
        : (seconds) => `${Math.round(seconds ?? 0)}s`;
      const formatLocation = utils?.formatLocationLabel
        ? (entry) => utils.formatLocationLabel(entry)
        : (entry) => entry.locationLabel || '—';
      if (!entries.length) {
        this.scoreboardListEl.innerHTML = `
          <tr>
            <td colspan="8" class="leaderboard-empty-row">No runs tracked yet — start exploring!</td>
          </tr>
        `;
        if (this.scoreboardContainer) {
          this.scoreboardContainer.dataset.empty = 'true';
        }
        if (this.scoreboardEmptyEl) {
          this.scoreboardEmptyEl.hidden = false;
        }
        return;
      }
      const rows = entries
        .map((entry, index) => {
          const rank = index + 1;
          const updated = entry.updatedAt
            ? new Date(entry.updatedAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
            : '—';
          let dimensionNames = Array.isArray(entry.dimensions)
            ? entry.dimensions.filter((name) => typeof name === 'string' && name.trim().length > 0)
            : [];
          if (!dimensionNames.length && Array.isArray(entry.dimensionNames)) {
            dimensionNames = entry.dimensionNames.filter(
              (name) => typeof name === 'string' && name.trim().length > 0,
            );
          }
          if (!dimensionNames.length && Array.isArray(entry.dimensionLabels)) {
            dimensionNames = entry.dimensionLabels.filter(
              (name) => typeof name === 'string' && name.trim().length > 0,
            );
          }
          if (
            !dimensionNames.length &&
            typeof entry.dimensionLabel === 'string' &&
            entry.dimensionLabel.trim().length > 0
          ) {
            dimensionNames = [entry.dimensionLabel.trim()];
          }
          const dimensionNameSet = new Set();
          const normalizedDimensionNames = [];
          dimensionNames.forEach((label) => {
            const trimmed = label.trim();
            if (!trimmed || dimensionNameSet.has(trimmed.toLowerCase())) {
              return;
            }
            dimensionNameSet.add(trimmed.toLowerCase());
            normalizedDimensionNames.push(trimmed);
          });
          dimensionNames = normalizedDimensionNames;
          const dimensionTotal = Number.isFinite(entry.dimensionTotal)
            ? Math.max(1, Math.floor(entry.dimensionTotal))
            : DIMENSION_THEME.length;
          const completedDimensions = Number.isFinite(entry.dimensionCount)
            ? Math.max(1, Math.floor(entry.dimensionCount))
            : Math.max(1, dimensionNames.length || 1);
          const boundedCompleted = Math.min(completedDimensions, dimensionTotal);
          const badges = dimensionNames.length
            ? dimensionNames
                .map((label) => {
                  const safeLabel = escapeHtml(label.trim());
                  const symbol = escapeHtml(this.getDimensionBadgeSymbol(label));
                  return `
                    <li class="leaderboard-dimension-badges__item">
                      <span class="leaderboard-dimension-badge">
                        <span class="leaderboard-dimension-badge__icon" aria-hidden="true">${symbol}</span>
                        <span class="leaderboard-dimension-badge__label">${safeLabel}</span>
                      </span>
                    </li>
                  `;
                })
                .join('')
            : `
                <li class="leaderboard-dimension-badges__item leaderboard-dimension-badges__item--empty">
                  <span class="leaderboard-dimension-badge">—</span>
                </li>
              `;
          const isPlayer = this.isPlayerScoreEntry(entry);
          const rowClasses = ['leaderboard-row'];
          if (isPlayer) {
            rowClasses.push('leaderboard-row--player');
          }
          const rowAttributes = isPlayer ? ' data-player="true" aria-current="true"' : '';
          const safeName = escapeHtml(entry.name ?? 'Explorer');
          const explorerLabel = isPlayer
            ? `${safeName} <span class="leaderboard-player-tag" aria-hidden="true">You</span><span class="sr-only"> (Current player)</span>`
            : safeName;
          const scoreDisplay = escapeHtml(formatScore(entry.score));
          const runTimeDisplay = escapeHtml(formatRunTime(entry.runTimeSeconds));
          const dimensionCountDisplay = escapeHtml(String(boundedCompleted));
          const inventoryDisplay = escapeHtml(
            String(Number.isFinite(entry.inventoryCount) ? Math.max(0, Math.round(entry.inventoryCount)) : 0),
          );
          const locationDisplay = escapeHtml(formatLocation(entry));
          const updatedDisplay = escapeHtml(updated);
          return `
            <tr class="${rowClasses.join(' ')}"${rowAttributes}>
              <th scope="row" class="leaderboard-col-rank">${rank}</th>
              <td>${explorerLabel}</td>
              <td>${scoreDisplay}</td>
              <td>${runTimeDisplay}</td>
              <td data-cell="dimensions">
                <span class="leaderboard-dimension-count">${dimensionCountDisplay}</span>
                <ul class="leaderboard-dimension-badges" aria-label="Dimensions unlocked">
                  ${badges}
                </ul>
                <span class="leaderboard-dimension-list sr-only">${escapeHtml(
                  dimensionNames.length ? dimensionNames.join(', ') : 'No additional dimensions tracked',
                )}</span>
              </td>
              <td>${inventoryDisplay}</td>
              <td data-cell="location">${locationDisplay}</td>
              <td data-cell="updated">${updatedDisplay}</td>
            </tr>
          `;
        })
        .join('');
      this.scoreboardListEl.innerHTML = rows;
      if (this.scoreboardContainer) {
        this.scoreboardContainer.dataset.empty = 'false';
      }
      if (this.scoreboardEmptyEl) {
        this.scoreboardEmptyEl.hidden = true;
      }
      if (this.victoryCelebrationActive) {
        this.updateVictoryCelebrationStats();
      }
    }

    getDimensionBadgeSymbol(label) {
      if (!label) {
        return DEFAULT_DIMENSION_BADGE_SYMBOL;
      }
      const raw = String(label).trim();
      if (!raw) {
        return DEFAULT_DIMENSION_BADGE_SYMBOL;
      }
      const lower = raw.toLowerCase();
      const matchedTheme = DIMENSION_THEME.find((dimension) => {
        const id = dimension.id?.toLowerCase();
        const name = dimension.name?.toLowerCase();
        return lower === id || lower === name || lower.includes(id ?? '') || lower.includes(name ?? '');
      });
      if (matchedTheme && this.dimensionBadgeSymbols[matchedTheme.id]) {
        return this.dimensionBadgeSymbols[matchedTheme.id];
      }
      for (const [key, synonyms] of Object.entries(DIMENSION_BADGE_SYNONYMS)) {
        if (synonyms.some((token) => lower.includes(token))) {
          return this.dimensionBadgeSymbols[key] ?? DEFAULT_DIMENSION_BADGE_SYMBOL;
        }
      }
      return DEFAULT_DIMENSION_BADGE_SYMBOL;
    }

    getPlayerLeaderboardRank() {
      const ids = this.getPlayerScoreEntryIds();
      if (!ids.length) {
        return null;
      }
      const index = this.scoreEntries.findIndex((entry) => {
        const identifier = this.getScoreEntryIdentifier(entry);
        return identifier && ids.includes(identifier);
      });
      if (index < 0) {
        return null;
      }
      return index + 1;
    }

    scheduleScoreSync(reason) {
      this.updateLocalScoreEntry(reason);
      if (!this.apiBaseUrl) {
        this.handleLeaderboardOffline(null, {
          source: 'sync',
          reason:
            typeof reason === 'string' && reason.trim().length ? reason.trim() : 'missing-backend',
          forceLocalMode: true,
          message: 'Offline mode: connect an API to sync runs.',
          hint: 'Leaderboard API not configured — runs stored locally until a backend is connected.',
        });
        return;
      }
      this.pendingScoreSyncReason = reason;
      this.flushScoreSync();
    }

    async flushScoreSync(force = false) {
      if (!this.apiBaseUrl || this.scoreSyncInFlight) {
        return;
      }
      const now = typeof performance !== 'undefined' ? performance.now() : Date.now();
      let queueRecord = this.peekScoreSyncQueue();
      let usingQueuedEntry = Boolean(queueRecord);
      if (!usingQueuedEntry && !this.pendingScoreSyncReason) {
        if (!force && now - this.lastScoreSyncAt < this.scoreSyncCooldownSeconds * 1000) {
          return;
        }
      }
      let reason;
      let entry;
      if (usingQueuedEntry && queueRecord && queueRecord.entry) {
        reason =
          typeof queueRecord.reason === 'string' && queueRecord.reason.trim().length
            ? queueRecord.reason.trim()
            : 'queued';
        entry = queueRecord.entry;
      } else {
        reason = this.pendingScoreSyncReason ?? 'auto';
        this.pendingScoreSyncReason = null;
        entry = this.createRunSummary(reason);
        queueRecord = null;
        usingQueuedEntry = false;
      }
      const baseUrl = this.apiBaseUrl.replace(/\/$/, '');
      const url = `${baseUrl}/scores`;
      try {
        this.scoreSyncInFlight = true;
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Accept: 'application/json',
          },
          body: JSON.stringify(entry),
          credentials: 'omit',
        });
        if (!response.ok) {
          const failure = new Error(`Score sync failed with ${response.status}`);
          failure.status = response.status;
          failure.endpoint = url;
          failure.method = 'POST';
          throw failure;
        }
        let payload = null;
        try {
          payload = await response.json();
        } catch (parseError) {
          payload = null;
        }
        const entries = Array.isArray(payload?.items)
          ? payload.items
          : payload && typeof payload === 'object'
            ? [payload]
            : [entry];
        this.mergeScoreEntries(entries);
        this.lastScoreSyncAt = performance.now();
        this.scoreSyncHeartbeat = 0;
        if (usingQueuedEntry) {
          this.shiftScoreSyncQueue();
        }
        const statusMessage = 'Leaderboard synced';
        this.setScoreboardStatus(statusMessage, { offline: false });
        this.clearOfflineSyncNotice('sync', { message: statusMessage });
        this.pendingScoreSyncReason = null;
        if (!this.hasQueuedScoreSyncEntries()) {
          this.hideScoreSyncWarning(statusMessage);
        }
        console.error(
          'Score sync diagnostic — confirm the leaderboard API accepted the update. Inspect the network panel if the leaderboard remains stale.',
          {
            reason,
            score: entry.score,
          },
        );
        if (this.hasQueuedScoreSyncEntries() && this.apiBaseUrl) {
          setTimeout(() => {
            if (!this.scoreSyncInFlight) {
              this.flushScoreSync(true);
            }
          }, 600);
        }
      } catch (error) {
        const statusCode = Number.isFinite(error?.status) ? error.status : null;
        const summary = this.formatBackendEndpointSummary({ method: 'POST', endpoint: url, status: statusCode });
        console.warn('Unable to sync score to backend', {
          error,
          endpoint: url,
          reason,
          status: statusCode,
          summary,
        });
        this.pendingScoreSyncReason = reason;
        if (!usingQueuedEntry) {
          this.enqueueScoreSyncEntry(entry, { reason });
          queueRecord = this.peekScoreSyncQueue();
        } else if (queueRecord) {
          queueRecord.reason = reason;
          queueRecord.queuedAt = Date.now();
          this.persistScoreSyncQueue();
        }
        this.handleLeaderboardOffline(error, {
          source: 'sync',
          reason,
          message:
            summary && summary.length
              ? `Sync failed — run saved locally. Will retry shortly. (${summary})`
              : 'Sync failed — run saved locally. Will retry shortly.',
          hint:
            summary && summary.length
              ? `Leaderboard unreachable (${summary}). We will retry automatically.`
              : 'Leaderboard offline — progress saved locally. We will retry automatically.',
          endpoint: url,
          method: 'POST',
          status: statusCode ?? undefined,
        });
      } finally {
        this.scoreSyncInFlight = false;
      }
    }

    stop() {
      this.setHudInteractionState(false);
      this.cancelQueuedModelPreload();
      this.cancelAllAssetDelayWarnings();
      this.cancelNavigationMeshMaintenance();
      if (this.animationFrame !== null) {
        cancelAnimationFrame(this.animationFrame);
        this.animationFrame = null;
      }
      this.unbindEvents();
      this.hidePointerHint(true);
      this.clearVictoryEffectTimers();
      this.hideVictoryCelebration(true);
      this.hideVictoryBanner();
      this.victoryShareBusy = false;
      this.activeSessionId = 0;
      this.resetPlayerCharacterState();
      this.started = false;
    }

    resetPlayerCharacterState() {
      if (this.playerAnimationRig) {
        this.disposeAnimationRig(this.playerAnimationRig);
        this.playerAnimationRig = null;
      } else if (this.playerMixer) {
        try {
          this.playerMixer.stopAllAction();
          if (this.playerAvatar && typeof this.playerMixer.uncacheRoot === 'function') {
            this.playerMixer.uncacheRoot(this.playerAvatar);
          }
        } catch (error) {
          console.debug('Unable to stop player mixer cleanly.', error);
        }
      }
      this.playerMixer = null;
      this.playerIdleAction = null;
      this.playerAvatarLoaded = false;

      this.cameraPerspective = 'first';
      this.playerHeadAttachment = null;
      if (this.camera && this.camera.parent && typeof this.camera.parent.remove === 'function') {
        try {
          this.camera.parent.remove(this.camera);
        } catch (error) {
          console.debug('Failed to detach camera from previous parent.', error);
        }
      }
      const cameraHolder = this.cameraBoom && typeof this.cameraBoom.add === 'function' ? this.cameraBoom : this.playerRig;
      if (cameraHolder && this.camera && typeof cameraHolder.add === 'function') {
        try {
          cameraHolder.add(this.camera);
          this.camera.position.set(0, 0, 0);
        } catch (error) {
          console.debug('Unable to reset camera rig state.', error);
        }
      }

      if (this.playerAvatar) {
        if (this.playerRig && typeof this.playerRig.remove === 'function') {
          this.playerRig.remove(this.playerAvatar);
        }
        disposeObject3D(this.playerAvatar);
        this.playerAvatar = null;
      }

      if (this.handGroup) {
        if (this.handGroup.parent && typeof this.handGroup.parent.remove === 'function') {
          this.handGroup.parent.remove(this.handGroup);
        }
        if (typeof this.handGroup.clear === 'function') {
          this.handGroup.clear();
        }
        this.handGroup.visible = true;
        this.handGroup = null;
      }

      this.handMaterials = [];
      this.handMaterialsDynamic = true;
      this.handModelLoaded = false;
      this.lastCullingCameraValid = false;
    }

    setupScene() {
      const THREE = this.THREE;
      const width = this.canvas.clientWidth || this.canvas.width || 1;
      const height = this.canvas.clientHeight || this.canvas.height || 1;
      const aspect = width / Math.max(1, height);

      let renderer;
      try {
        renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
      } catch (error) {
        const errorMessage =
          typeof error?.message === 'string' && error.message.trim().length
            ? error.message.trim()
            : 'Failed to initialise Three.js renderer.';
        this.emitGameEvent('initialisation-error', {
          stage: 'renderer',
          message: 'Failed to initialise Three.js renderer.',
          errorMessage,
          errorName: typeof error?.name === 'string' && error.name.trim().length ? error.name.trim() : undefined,
          stack: typeof error?.stack === 'string' && error.stack.trim().length ? error.stack.trim() : undefined,
        });
        console.error('Failed to initialise Three.js renderer.', error);
        if (error && error.stack) {
          console.error('Renderer initialisation stack trace:', error.stack);
        }
        this.renderer = null;
        throw error;
      }

      this.renderer = renderer;
      this.renderer.outputColorSpace = THREE.SRGBColorSpace;
      this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
      this.renderer.toneMappingExposure = 1.05;
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      this.renderer.setPixelRatio(window.devicePixelRatio ?? 1);
      this.renderer.setSize(width, height, false);
      this.applyTextureAnisotropy();
      this.bindWebglContextEvents();

      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color('#87ceeb');
      this.scene.fog = new THREE.Fog(0x87ceeb, 40, 140);

      this.worldRoot = new THREE.Group();
      this.worldRoot.name = 'WorldRoot';
      this.scene.add(this.worldRoot);

      const fov = this.cameraFieldOfView ?? 60;
      this.camera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 250);
      this.camera.position.set(0, 0, 0);

      this.playerRig = new THREE.Group();
      this.playerRig.name = 'PlayerRig';
      this.playerRig.position.set(0, PLAYER_EYE_HEIGHT, 0);
      this.cameraBoom = new THREE.Object3D();
      this.cameraBoom.name = 'PlayerCameraBoom';
      this.playerRig.add(this.cameraBoom);
      this.cameraBoom.add(this.camera);
      this.scene.add(this.playerRig);
      this.ensurePlayerPhysicsBody();
      this.camera.position.set(0, 0, 0);
      this.updateCameraFrustum(width, height);

      this.ensurePrimaryLights();
      this.applyPendingLightingFallback();

      this.terrainGroup = new THREE.Group();
      this.railsGroup = new THREE.Group();
      this.portalGroup = new THREE.Group();
      this.zombieGroup = new THREE.Group();
      this.golemGroup = new THREE.Group();
      this.chestGroup = new THREE.Group();
      this.challengeGroup = new THREE.Group();
      this.worldRoot.add(this.terrainGroup);
      this.worldRoot.add(this.railsGroup);
      this.worldRoot.add(this.portalGroup);
      this.worldRoot.add(this.zombieGroup);
      this.worldRoot.add(this.golemGroup);
      this.worldRoot.add(this.chestGroup);
      this.worldRoot.add(this.challengeGroup);
      this.createFirstPersonHands();
      this.playerAvatarLoaded = false;
      this.loadPlayerCharacter()
        .then((loaded) => {
          this.playerAvatarLoaded = loaded === true;
          if (!loaded && typeof console !== 'undefined' && typeof console.warn === 'function') {
            console.warn('Steve GLTF model unavailable at spawn — placeholder rig active.');
          }
        })
        .catch((error) => {
          console.error('Player model failed to load; continuing with primitive hands.', error);
          this.playerAvatarLoaded = false;
          this.ensurePlayerAvatarPlaceholder('failed');
          this.primePlayerLocomotionAnimations();
        });
      this.refreshCameraBaseOffset();
      if (typeof console !== 'undefined') {
        console.info(
          'Scene population check fired — validate terrain, rails, portals, mobs, and chests render correctly. Re-run asset bootstrap if visuals are missing.',
        );
      }
    }

    updateCameraFrustum(width, height) {
      if (!this.camera || typeof width !== 'number' || typeof height !== 'number') {
        return;
      }
      const safeWidth = Math.max(1, width);
      const safeHeight = Math.max(1, height);
      if (this.camera.isPerspectiveCamera) {
        this.camera.aspect = safeWidth / safeHeight;
        this.camera.updateProjectionMatrix();
        return;
      }
      if (this.camera.isOrthographicCamera) {
        const aspect = safeWidth / safeHeight;
        const frustumHeight = this.cameraFrustumHeight ?? 6;
        const frustumWidth = frustumHeight * aspect;
        this.camera.left = -frustumWidth / 2;
        this.camera.right = frustumWidth / 2;
        this.camera.top = frustumHeight / 2;
        this.camera.bottom = -frustumHeight / 2;
        this.camera.updateProjectionMatrix();
      }
    }

    refreshCameraBaseOffset() {
      if (!this.camera || !this.cameraBaseOffset) {
        return;
      }
      this.cameraBaseOffset.copy(this.camera.position);
    }

    applyCameraPerspective(mode) {
      const perspective = mode === 'third' ? 'third' : 'first';
      this.cameraPerspective = perspective;
      if (!this.camera) {
        return;
      }
      const desiredParent =
        perspective === 'first'
          ? (this.playerHeadAttachment && this.playerHeadAttachment.isObject3D
              ? this.playerHeadAttachment
              : this.cameraBoom || this.playerRig || this.scene)
          : this.cameraBoom || this.playerRig || this.scene;
      if (desiredParent && this.camera.parent !== desiredParent && typeof desiredParent.add === 'function') {
        try {
          this.camera.parent?.remove?.(this.camera);
        } catch (error) {
          console.debug('Unable to detach camera from previous parent.', error);
        }
        try {
          desiredParent.add(this.camera);
        } catch (error) {
          console.debug('Unable to reparent camera for perspective change.', error);
        }
      }
      if (perspective === 'third') {
        if (this.thirdPersonCameraOffset) {
          this.camera.position.copy(this.thirdPersonCameraOffset);
        }
      } else if (this.firstPersonCameraOffset) {
        this.camera.position.copy(this.firstPersonCameraOffset);
      }
      this.refreshCameraBaseOffset();
      this.ensurePlayerArmsVisible();
    }

    toggleCameraPerspective() {
      const next = this.cameraPerspective === 'first' ? 'third' : 'first';
      this.applyCameraPerspective(next);
      const message = next === 'first' ? 'First-person view enabled.' : 'Third-person view enabled.';
      this.showHint(message);
    }

    toggleDeveloperLogOverlay(source = 'experience-hotkey') {
      const scope =
        (typeof window !== 'undefined' && window) ||
        (typeof globalThis !== 'undefined' && globalThis) ||
        null;
      const api = scope?.InfiniteRails?.developerStats || null;
      if (api && typeof api.toggle === 'function') {
        try {
          const toggled = api.toggle({ source: source ?? 'experience-hotkey' });
          let enabledState = null;
          if (typeof toggled === 'boolean') {
            enabledState = toggled;
          } else if (typeof api.isEnabled === 'function') {
            try {
              enabledState = Boolean(api.isEnabled());
            } catch (readError) {
              enabledState = null;
            }
          }
          if (enabledState !== null) {
            this.reportDeveloperOverlayState(enabledState, source);
          }
          return true;
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Developer log overlay toggle failed.', error);
          }
        }
      }
      if (!this.developerOverlayWarningIssued && typeof console !== 'undefined') {
        if (typeof console.warn === 'function') {
          console.warn(
            'Developer stats overlay unavailable — ensure the HUD bootstrap completes before using the hotkey.',
          );
        }
        this.developerOverlayWarningIssued = true;
      }
      return false;
    }

    reportDeveloperOverlayState(enabled, source = 'experience-hotkey') {
      const origin = typeof source === 'string' && source.trim() ? source.trim() : 'experience-hotkey';
      const detail = { source: origin, enabled: Boolean(enabled) };
      const showHint = typeof this.showHint === 'function' ? this.showHint.bind(this) : null;
      if (!enabled) {
        if (showHint) {
          showHint('Developer stats overlay hidden.');
        }
        if (typeof notifyLiveDiagnostics === 'function') {
          notifyLiveDiagnostics('hotkey', 'Developer stats overlay hidden.', detail, { level: 'info' });
        }
        if (typeof console !== 'undefined' && typeof console.info === 'function') {
          console.info('Developer stats overlay hidden.', detail);
        }
        return;
      }

      let metrics = null;
      if (typeof this.getDeveloperMetrics === 'function') {
        try {
          metrics = this.getDeveloperMetrics();
        } catch (error) {
          metrics = null;
        }
      }

      const normalisedMetrics = {
        fps: null,
        pendingAssets: null,
        missingAssets: null,
        scene: {
          sceneChildren: null,
          worldChildren: null,
          terrainMeshes: null,
          actorCount: null,
        },
      };

      if (metrics && typeof metrics === 'object') {
        if (Number.isFinite(metrics.fps) && metrics.fps > 0) {
          normalisedMetrics.fps = metrics.fps;
        }
        const assets = metrics.assets && typeof metrics.assets === 'object' ? metrics.assets : null;
        if (assets) {
          if (Number.isFinite(assets.pending)) {
            normalisedMetrics.pendingAssets = Math.max(0, assets.pending);
          }
          if (Number.isFinite(assets.failures)) {
            normalisedMetrics.missingAssets = Math.max(0, assets.failures);
          }
        }
        const scene = metrics.scene && typeof metrics.scene === 'object' ? metrics.scene : null;
        if (scene) {
          if (Number.isFinite(scene.sceneChildren)) {
            normalisedMetrics.scene.sceneChildren = Math.max(0, scene.sceneChildren);
          }
          if (Number.isFinite(scene.worldChildren)) {
            normalisedMetrics.scene.worldChildren = Math.max(0, scene.worldChildren);
          }
          if (Number.isFinite(scene.terrainMeshes)) {
            normalisedMetrics.scene.terrainMeshes = Math.max(0, scene.terrainMeshes);
          }
          if (Number.isFinite(scene.actorCount)) {
            normalisedMetrics.scene.actorCount = Math.max(0, scene.actorCount);
          }
        }
      }

      const summaryParts = [];
      if (normalisedMetrics.fps !== null) {
        const fpsValue = normalisedMetrics.fps;
        const fpsLabel = fpsValue >= 100 ? Math.round(fpsValue).toString() : fpsValue.toFixed(1);
        summaryParts.push(`FPS ${fpsLabel}`);
      } else {
        summaryParts.push('FPS —');
      }
      if (normalisedMetrics.pendingAssets !== null) {
        summaryParts.push(`pending assets ${normalisedMetrics.pendingAssets}`);
      } else {
        summaryParts.push('pending assets —');
      }
      if (normalisedMetrics.missingAssets !== null) {
        summaryParts.push(`missing assets ${normalisedMetrics.missingAssets}`);
      } else {
        summaryParts.push('missing assets —');
      }
      const sceneParts = [];
      const sceneMetrics = normalisedMetrics.scene;
      const sceneChildLabel =
        sceneMetrics.sceneChildren !== null ? sceneMetrics.sceneChildren.toLocaleString(undefined) : '—';
      const worldChildLabel =
        sceneMetrics.worldChildren !== null ? sceneMetrics.worldChildren.toLocaleString(undefined) : '—';
      if (sceneMetrics.sceneChildren !== null || sceneMetrics.worldChildren !== null) {
        sceneParts.push(`${sceneChildLabel} scene / ${worldChildLabel} world`);
      }
      if (sceneMetrics.terrainMeshes !== null) {
        sceneParts.push(`${sceneMetrics.terrainMeshes.toLocaleString(undefined)} terrain`);
      }
      if (sceneMetrics.actorCount !== null) {
        sceneParts.push(`${sceneMetrics.actorCount.toLocaleString(undefined)} actors`);
      }
      if (!sceneParts.length) {
        sceneParts.push('—');
      }
      summaryParts.push(`scene ${sceneParts.join(' · ')}`);
      const summary = summaryParts.join(' | ');

      detail.metrics = { ...normalisedMetrics, summary };
      const message = `Developer stats overlay enabled — ${summary}.`;

      if (showHint) {
        showHint('Developer stats overlay enabled.');
      }
      if (typeof notifyLiveDiagnostics === 'function') {
        notifyLiveDiagnostics('hotkey', message, detail, { level: 'info' });
      }
      if (typeof console !== 'undefined' && typeof console.info === 'function') {
        console.info(message, detail.metrics);
      }
    }

    ensurePlayerArmsVisible() {
      if (this.playerAvatar) {
        this.playerAvatar.visible = true;
        if (typeof this.playerAvatar.traverse === 'function') {
          this.playerAvatar.traverse((child) => {
            if (child && child.visible === false) {
              child.visible = true;
            }
          });
        }
      }
      if (!this.handGroup) {
        return;
      }
      const shouldShowHands = this.cameraPerspective === 'first';
      if (shouldShowHands && this.camera && this.handGroup.parent !== this.camera) {
        try {
          this.handGroup.parent?.remove?.(this.handGroup);
        } catch (error) {
          console.debug('Unable to detach hand group from previous parent.', error);
        }
        try {
          this.camera.add(this.handGroup);
        } catch (error) {
          console.debug('Unable to attach hand group to camera.', error);
        }
      }
      this.handGroup.visible = shouldShowHands;
    }

    getHighResTimestamp() {
      if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
        return performance.now();
      }
      return Date.now();
    }

    beginAssetTimer(kind, key) {
      if (!kind || !key) {
        return;
      }
      const timers = this.assetLoadTimers?.[kind];
      if (!timers || timers.has(key)) {
        return;
      }
      timers.set(key, this.getHighResTimestamp());
      this.emitGameEvent('asset-fetch-start', { kind, key });
      this.scheduleAssetDelayWarning(kind, key);
    }

    completeAssetTimer(kind, key, details = {}) {
      if (!kind || !key) {
        return;
      }
      const timers = this.assetLoadTimers?.[kind];
      if (!timers || !timers.has(key)) {
        return;
      }
      const startedAt = timers.get(key);
      timers.delete(key);
      const duration = Math.max(0, this.getHighResTimestamp() - startedAt);
      const entry = {
        kind,
        key,
        duration,
        status: details.success ? 'fulfilled' : 'failed',
        url: details.url ?? null,
        timestamp: Date.now(),
      };
      this.assetLoadLog.push(entry);
      if (this.assetLoadLog.length > 40) {
        this.assetLoadLog.splice(0, this.assetLoadLog.length - 40);
      }
      this.emitGameEvent('asset-fetch-complete', entry);
      this.cancelAssetDelayWarning(kind, key);
      this.clearAssetDelayNoticesForKey(key);
      const budget = Number.isFinite(this.assetLoadBudgetMs) ? this.assetLoadBudgetMs : 3000;
      const formattedDuration = duration.toFixed(0);
      const sourceLabel = details.url ? ` from ${details.url}` : '';
      const runningFromFile =
        typeof this.isRunningFromFileProtocol === 'function' && this.isRunningFromFileProtocol();
      if (details.success) {
        if (duration > budget && !runningFromFile) {
          console.warn(
            `[AssetBudget] ${kind}:${key} ready in ${formattedDuration}ms (exceeds ${budget}ms budget)${sourceLabel}.`,
          );
        } else {
          const label =
            duration > budget && runningFromFile
              ? `[AssetBudget] ${kind}:${key} ready in ${formattedDuration}ms (file protocol relaxed threshold)${sourceLabel}.`
              : `[AssetBudget] ${kind}:${key} ready in ${formattedDuration}ms${sourceLabel}.`;
          console.info(label);
        }
      } else if (!details.silent) {
        const attemptLabel = details.url ? ` (last attempted ${details.url})` : '';
        const scheme = typeof window !== 'undefined' ? window.location?.protocol : null;
        const logFn = scheme === 'file:' ? console.info : console.warn;
        logFn(`[AssetBudget] ${kind}:${key} failed after ${formattedDuration}ms${attemptLabel}.`);
      }
    }

    scheduleAssetDelayWarning(kind, key) {
      if (!kind || !key) {
        return;
      }
      const handles = this.assetDelayHandles?.[kind];
      if (!handles || handles.has(key)) {
        return;
      }
      const budget = Number.isFinite(this.assetDelayIndicatorThresholdMs)
        ? Math.max(1000, this.assetDelayIndicatorThresholdMs)
        : 1000;
      const scope =
        typeof window !== 'undefined'
          ? window
          : typeof globalThis !== 'undefined'
            ? globalThis
            : null;
      const setTimer = typeof scope?.setTimeout === 'function' ? scope.setTimeout.bind(scope) : setTimeout;
      const handle = setTimer(() => {
        handles.delete(key);
        this.handleAssetLoadDelay(kind, key);
      }, budget);
      handles.set(key, handle);
    }

    cancelAssetDelayWarning(kind, key) {
      if (!kind || !key) {
        return;
      }
      const handles = this.assetDelayHandles?.[kind];
      if (!handles || !handles.has(key)) {
        return;
      }
      const handle = handles.get(key);
      handles.delete(key);
      const scope =
        typeof window !== 'undefined'
          ? window
          : typeof globalThis !== 'undefined'
            ? globalThis
            : null;
      const clearTimer = typeof scope?.clearTimeout === 'function' ? scope.clearTimeout.bind(scope) : clearTimeout;
      try {
        clearTimer(handle);
      } catch (error) {
        if (typeof console !== 'undefined' && typeof console.debug === 'function') {
          console.debug('Failed to cancel asset delay timer cleanly.', { kind, key, error });
        }
      }
    }

    cancelAllAssetDelayWarnings() {
      const scope =
        typeof window !== 'undefined'
          ? window
          : typeof globalThis !== 'undefined'
            ? globalThis
            : null;
      const clearTimer = typeof scope?.clearTimeout === 'function' ? scope.clearTimeout.bind(scope) : clearTimeout;
      if (!this.assetDelayHandles) {
        return;
      }
      Object.values(this.assetDelayHandles).forEach((handles) => {
        if (!handles) {
          return;
        }
        handles.forEach((handle, key) => {
          try {
            clearTimer(handle);
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Failed to cancel asset delay timer during teardown.', { key, error });
            }
          }
        });
        handles.clear();
      });
      if (this.assetDelayNotices && typeof this.assetDelayNotices.clear === 'function') {
        this.assetDelayNotices.clear();
      }
    }

    handleAssetLoadDelay(kind, key) {
      if (!key) {
        return;
      }
      if (kind === 'models') {
        if (key === 'steve') {
          this.ensurePlayerAvatarPlaceholder('loading');
        } else if (key === 'arm') {
          this.ensurePlayerArmsVisible();
        }
      }
      const indicator = this.buildAssetDelayIndicator(key, {
        kind: kind || 'asset',
        delayMs: this.assetDelayIndicatorThresholdMs,
      });
      const messageMap = {
        arm: 'Loading the first-person hands — simplified overlay active until streaming completes.',
        steve: 'Loading the explorer avatar — placeholder rig active until streaming completes.',
        zombie: 'Loading the zombie models — husk stand-ins deployed until streaming completes.',
        golem: 'Loading the golem armour — placeholder guardian active until streaming completes.',
      };
      const fallbackMessage = messageMap[key] || indicator.hint || 'Loading critical assets — placeholder visuals active.';
      indicator.message = fallbackMessage;
      indicator.hint = fallbackMessage;
      this.announceAssetStreamIssue(key, fallbackMessage, {
        kind: 'delay',
        variant: 'warning',
        indicator,
        assetKind: kind || 'asset',
      });
    }

    announceAssetStreamIssue(key, message, options = {}) {
      const text = typeof message === 'string' ? message.trim() : '';
      if (!text) {
        return;
      }
      const kind = options.kind || 'delay';
      const assetKind = options.assetKind || null;
      const indicatorOptions = options.indicator || null;
      const normalisedKey = typeof key === 'string' && key.trim().length ? key.trim() : 'asset';
      const dedupeKey = `${kind}:${normalisedKey}|${text}`;
      if (this.assetDelayNotices?.has(dedupeKey)) {
        return;
      }
      this.assetDelayNotices?.add(dedupeKey);
      const variant = options.variant || 'warning';
      if (this.playerHintEl) {
        this.playerHintEl.textContent = text;
        this.playerHintEl.classList.add('visible');
        this.playerHintEl.setAttribute('data-variant', variant);
      }
      this.lastHintMessage = text;
      if (this.footerStatusEl) {
        this.footerStatusEl.textContent = text;
      }
      if (this.footerEl) {
        this.footerEl.dataset.state = variant === 'critical' ? 'error' : 'warning';
      }
      this.updateFooterSummary();
      this.emitGameEvent('asset-delay-warning', {
        key: normalisedKey,
        originalKey: typeof key === 'string' ? key : null,
        kind,
        assetKind,
        message: text,
        variant,
        indicator: indicatorOptions
          ? {
              label: indicatorOptions.label || null,
              title: indicatorOptions.title || null,
              message: indicatorOptions.message || text,
              delayMs: indicatorOptions.delayMs ?? null,
            }
          : undefined,
      });
      if (indicatorOptions) {
        const baseLabel =
          indicatorOptions.label || this.describeAssetKey(normalisedKey) || `${normalisedKey} assets`;
        const capitalisedLabel = baseLabel.charAt(0).toUpperCase() + baseLabel.slice(1);
        const indicatorDetail = {
          key: normalisedKey,
          originalKey: typeof key === 'string' ? key : null,
          kind: indicatorOptions.assetKind || assetKind || 'asset',
          noticeKind: kind,
          label: baseLabel,
          title: indicatorOptions.title || `Loading ${capitalisedLabel}`,
          message: indicatorOptions.message || text,
          delayMs: Number.isFinite(indicatorOptions.delayMs)
            ? Math.max(0, indicatorOptions.delayMs)
            : this.assetDelayIndicatorThresholdMs,
        };
        this.emitGameEvent('asset-load-delay-indicator', indicatorDetail);
      }
    }

    clearAssetDelayNoticesForKey(key) {
      if (!this.assetDelayNotices) {
        return;
      }
      const normalisedKey = typeof key === 'string' && key.trim().length ? key.trim() : 'asset';
      const prefix = `delay:${normalisedKey}|`;
      Array.from(this.assetDelayNotices).forEach((entry) => {
        if (entry.startsWith(prefix)) {
          this.assetDelayNotices.delete(entry);
        }
      });
    }

    getAssetLoadLog(limit = 20) {
      const size = Math.max(1, Math.floor(limit));
      if (!this.assetLoadLog?.length) {
        return [];
      }
      return this.assetLoadLog.slice(-size);
    }

    handlePortalShaderInitialisationFailure(error) {
      const wasFallbackActive = this.portalShaderFallbackActive === true;
      this.portalShaderFallbackActive = true;
      this.lightingFallbackPending = true;
      const consoleRef = typeof console !== 'undefined' ? console : null;
      const warningMessage =
        'Portal shader initialisation failed; falling back to a standard material and default lighting.';
      if (consoleRef?.warn) {
        consoleRef.warn(warningMessage, error);
      } else if (consoleRef?.error) {
        consoleRef.error(warningMessage, error);
      }
      const fallbackAnnouncement = PORTAL_SHADER_FALLBACK_ANNOUNCEMENT;
      if (typeof this.showHint === 'function') {
        this.showHint(fallbackAnnouncement);
      }
      this.lastHintMessage = fallbackAnnouncement;
      if (!Array.isArray(this.portalIgnitionLog)) {
        this.portalIgnitionLog = [];
      }
      if (this.portalIgnitionLog[0] !== fallbackAnnouncement) {
        this.portalIgnitionLog.unshift(fallbackAnnouncement);
      }
      this.portalIgnitionLog = this.portalIgnitionLog.filter(Boolean).slice(0, 6);
      if (typeof this.updatePortalProgress === 'function') {
        this.updatePortalProgress();
      }
      if (!wasFallbackActive && typeof this.updateFooterSummary === 'function') {
        this.updateFooterSummary();
      }
      const errorMessage =
        typeof error?.message === 'string' && error.message.trim().length ? error.message.trim() : undefined;
      this.emitGameEvent('shader-fallback', {
        shader: 'portal',
        reason: 'initialisation-error',
        errorMessage,
        fallbackActive: true,
        announcement: fallbackAnnouncement,
      });
    }

    applyPendingLightingFallback() {
      if (!this.lightingFallbackPending || this.lightingFallbackActive) {
        return;
      }
      this.ensurePrimaryLights();
      const consoleRef = typeof console !== 'undefined' ? console : null;
      if (consoleRef?.info) {
        consoleRef.info('Activating simplified lighting fallback to preserve scene visibility.');
      }
      if (this.ambientLight) {
        this.ambientLight.intensity = Math.max(0.35, this.ambientLight.intensity || 0);
        if (typeof this.ambientLight.color?.set === 'function') {
          this.ambientLight.color.set('#cfd8dc');
        } else if (this.THREE?.Color) {
          this.ambientLight.color = new this.THREE.Color('#cfd8dc');
        }
      }
      if (this.hemiLight) {
        this.hemiLight.intensity = Math.max(0.65, this.hemiLight.intensity || 0);
      }
      if (this.sunLight) {
        this.sunLight.intensity = Math.max(0.85, this.sunLight.intensity || 0);
      }
      this.lightingFallbackActive = true;
      this.lightingFallbackPending = false;
      this.emitGameEvent('lighting-fallback-applied', { reason: 'shader-failure' });
    }

    ensurePrimaryLights() {
      const THREE = this.THREE;
      if (!THREE) {
        return;
      }
      const root = this.worldRoot || this.scene;
      if (!root || typeof root.add !== 'function') {
        return;
      }

      if (!this.hemiLight) {
        this.hemiLight = new THREE.HemisphereLight(0xbddcff, 0x34502d, 0.9);
        this.hemiLight.name = 'SkyLight';
      }
      if (!this.hemiLight.parent) {
        root.add(this.hemiLight);
      }

      if (!this.sunLight) {
        this.sunLight = new THREE.DirectionalLight(0xffffff, 1.1);
        this.sunLight.name = 'SunLight';
        this.sunLight.castShadow = true;
      }
      this.sunLight.position.set(18, 32, 12);
      this.sunLight.shadow.mapSize.set(2048, 2048);
      this.sunLight.shadow.camera.near = 0.5;
      this.sunLight.shadow.camera.far = 160;
      this.sunLight.shadow.camera.left = -60;
      this.sunLight.shadow.camera.right = 60;
      this.sunLight.shadow.camera.top = 60;
      this.sunLight.shadow.camera.bottom = -60;
      if (!this.sunLight.parent) {
        root.add(this.sunLight);
      }
      if (this.sunLight.target && this.sunLight.target.parent !== root) {
        this.sunLight.target.position.set(0, 0, 0);
        root.add(this.sunLight.target);
      }

      if (!this.moonLight) {
        this.moonLight = new THREE.DirectionalLight(0x8ea2ff, 0.4);
        this.moonLight.name = 'MoonLight';
        this.moonLight.castShadow = false;
      }
      this.moonLight.position.set(-32, 18, -20);
      if (!this.moonLight.parent) {
        root.add(this.moonLight);
      }
      if (this.moonLight.target && this.moonLight.target.parent !== root) {
        this.moonLight.target.position.set(0, 0, 0);
        root.add(this.moonLight.target);
      }

      if (!this.ambientLight) {
        this.ambientLight = new THREE.AmbientLight(0xffffff, 0.18);
        this.ambientLight.name = 'AmbientFillLight';
      }
      if (!this.ambientLight.parent) {
        root.add(this.ambientLight);
      }
    }

    createMaterials() {
      const THREE = this.THREE;
      const grassTexture = this.createVoxelTexture('grass', {
        base: '#69c368',
        highlight: '#92dd83',
        shadow: '#3f8f3a',
        accent: '#7dcf6f',
      });
      const dirtTexture = this.createVoxelTexture('dirt', {
        base: '#a66a33',
        highlight: '#c28145',
        shadow: '#7b4a26',
        accent: '#b5773a',
      });
      const stoneTexture = this.createVoxelTexture('stone', {
        base: '#8f8f8f',
        highlight: '#b8babd',
        shadow: '#5b5f63',
        accent: '#a5a5a5',
      });
      const materials = {
        grass: new THREE.MeshLambertMaterial({
          map: grassTexture,
          color: new THREE.Color('#ffffff'),
        }),
        dirt: new THREE.MeshLambertMaterial({
          map: dirtTexture,
          color: new THREE.Color('#ffffff'),
        }),
        stone: new THREE.MeshLambertMaterial({
          map: stoneTexture,
          color: new THREE.Color('#ffffff'),
        }),
        rails: new THREE.MeshLambertMaterial({
          color: new THREE.Color('#c9a14d'),
        }),
        zombie: new THREE.MeshStandardMaterial({
          color: new THREE.Color('#2e7d32'),
          roughness: 0.8,
          metalness: 0.1,
        }),
        portal: (() => {
          try {
            return new THREE.ShaderMaterial({
              transparent: true,
              depthWrite: false,
              uniforms: {
                uTime: { value: 0 },
                uColorA: { value: new THREE.Color('#7f5af0') },
                uColorB: { value: new THREE.Color('#2cb67d') },
              },
              vertexShader: `
                varying vec2 vUv;
                void main() {
                  vUv = uv;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform float uTime;
                uniform vec3 uColorA;
                uniform vec3 uColorB;
                varying vec2 vUv;
                void main() {
                  float swirl = sin((vUv.x + vUv.y + uTime * 0.7) * 6.2831) * 0.5 + 0.5;
                  float vignette = smoothstep(0.95, 0.35, distance(vUv, vec2(0.5)));
                  vec3 color = mix(uColorA, uColorB, swirl) * vignette;
                  gl_FragColor = vec4(color, vignette);
                }
              `,
            });
          } catch (error) {
            this.handlePortalShaderInitialisationFailure(error);
            return new THREE.MeshStandardMaterial({
              color: new THREE.Color('#7f5af0'),
              emissive: new THREE.Color('#2cb67d'),
              emissiveIntensity: 0.65,
              roughness: 0.35,
              metalness: 0.55,
              transparent: true,
              opacity: 0.85,
            });
          }
        })(),
        portalInvalid: new THREE.MeshStandardMaterial({
          color: new THREE.Color('#ff4d4f'),
          emissive: new THREE.Color('#ff8a80'),
          emissiveIntensity: 0.35,
          roughness: 0.6,
          metalness: 0.1,
        }),
      };
      this.queueExternalTextureUpgrade('grass', materials.grass);
      this.queueExternalTextureUpgrade('dirt', materials.dirt);
      this.queueExternalTextureUpgrade('stone', materials.stone);
      return materials;
    }

    createCraftingRecipes() {
      return new Map([
        [
          'stick,stick,stone',
          {
            id: 'stone-pickaxe',
            label: 'Stone Pickaxe',
            score: 2,
            description: 'Unlocks tougher mining strikes and portal prep.',
            sequence: ['stick', 'stick', 'stone'],
          },
        ],
        [
          'stone,stone,grass-block',
          {
            id: 'portal-charge',
            label: 'Portal Charge',
            score: 4,
            description: 'Stabilises the next realm transition.',
            sequence: ['stone', 'stone', 'grass-block'],
          },
        ],
      ]);
    }

    restorePersistentUnlocks() {
      if (typeof localStorage === 'undefined') {
        return;
      }
      let payload = null;
      try {
        const raw = localStorage.getItem(RECIPE_UNLOCK_STORAGE_KEY);
        if (!raw) {
          return;
        }
        payload = JSON.parse(raw);
      } catch (error) {
        console.warn('Failed to parse stored recipe unlocks', error);
        return;
      }
      const sequences = Array.isArray(payload?.sequences) ? payload.sequences : [];
      const craftedIds = Array.isArray(payload?.craftedIds) ? payload.craftedIds : [];
      sequences.forEach((key) => {
        if (typeof key !== 'string' || !key) return;
        const recipe = this.craftingRecipes.get(key);
        if (recipe) {
          this.craftingState.unlocked.set(key, recipe);
        }
      });
      craftedIds.forEach((id) => {
        if (typeof id !== 'string' || !id) return;
        this.craftedRecipes.add(id);
      });
    }

    savePersistentUnlocks() {
      if (typeof localStorage === 'undefined') {
        return;
      }
      try {
        const data = {
          sequences: Array.from(this.craftingState.unlocked.keys()),
          craftedIds: Array.from(this.craftedRecipes.values()),
        };
        localStorage.setItem(RECIPE_UNLOCK_STORAGE_KEY, JSON.stringify(data));
      } catch (error) {
        console.warn('Failed to persist recipe unlocks', error);
      }
    }

    restoreIdentitySnapshot() {
      if (typeof localStorage === 'undefined') {
        return;
      }
      this.identityHydrating = true;
      try {
        const raw = localStorage.getItem(this.identityStorageKey);
        if (!raw) {
          return;
        }
        let payload = null;
        try {
          payload = JSON.parse(raw);
        } catch (error) {
          console.warn('Failed to parse stored identity snapshot', error);
          return;
        }
        if (!payload || typeof payload !== 'object') {
          return;
        }
        if (typeof payload.displayName === 'string' && payload.displayName.trim().length > 0) {
          this.playerDisplayName = payload.displayName.trim();
          this.defaultPlayerName = this.playerDisplayName;
        }
        if (typeof payload.googleId === 'string' && payload.googleId.trim().length > 0) {
          this.playerGoogleId = payload.googleId.trim();
          this.mergeRestoredLocalScoreEntriesWithIdentity();
        }
        if (payload.location && typeof payload.location === 'object') {
          this.setPlayerLocation({ ...payload.location });
        } else if (typeof payload.locationLabel === 'string' && payload.locationLabel.trim().length > 0) {
          this.playerLocationLabel = payload.locationLabel.trim();
        }
      } finally {
        this.identityHydrating = false;
      }
    }

    persistIdentitySnapshot() {
      if (this.identityHydrating || typeof localStorage === 'undefined') {
        return;
      }
      try {
        const payload = {
          displayName: this.playerDisplayName,
          googleId: this.playerGoogleId,
          location: this.playerLocation,
          locationLabel: this.playerLocationLabel,
        };
        localStorage.setItem(this.identityStorageKey, JSON.stringify(payload));
      } catch (error) {
        console.warn('Failed to persist identity snapshot', error);
      }
    }

    autoCaptureLocation(options = {}) {
      if (typeof navigator === 'undefined' || !navigator.geolocation) {
        if (options.updateOnFailure !== false) {
          this.setPlayerLocation({ error: 'Location unavailable' });
        }
        return Promise.resolve(null);
      }
      if (this.pendingLocationRequest) {
        return this.pendingLocationRequest;
      }
      if (!options.force && this.playerLocation && !this.playerLocation.error) {
        return Promise.resolve(this.playerLocation);
      }
      const now = typeof performance !== 'undefined' ? performance.now() : Date.now();
      if (
        !options.force &&
        this.lastLocationRequestAt &&
        now - this.lastLocationRequestAt < this.locationRequestCooldownSeconds * 1000
      ) {
        return Promise.resolve(this.playerLocation);
      }
      this.lastLocationRequestAt = now;
      this.pendingLocationRequest = new Promise((resolve) => {
        const handleSuccess = (position) => {
          this.pendingLocationRequest = null;
          const coords = position?.coords || {};
          const payload = {
            latitude: Number.isFinite(coords.latitude) ? coords.latitude : null,
            longitude: Number.isFinite(coords.longitude) ? coords.longitude : null,
            accuracy: Number.isFinite(coords.accuracy) ? coords.accuracy : null,
          };
          this.setPlayerLocation(payload);
          this.persistIdentitySnapshot();
          resolve(payload);
        };
        const handleError = (error) => {
          this.pendingLocationRequest = null;
          if (options.updateOnFailure !== false) {
            const denied = error?.code === error?.PERMISSION_DENIED;
            const label = denied ? 'Location permission denied' : 'Location unavailable';
            this.setPlayerLocation({ error: label });
            this.persistIdentitySnapshot();
          }
          resolve(null);
        };
        try {
          navigator.geolocation.getCurrentPosition(handleSuccess, handleError, {
            enableHighAccuracy: options.highAccuracy === true,
            maximumAge: Number.isFinite(options.maximumAge) ? options.maximumAge : 60000,
            timeout: Number.isFinite(options.timeout) ? options.timeout : 8000,
          });
        } catch (error) {
          handleError(error);
        }
      });
      return this.pendingLocationRequest;
    }

    describeDevice() {
      if (typeof navigator === 'undefined') {
        return 'Device details pending';
      }
      const platform = navigator.userAgentData?.platform || navigator.platform || 'Unknown platform';
      const brand = Array.isArray(navigator.userAgentData?.brands)
        ? navigator.userAgentData.brands.map((entry) => entry.brand).join(' · ')
        : navigator.vendor || '';
      const userAgent = navigator.userAgent || '';
      const labelParts = [platform.trim(), brand.trim(), userAgent.trim()].filter(Boolean);
      return labelParts.length ? labelParts.join(' · ') : 'Device details pending';
    }

    getDeviceLabel() {
      return this.deviceLabel;
    }

    inferLocationLabel(coords) {
      if (!coords) {
        return 'Location unavailable';
      }
      if (coords.error) {
        return typeof coords.error === 'string' ? coords.error : 'Location unavailable';
      }
      const latitude = Number(coords.latitude);
      const longitude = Number(coords.longitude);
      if (Number.isFinite(latitude) && Number.isFinite(longitude)) {
        const latLabel = latitude.toFixed(1);
        const lonLabel = longitude.toFixed(1);
        return `Lat ${latLabel}°, Lon ${lonLabel}°`;
      }
      return 'Location unavailable';
    }

    setPlayerLocation(location) {
      const hydrating = this.identityHydrating;
      if (!location) {
        this.playerLocation = null;
        this.playerLocationLabel = 'Location hidden';
      } else if (location.error) {
        this.playerLocation = { error: location.error };
        this.playerLocationLabel = typeof location.error === 'string' ? location.error : 'Location hidden';
      } else {
        const latitude = Number(location.latitude);
        const longitude = Number(location.longitude);
        const accuracy = Number.isFinite(location.accuracy) ? Number(location.accuracy) : null;
        const normalized = {
          latitude: Number.isFinite(latitude) ? latitude : null,
          longitude: Number.isFinite(longitude) ? longitude : null,
          accuracy,
        };
        const label = location.label || this.inferLocationLabel(normalized);
        normalized.label = label;
        this.playerLocation = normalized;
        this.playerLocationLabel = label;
      }
      if (this.started) {
        this.updateHud();
      }
      if (!hydrating) {
        this.updateLocalScoreEntry('location-update');
        this.scheduleScoreSync('location-update');
        this.renderScoreboard();
      }
      this.persistIdentitySnapshot();
    }

    setIdentity(identity = {}) {
      const previousId = this.playerGoogleId;
      const name = typeof identity.name === 'string' ? identity.name.trim() : '';
      if (name) {
        this.playerDisplayName = name;
      }
      this.playerGoogleId = identity.googleId ?? null;
      this.playerEmail = identity.email ?? null;
      this.playerAvatarUrl = identity.avatar ?? null;
      if (this.playerGoogleId) {
        this.mergeRestoredLocalScoreEntriesWithIdentity();
      }
      if (identity.location || identity.locationLabel) {
        this.setPlayerLocation(identity.location || { label: identity.locationLabel });
      }
      if (identity.locationLabel && !identity.location) {
        this.playerLocationLabel = identity.locationLabel;
      }
      if (this.started) {
        this.updateHud();
      }
      this.updateLocalScoreEntry('identity-update');
      this.scheduleScoreSync('identity-update');
      this.persistIdentitySnapshot();
      if (previousId !== this.playerGoogleId && typeof this.loadScoreboard === 'function') {
        this.loadScoreboard({ force: true }).catch(() => {});
      } else {
        this.renderScoreboard();
      }
    }

    clearIdentity() {
      this.playerGoogleId = null;
      this.playerEmail = null;
      this.playerAvatarUrl = null;
      this.playerDisplayName = this.defaultPlayerName || 'Explorer';
      this.playerLocation = null;
      this.playerLocationLabel = 'Location hidden';
      if (this.started) {
        this.updateHud();
      }
      this.updateLocalScoreEntry('identity-cleared');
      this.scheduleScoreSync('identity-cleared');
      this.renderScoreboard();
      this.persistIdentitySnapshot();
    }

    registerDefaultVoxelTexturePalette(key, palette) {
      const normalised = typeof key === 'string' ? key.trim() : '';
      if (!normalised || !palette || typeof palette !== 'object') {
        return;
      }
      const safePalette = {
        base: palette.base || DEFAULT_PROCEDURAL_VOXEL_PALETTE.base,
        highlight: palette.highlight || palette.base || DEFAULT_PROCEDURAL_VOXEL_PALETTE.highlight,
        shadow: palette.shadow || palette.base || DEFAULT_PROCEDURAL_VOXEL_PALETTE.shadow,
        accent: palette.accent || palette.highlight || DEFAULT_PROCEDURAL_VOXEL_PALETTE.accent,
      };
      this.defaultVoxelTexturePalettes.set(normalised, safePalette);
    }

    ensureProceduralTexture(key) {
      const normalised = typeof key === 'string' ? key.trim() : '';
      if (!normalised) {
        return null;
      }
      let texture = this.textureCache.get(normalised) || null;
      if (texture) {
        return texture;
      }
      if (!this.defaultVoxelTexturePalettes.has(normalised)) {
        const fallbackPalette = resolveProceduralVoxelPalette(normalised);
        this.registerDefaultVoxelTexturePalette(normalised, fallbackPalette);
      }
      const storedPalette = this.defaultVoxelTexturePalettes.get(normalised) || DEFAULT_PROCEDURAL_VOXEL_PALETTE;
      texture = this.createVoxelTexture(normalised, storedPalette);
      return texture;
    }

    createVoxelTexture(key, palette) {
      const normalised = typeof key === 'string' ? key.trim() : '';
      const cacheKey = normalised || key;
      if (palette && typeof palette === 'object') {
        this.registerDefaultVoxelTexturePalette(cacheKey, palette);
      }
      const cached = this.textureCache.get(cacheKey);
      if (cached) {
        return cached;
      }
      const THREE = this.THREE;
      const size = 32;
      const colorSet = buildProceduralColorSet(palette);
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        const fallback = createSkyGrassDataTexture(THREE, colorSet);
        this.textureCache.set(cacheKey, fallback);
        return fallback;
      }
      const base = colorSet.grass;
      const highlight = mixRgb(base, colorSet.cloud, 0.6);
      const midTone = mixRgb(base, colorSet.sky, 0.25);
      const shadow = mixRgb(base, colorSet.shadow, 0.65);
      const hashSeed = (() => {
        if (!normalised) {
          return 0x811c9dc5;
        }
        let hash = 0x811c9dc5;
        for (let i = 0; i < normalised.length; i += 1) {
          hash ^= normalised.charCodeAt(i) * (i + 11);
          hash = (hash << 5) - hash;
        }
        return hash >>> 0;
      })();
      const pseudoRandom = (x, y) => {
        let value = hashSeed + x * 374761393 + y * 668265263;
        value = (value ^ (value >>> 13)) * 1274126177;
        value = value ^ (value >>> 16);
        return (value >>> 0) / 4294967295;
      };
      const topBand = Math.max(3, Math.floor(size * 0.22));
      const bottomBand = Math.max(3, Math.floor(size * 0.26));
      const edgeBand = Math.max(2, Math.floor(size * 0.14));
      const accentBand = Math.max(1, Math.floor(size * 0.08));
      const checkerOffset = hashSeed % 4;
      const accentModulo = 9 + (hashSeed % 5);
      const accentShift = (hashSeed >>> 5) % accentModulo;
      const soilStart = topBand;
      const soilEnd = size - bottomBand;
      for (let y = 0; y < size; y += 1) {
        for (let x = 0; x < size; x += 1) {
          const verticalRatio = clamp01((y - topBand) / Math.max(1, size - topBand - bottomBand));
          let color = mixRgb(highlight, midTone, clamp01(y / topBand) * 0.5);
          color = mixRgb(color, shadow, verticalRatio * 0.5);
          if (x < edgeBand) {
            const edgeRatio = clamp01((edgeBand - x) / edgeBand);
            color = mixRgb(color, highlight, edgeRatio * 0.3);
          } else if (x >= size - edgeBand) {
            const edgeRatio = clamp01((x - (size - edgeBand - 1)) / edgeBand);
            color = mixRgb(color, shadow, edgeRatio * 0.35);
          }
          if (y < accentBand) {
            const accentRatio = clamp01((accentBand - y) / accentBand);
            color = mixRgb(color, highlight, accentRatio * 0.25);
          } else if (y >= size - accentBand) {
            const accentRatio = clamp01((y - (size - accentBand - 1)) / accentBand);
            color = mixRgb(color, shadow, accentRatio * 0.3);
          }
          const topBlend = y < topBand ? clamp01((topBand - y) / topBand) : 0;
          const bottomBlend = y >= soilEnd ? clamp01((y - soilEnd) / Math.max(1, bottomBand)) : 0;
          const surfaceNoise = pseudoRandom(x * 7, hashSeed + y * 13);
          const detailNoise = pseudoRandom(hashSeed + x * 17, y * 29);
          if (topBlend > 0) {
            const bladeBase = mixRgb(highlight, mixRgb(colorSet.sky, colorSet.cloud, 0.35), 0.5);
            const bladeStrength = topBlend * (0.3 + surfaceNoise * 0.4);
            color = mixRgb(color, bladeBase, bladeStrength);
            const stripeInterval = 3 + (hashSeed % 3);
            if ((x + Math.floor(surfaceNoise * 5)) % stripeInterval === 0) {
              const stripeColor = mixRgb(bladeBase, colorSet.shadow, 0.45);
              color = mixRgb(color, stripeColor, 0.4 * topBlend);
            }
            const dewNoise = pseudoRandom(hashSeed ^ (x * 53), y * 97);
            if (dewNoise > 0.88) {
              const dewColor = mixRgb(colorSet.cloud, colorSet.sky, 0.5);
              color = mixRgb(color, dewColor, 0.3 * topBlend);
            }
          } else if (bottomBlend > 0) {
            const depth = bottomBlend;
            const bedrockColor = mixRgb(shadow, colorSet.shadow, 0.5);
            color = mixRgb(color, bedrockColor, 0.55 * depth);
            const seamInterval = 4 + (hashSeed % 4);
            if ((y + Math.floor(detailNoise * 3)) % seamInterval === 0) {
              const seamColor = mixRgb(bedrockColor, colorSet.sky, 0.15);
              color = mixRgb(color, seamColor, 0.3 * depth);
            }
            if (surfaceNoise > 0.82) {
              const glintColor = mixRgb(colorSet.cloud, colorSet.sky, 0.2);
              color = mixRgb(color, glintColor, 0.25 * depth);
            }
          } else {
            const soilNoise = surfaceNoise;
            const striationNoise = detailNoise;
            const striation = (Math.floor((y - soilStart) / 2) + Math.floor(striationNoise * 3)) % 2 === 0;
            const soilHighlight = mixRgb(midTone, colorSet.sky, 0.18);
            const soilShadow = mixRgb(shadow, colorSet.shadow, 0.45);
            color = mixRgb(color, soilNoise > 0.55 ? soilHighlight : soilShadow, 0.35);
            if (striation) {
              color = mixRgb(color, soilShadow, 0.2);
            }
            if (soilNoise > 0.9) {
              const mica = mixRgb(colorSet.cloud, soilHighlight, 0.5);
              color = mixRgb(color, mica, 0.28);
            } else if (soilNoise < 0.08) {
              const peat = mixRgb(colorSet.shadow, soilShadow, 0.6);
              color = mixRgb(color, peat, 0.3);
            }
          }
          const checker = (Math.floor((x + checkerOffset) / 4) + Math.floor((y + checkerOffset) / 4)) % 2 === 0;
          const checkerMix = checker ? mixRgb(colorSet.cloud, colorSet.sky, 0.35) : mixRgb(colorSet.shadow, colorSet.sky, 0.25);
          color = mixRgb(color, checkerMix, 0.1);
          const grain = pseudoRandom(x, y);
          const grainHighlight = mixRgb(colorSet.cloud, colorSet.sky, 0.3);
          const grainShadow = mixRgb(colorSet.shadow, colorSet.grass, 0.6);
          color = mixRgb(color, grain > 0.58 ? grainHighlight : grainShadow, Math.abs(grain - 0.5) * 0.22 + 0.05);
          if (((x + y * size + accentShift) % accentModulo) === 0) {
            const accentColor = mixRgb(colorSet.sky, colorSet.cloud, 0.4);
            color = mixRgb(color, accentColor, 0.32 + topBlend * 0.2);
          } else if (((x * 3 + y * 5 + accentShift) % (accentModulo + 3)) === 0) {
            const shadowAccent = mixRgb(colorSet.shadow, colorSet.grass, 0.5);
            color = mixRgb(color, shadowAccent, 0.2 + bottomBlend * 0.25);
          }
          const sparkle = pseudoRandom(x + hashSeed, y + hashSeed);
          if (sparkle > 0.97 && topBlend > 0) {
            const sparkleColor = mixRgb(colorSet.cloud, colorSet.sky, 0.6);
            color = mixRgb(color, sparkleColor, 0.35 * topBlend);
          } else if (sparkle < 0.03 && bottomBlend > 0) {
            const emberColor = mixRgb(colorSet.shadow, colorSet.sky, 0.25);
            color = mixRgb(color, emberColor, 0.25 * bottomBlend);
          }
          ctx.fillStyle = rgbToCss(color);
          ctx.fillRect(x, y, 1, 1);
        }
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.anisotropy = 1;
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.needsUpdate = true;
      this.textureCache.set(cacheKey, texture);
      return texture;
    }

    describeVoxelTextureKey(key) {
      if (typeof key !== 'string') {
        return 'voxel';
      }
      const normalised = key.trim();
      if (!normalised) {
        return 'voxel';
      }
      const mapping = {
        grass: 'grass',
        dirt: 'dirt',
        stone: 'stone',
        obsidian: 'obsidian',
        sand: 'sand',
        gravel: 'gravel',
      };
      return mapping[normalised] || normalised;
    }

    formatTextureNameList(labels) {
      if (!Array.isArray(labels) || !labels.length) {
        return '';
      }
      if (labels.length === 1) {
        return labels[0];
      }
      if (labels.length === 2) {
        return `${labels[0]} and ${labels[1]}`;
      }
      const head = labels.slice(0, -1).join(', ');
      return `${head}, and ${labels[labels.length - 1]}`;
    }

    buildTextureFallbackMessage() {
      const missingKeys = Array.from(this.textureFallbackMissingKeys || []).filter(
        (entry) => typeof entry === 'string' && entry.trim().length,
      );
      const prefix = this.texturePackUnavailable ? 'Texture pack unavailable' : 'Texture pack offline';
      const retrySummary = this.describeScheduledTextureRetry();
      if (!missingKeys.length) {
        const suffix = retrySummary ? ` ${retrySummary}` : '';
        return `${prefix} — using procedural colours until streaming recovers.${suffix}`;
      }
      const sorted = missingKeys.sort();
      const labels = sorted.map((entry) => this.describeVoxelTextureKey(entry));
      const list = this.formatTextureNameList(labels);
      const suffix = retrySummary ? ` ${retrySummary}` : '';
      return `${prefix} — missing textures for ${list}. Procedural colours active until streaming recovers.${suffix}`;
    }

    describeScheduledTextureRetry() {
      if (!this.textureRetrySchedules || this.textureRetrySchedules.size === 0) {
        return '';
      }
      const now = typeof Date !== 'undefined' && typeof Date.now === 'function' ? Date.now() : null;
      let nextEntry = null;
      for (const [key, entry] of this.textureRetrySchedules.entries()) {
        if (!entry || typeof entry !== 'object') {
          continue;
        }
        const delayMs = Number.isFinite(entry.delayMs) ? entry.delayMs : null;
        const scheduledAt = Number.isFinite(entry.scheduledAt) ? entry.scheduledAt : null;
        const storedRunAt = Number.isFinite(entry.runAt) ? entry.runAt : null;
        const computedRunAt = Number.isFinite(scheduledAt) && Number.isFinite(delayMs)
          ? scheduledAt + delayMs
          : null;
        const runAt = storedRunAt ?? computedRunAt;
        if (!Number.isFinite(runAt)) {
          continue;
        }
        if (!nextEntry || runAt < nextEntry.runAt) {
          nextEntry = {
            key,
            attempt: Number.isFinite(entry.attempt) ? Math.max(1, Math.floor(entry.attempt)) : null,
            runAt,
          };
        }
      }
      if (!nextEntry) {
        return '';
      }
      const attemptNumber = nextEntry.attempt || null;
      let secondsRemaining = null;
      if (Number.isFinite(now)) {
        secondsRemaining = Math.max(0, Math.ceil((nextEntry.runAt - now) / 1000));
      } else if (Number.isFinite(nextEntry.runAt)) {
        secondsRemaining = Math.max(0, Math.ceil(nextEntry.runAt / 1000));
      }
      const attemptSuffix = attemptNumber ? ` (attempt ${attemptNumber} of ${this.assetRetryLimit})` : '';
      if (!Number.isFinite(secondsRemaining)) {
        return `Retrying texture streams soon${attemptSuffix}.`;
      }
      if (secondsRemaining <= 0) {
        return `Retrying texture streams now${attemptSuffix}.`;
      }
      const label = this.describeVoxelTextureKey(nextEntry.key);
      const keyFragment = label ? ` for ${label}` : '';
      const plural = secondsRemaining === 1 ? '' : 's';
      return `Next retry${keyFragment} in ${secondsRemaining} second${plural}${attemptSuffix}.`;
    }

    refreshTextureFallbackNotice() {
      const message = this.buildTextureFallbackMessage();
      if (!message) {
        return;
      }
      const isFirstNotice = this.texturePackNoticeShown !== true;
      if (typeof console !== 'undefined' && typeof console.warn === 'function') {
        if (isFirstNotice || message !== this.lastTextureFallbackMessage) {
          console.warn(message, {
            failures: this.texturePackErrorCount,
            missingKeys: Array.from(this.textureFallbackMissingKeys || []),
          });
        }
      }
      if (this.playerHintEl) {
        this.playerHintEl.textContent = message;
        this.playerHintEl.classList?.add?.('visible');
        this.playerHintEl.setAttribute?.('data-variant', 'warning');
      }
      if (this.footerStatusEl) {
        this.footerStatusEl.textContent = message;
      }
      if (this.footerEl?.dataset) {
        this.footerEl.dataset.state = 'warning';
      }
      this.lastHintMessage = message;
      this.lastTextureFallbackMessage = message;
      this.texturePackNoticeShown = true;
    }

    dismissTextureFallbackNotice() {
      const previousMessage = this.lastTextureFallbackMessage;
      this.texturePackUnavailable = false;
      this.texturePackNoticeShown = false;
      this.lastTextureFallbackMessage = '';
      if (!previousMessage) {
        return;
      }
      if (this.playerHintEl && this.playerHintEl.textContent === previousMessage) {
        this.playerHintEl.classList?.remove?.('visible');
        this.playerHintEl.textContent = '';
        this.playerHintEl.removeAttribute?.('data-variant');
      }
      if (this.footerStatusEl && this.footerStatusEl.textContent === previousMessage) {
        this.footerStatusEl.textContent = '';
      }
      if (this.footerEl?.dataset?.state === 'warning') {
        delete this.footerEl.dataset.state;
      }
      if (this.lastHintMessage === previousMessage) {
        this.lastHintMessage = '';
      }
    }

    clearScheduledTextureRetry(key) {
      const normalised = typeof key === 'string' ? key.trim() : '';
      if (!normalised || !this.textureRetryHandles?.has?.(normalised)) {
        return;
      }
      const handle = this.textureRetryHandles.get(normalised);
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      const clearTimer = typeof scope?.clearTimeout === 'function' ? scope.clearTimeout.bind(scope) : clearTimeout;
      clearTimer(handle);
      this.textureRetryHandles.delete(normalised);
      this.textureRetrySchedules?.delete?.(normalised);
    }

    handleTextureRetryExhausted(key, context = {}) {
      const normalised = typeof key === 'string' ? key.trim() : '';
      if (!normalised) {
        return;
      }
      this.textureRetryAttempts.set(normalised, this.assetRetryLimit);
      this.clearScheduledTextureRetry(normalised);
      if (typeof console !== 'undefined' && typeof console.warn === 'function') {
        console.warn(`Texture stream for ${normalised} failed after ${this.assetRetryLimit} attempt(s).`, {
          key: normalised,
          reason: context?.reason || 'unknown',
          url: context?.url ?? null,
        });
      }
      const fallbackMessage = this.buildTextureFallbackMessage();
      this.recordAssetFailure(`texture:${normalised}`, {
        fallbackMessage,
        error: context?.error || null,
      });
      this.emitGameEvent('texture-retry-exhausted', {
        key: normalised,
        reason: context?.reason || 'unknown',
        url: context?.url ?? null,
      });
    }

    triggerTextureRetry(key) {
      const normalised = typeof key === 'string' ? key.trim() : '';
      if (!normalised) {
        return;
      }
      this.textureRetrySchedules?.delete?.(normalised);
      if (this.texturePackNoticeShown) {
        this.refreshTextureFallbackNotice();
      }
      const attemptNumber = this.textureRetryAttempts.get(normalised) || 1;
      this.emitGameEvent('texture-retry-attempt', {
        key: normalised,
        attempt: attemptNumber,
      });
      const schedule = this.textureRetrySchedules?.get?.(normalised) || null;
      this.emitGameEvent('asset-retry-attempt', {
        key: `texture:${normalised}`,
        kind: 'textures',
        attempt: attemptNumber,
        limit: this.assetRetryLimit,
        reason: schedule?.reason || 'unknown',
        url: schedule?.url ?? null,
      });
      const material = this.textureUpgradeTargets.get(normalised) || null;
      if (material) {
        this.queueExternalTextureUpgrade(normalised, material);
        return;
      }
      this.loadExternalVoxelTexture(normalised);
    }

    scheduleTextureRetry(key, context = {}) {
      const normalised = typeof key === 'string' ? key.trim() : '';
      if (!normalised) {
        return;
      }
      const reason = context?.reason || 'unknown';
      if (reason === 'unsupported-environment' || reason === 'missing-sources') {
        return;
      }
      if (this.textureRetryHandles.has(normalised)) {
        return;
      }
      const attemptsSoFar = this.textureRetryAttempts.get(normalised) || 0;
      if (attemptsSoFar >= this.assetRetryLimit) {
        this.handleTextureRetryExhausted(normalised, context);
        return;
      }
      const nextAttempt = attemptsSoFar + 1;
      this.textureRetryAttempts.set(normalised, nextAttempt);
      const intervalMs =
        Number.isFinite(this.texturePackRetryIntervalMs) && this.texturePackRetryIntervalMs > 0
          ? Math.max(1000, Math.floor(this.texturePackRetryIntervalMs))
          : 60000;
      const delay = intervalMs;
      const delaySeconds = Math.max(1, Math.round(delay / 1000));
      const scheduledAt = typeof Date !== 'undefined' && typeof Date.now === 'function' ? Date.now() : null;
      const runAt =
        Number.isFinite(scheduledAt) && Number.isFinite(delay)
          ? scheduledAt + delay
          : Number.isFinite(delay)
            ? delay
            : null;
      if (typeof console !== 'undefined' && typeof console.warn === 'function') {
        console.warn(
          `Retrying ${normalised} texture stream (attempt ${nextAttempt} of ${this.assetRetryLimit}) after a loading error in ${delaySeconds} second(s).`,
          {
            key: normalised,
            attempt: nextAttempt,
            delay,
            reason,
            url: context?.url ?? null,
          },
        );
      }
      if (attemptsSoFar === 0) {
        this.emitGameEvent('asset-retry-requested', {
          keys: [`texture:${normalised}`],
          source: 'automatic',
        });
      }
      this.emitGameEvent('texture-retry-scheduled', {
        key: normalised,
        attempt: nextAttempt,
        delayMs: delay,
        reason,
        url: context?.url ?? null,
      });
      this.emitGameEvent('asset-retry-scheduled', {
        key: `texture:${normalised}`,
        kind: 'textures',
        attempt: nextAttempt,
        limit: this.assetRetryLimit,
        delayMs: delay,
        reason,
        url: context?.url ?? null,
      });
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      const setTimer = typeof scope?.setTimeout === 'function' ? scope.setTimeout.bind(scope) : setTimeout;
      const handle = setTimer(() => {
        this.textureRetryHandles.delete(normalised);
        this.textureRetrySchedules?.delete?.(normalised);
        if (this.texturePackNoticeShown) {
          this.refreshTextureFallbackNotice();
        }
        this.triggerTextureRetry(normalised);
      }, delay);
      this.textureRetryHandles.set(normalised, handle);
      this.textureRetrySchedules.set(normalised, {
        attempt: nextAttempt,
        delayMs: delay,
        scheduledAt,
        runAt,
        reason,
        url: context?.url ?? null,
      });
      if (this.texturePackNoticeShown) {
        this.refreshTextureFallbackNotice();
      }
    }

    retryMissingTextureStreams(context = {}) {
      const keys = Array.from(this.textureFallbackMissingKeys || []).filter(
        (entry) => typeof entry === 'string' && entry.trim().length,
      );
      if (!keys.length) {
        return;
      }
      const reason = typeof context?.reason === 'string' ? context.reason : 'manual';
      if (typeof console !== 'undefined' && typeof console.info === 'function') {
        console.info('Retrying texture pack streams for missing textures.', {
          keys,
          reason,
        });
      }
      keys.forEach((key) => {
        const normalised = typeof key === 'string' ? key.trim() : '';
        if (!normalised) {
          return;
        }
        if (this.pendingTextureLoads?.has?.(normalised)) {
          return;
        }
        this.clearScheduledTextureRetry(normalised);
        this.triggerTextureRetry(normalised);
      });
    }

    handleNetworkOnline() {
      this.retryMissingTextureStreams({ reason: 'network-online' });
    }

    noteTexturePackRecovery(key, context = {}) {
      const normalised = typeof key === 'string' ? key.trim() : '';
      if (!normalised) {
        return;
      }
      const wasMissing = this.textureFallbackMissingKeys.delete(normalised);
      const attemptsUsed = this.textureRetryAttempts.get(normalised) || 0;
      this.textureRetryAttempts.delete(normalised);
      this.clearScheduledTextureRetry(normalised);
      if (wasMissing) {
        if (typeof console !== 'undefined' && typeof console.info === 'function') {
          console.info(`Texture streaming restored for ${normalised}.`, {
            key: normalised,
            url: context?.url ?? null,
          });
        }
        this.emitGameEvent('texture-pack-recovered', {
          key: normalised,
          url: context?.url ?? null,
        });
        if (attemptsUsed > 0) {
          this.emitGameEvent('asset-retry-success', {
            key: `texture:${normalised}`,
            kind: 'textures',
            attempts: attemptsUsed,
            url: context?.url ?? null,
          });
        }
      }
      if (this.textureFallbackMissingKeys.size === 0) {
        this.texturePackUnavailable = false;
        this.dismissTextureFallbackNotice();
      } else if (wasMissing) {
        this.refreshTextureFallbackNotice();
      }
    }

    getExternalTextureSources(key) {
      if (typeof window === 'undefined') {
        return [];
      }
      const config = window.APP_CONFIG || {};
      const explicit = config.textures && typeof config.textures === 'object' ? config.textures[key] : null;
      const sources = [];
      if (typeof explicit === 'string' && explicit.trim()) {
        sources.push(explicit.trim());
      } else if (Array.isArray(explicit)) {
        explicit
          .map((value) => (typeof value === 'string' ? value.trim() : ''))
          .filter(Boolean)
          .forEach((value) => sources.push(value));
      }
      const base = typeof config.textureBaseUrl === 'string' ? config.textureBaseUrl.trim() : '';
      if (base) {
        const normalised = base.endsWith('/') ? base.slice(0, -1) : base;
        sources.push(`${normalised}/${key}.png`);
      }
      const manifest = config.textureManifest && typeof config.textureManifest === 'object' ? config.textureManifest : null;
      if (manifest) {
        const manifestEntry = manifest[key];
        if (typeof manifestEntry === 'string' && manifestEntry.trim()) {
          sources.push(manifestEntry.trim());
        } else if (Array.isArray(manifestEntry)) {
          manifestEntry
            .map((value) => (typeof value === 'string' ? value.trim() : ''))
            .filter(Boolean)
            .forEach((value) => sources.push(value));
        }
      }
      const defaultManifestEntry = DEFAULT_TEXTURE_MANIFEST[key];
      if (typeof defaultManifestEntry === 'string' && defaultManifestEntry) {
        sources.push(defaultManifestEntry);
      } else if (Array.isArray(defaultManifestEntry)) {
        defaultManifestEntry
          .map((value) => (typeof value === 'string' ? value.trim() : ''))
          .filter(Boolean)
          .forEach((value) => sources.push(value));
      }
      return sources.filter(Boolean);
    }

    prepareExternalTexture(texture) {
      const THREE = this.THREE;
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.anisotropy = 1;
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.generateMipmaps = false;
      texture.needsUpdate = true;
    }

    noteTexturePackFallback(reason = 'unknown', context = {}) {
      this.texturePackErrorCount = (this.texturePackErrorCount || 0) + 1;
      const key = typeof context?.key === 'string' ? context.key.trim() : '';
      if (key) {
        this.textureFallbackMissingKeys.add(key);
      }
      this.texturePackUnavailable = true;
      const failureKey = key && typeof key === 'string' && key.trim().length ? `texture:${key.trim()}` : 'texture-pack';
      const previousFailures = this.assetFailureCounts?.get(failureKey) || 0;
      const fallbackMessage = this.buildTextureFallbackMessage();
      if (fallbackMessage && previousFailures === 0) {
        this.recordAssetFailure(failureKey, {
          fallbackMessage,
          error: context?.error || null,
        });
      }
      this.emitGameEvent('texture-pack-fallback', {
        reason,
        failures: this.texturePackErrorCount,
        key: key || null,
        url: context.url || null,
        missingKeys: Array.from(this.textureFallbackMissingKeys || []),
      });
      if (this.enforceAssetPreloadStrictness && key && !this.criticalAssetPreloadFailed) {
        const failureKey = `texture:${key}`;
        if (!this.assetFailureCounts.has(failureKey)) {
          const fallbackMessage = `Texture "${key}" failed to load. Reload to try again.`;
          this.recordAssetFailure(failureKey, {
            fallbackMessage,
            error: context?.error || null,
          });
        }
        const abortMessage = `Texture "${key}" failed to load. Reload to try again.`;
        this.abortDueToAssetFailure(abortMessage, {
          stage: reason === 'fallback-texture' ? 'texture-load' : 'texture-environment',
          error: context?.error || null,
          key: failureKey,
        });
      }
      const shouldShowNotice =
        this.texturePackNoticeShown ||
        this.textureFallbackMissingKeys.size > 0 ||
        this.texturePackErrorCount >= this.texturePackErrorNoticeThreshold;
      if (shouldShowNotice) {
        this.refreshTextureFallbackNotice();
      }
      if (key && reason === 'fallback-texture') {
        this.scheduleTextureRetry(key, { reason, url: context.url || null });
      }
    }

    loadExternalVoxelTexture(key) {
      const canStreamTextures =
        typeof document !== 'undefined' &&
        typeof document.createElement === 'function' &&
        typeof Image !== 'undefined';
      if (!canStreamTextures) {
        const fallback = this.ensureProceduralTexture(key);
        this.noteTexturePackFallback('unsupported-environment', { key });
        return Promise.resolve(fallback);
      }
      const sources = this.getExternalTextureSources(key);
      if (!sources.length) {
        const fallback = this.ensureProceduralTexture(key);
        this.noteTexturePackFallback('missing-sources', { key });
        return Promise.resolve(fallback);
      }
      if (this.pendingTextureLoads.has(key)) {
        return this.pendingTextureLoads.get(key);
      }
      const THREE = this.THREE;
      if (!this.textureLoader) {
        this.textureLoader = new THREE.TextureLoader();
        if (typeof this.textureLoader.setCrossOrigin === 'function') {
          this.textureLoader.setCrossOrigin('anonymous');
        } else {
          this.textureLoader.crossOrigin = 'anonymous';
        }
      }
      const useCachedFallbackTexture = (options = {}) => {
        const fallbackTexture = this.ensureProceduralTexture(key);
        if (fallbackTexture) {
          if (!options.silent) {
            const lastUrl = options.url ? ` after ${options.url}` : '';
            console.warn(
              `Falling back to default ${key} texture${lastUrl} because external sources failed.`,
            );
            notifyLiveDiagnostics(
              'texture',
              `Falling back to default ${key} texture source.`,
              { key, url: options.url || null },
              { level: 'warning' },
            );
          }
          this.noteTexturePackFallback('fallback-texture', {
            key,
            url: options.url || null,
          });
        } else if (!options.silent) {
          console.warn(`No procedural fallback texture is available for ${key}.`);
          notifyLiveDiagnostics(
            'texture',
            `No procedural fallback texture is available for ${key}.`,
            { key },
            { level: 'warning' },
          );
        }
        if (!fallbackTexture && key) {
          this.scheduleTextureRetry(key, {
            reason: 'missing-fallback-texture',
            url: options.url || null,
          });
        }
        return fallbackTexture;
      };

      const attemptLoad = (index) => {
        if (index >= sources.length) {
          return Promise.resolve(null);
        }
        const url = sources[index];
        return new Promise((resolve) => {
          this.textureLoader.load(
            url,
            (texture) => {
              resolve({ texture, url });
            },
            undefined,
            () => {
              console.warn(`Failed to load texture ${url}; attempting fallback source.`);
              notifyLiveDiagnostics(
                'texture',
                `Failed to load texture source for ${key}.`,
                { key, url, attempt: index + 1 },
                { level: 'warning' },
              );
              resolve(null);
            },
          );
        }).then((result) => {
          if (result) {
            return result;
          }
          return attemptLoad(index + 1);
        });
      };
      this.beginAssetTimer('textures', key);
      const loadPromise = attemptLoad(0)
        .then((result) => {
          if (!result || !result.texture) {
            const url = result?.url ?? null;
            this.completeAssetTimer('textures', key, { success: false, url });
            return useCachedFallbackTexture({ url }) ?? null;
          }
          this.prepareExternalTexture(result.texture);
          const resolvedUrl = result.url || '';
          const sourceIndex = typeof resolvedUrl === 'string' ? sources.indexOf(resolvedUrl) : -1;
          const wasPrimarySource = sourceIndex <= 0;
          const usedEmbeddedTexture = typeof resolvedUrl === 'string' && resolvedUrl.startsWith('data:');
          const logMode = usedEmbeddedTexture ? (wasPrimarySource ? 'default' : 'fallback') : 'check';
          if (usedEmbeddedTexture && !wasPrimarySource) {
            this.noteTexturePackFallback('embedded-texture', { key, url: resolvedUrl });
            this.scheduleTextureRetry(key, { reason: 'embedded-texture', url: resolvedUrl });
          } else {
            this.noteTexturePackRecovery(key, { url: resolvedUrl || null });
          }
          const logger = logMode === 'fallback' ? console.warn : console.info;
          if (typeof logger === 'function') {
            const sourceDescription = usedEmbeddedTexture
              ? wasPrimarySource
                ? 'the embedded default texture'
                : 'an embedded fallback texture'
              : resolvedUrl;
            const advisory =
              logMode === 'fallback'
                ? 'External sources failed, using embedded texture data.'
                : logMode === 'default'
                  ? 'Embedded default texture applied immediately. Configure APP_CONFIG.textureManifest to override this asset.'
                  : 'External texture stream succeeded.';
            logger(
              `Texture streaming ${logMode} — ${key} resolved via ${sourceDescription}. ${advisory} If textures appear blank, verify CDN availability and fallback cache configuration.`,
            );
          }
          this.completeAssetTimer('textures', key, { success: true, url: result.url });
          return result.texture;
        })
        .catch((error) => {
          console.warn(`Unable to stream external texture for ${key}`, error);
          this.completeAssetTimer('textures', key, { success: false });
          return useCachedFallbackTexture({ silent: true });
        })
        .finally(() => {
          this.pendingTextureLoads.delete(key);
        });
      this.pendingTextureLoads.set(key, loadPromise);
      return loadPromise;
    }

    queueExternalTextureUpgrade(key, material) {
      if (typeof key === 'string' && key.trim()) {
        if (material) {
          this.textureUpgradeTargets.set(key.trim(), material);
        } else {
          this.textureUpgradeTargets.delete(key.trim());
        }
      }
      const promise = this.loadExternalVoxelTexture(key);
      if (!promise) {
        return;
      }
      promise.then((texture) => {
        if (!texture || !material) {
          return;
        }
        this.textureCache.set(key, texture);
        material.map = texture;
        material.needsUpdate = true;
        if (this.renderer) {
          this.applyTextureAnisotropy();
        }
      });
    }

    async refreshTexturePack(options = {}) {
      const source = typeof options.source === 'string' && options.source.trim().length
        ? options.source.trim()
        : 'manual';
      const requestedKeys = Array.isArray(options.keys)
        ? options.keys
            .map((key) => (typeof key === 'string' ? key.trim() : ''))
            .filter((key) => key.length > 0)
        : [];
      const targetKeys = new Set(requestedKeys);
      if (targetKeys.size === 0 && this.textureFallbackMissingKeys instanceof Set) {
        this.textureFallbackMissingKeys.forEach((key) => {
          if (typeof key === 'string' && key.trim().length) {
            targetKeys.add(key.trim());
          }
        });
      }
      if (this.textureUpgradeTargets instanceof Map) {
        for (const key of this.textureUpgradeTargets.keys()) {
          if (typeof key === 'string' && key.trim().length) {
            targetKeys.add(key.trim());
          }
        }
      }
      const keys = Array.from(targetKeys);
      const results = [];
      const succeeded = [];
      const failed = [];
      if (keys.length === 0) {
        return { source, keys, results, succeeded, failed, reason: 'no-keys' };
      }
      for (const key of keys) {
        try {
          const texture = await this.loadExternalVoxelTexture(key);
          const material = this.textureUpgradeTargets?.get?.(key) || null;
          if (texture && material) {
            material.map = texture;
            material.needsUpdate = true;
          }
          const missing = this.textureFallbackMissingKeys?.has?.(key) === true;
          const success = Boolean(texture) && !missing;
          if (success) {
            succeeded.push(key);
          } else {
            failed.push(key);
          }
          results.push({ key, success, texture: texture ?? null });
        } catch (error) {
          failed.push(key);
          results.push({ key, success: false, error });
          this.noteTexturePackFallback('refresh-error', { key, error });
        }
      }
      if (succeeded.length && typeof this.applyTextureAnisotropy === 'function') {
        this.applyTextureAnisotropy();
      }
      if (typeof this.refreshTextureFallbackNotice === 'function') {
        this.refreshTextureFallbackNotice();
      }
      return { source, keys, results, succeeded, failed };
    }

    detectTouchPreferred() {
      if (typeof window === 'undefined') return false;
      if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
        return true;
      }
      const nav = typeof navigator !== 'undefined' ? navigator : null;
      if (nav?.maxTouchPoints && nav.maxTouchPoints > 0) {
        return true;
      }
      return 'ontouchstart' in window;
    }

    detectReducedMotion() {
      if (typeof window === 'undefined' || typeof window.matchMedia !== 'function') {
        return false;
      }
      try {
        return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      } catch (error) {
        console.debug('Unable to determine motion preferences', error);
        return false;
      }
    }

    createAudioController() {
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      const samples = scope?.INFINITE_RAILS_EMBEDDED_ASSETS?.audioSamples || null;
      const normaliseAudioName = (value) => {
        if (typeof value !== 'string') {
          return null;
        }
        const trimmed = value.trim();
        return trimmed.length ? trimmed : null;
      };
      const knownPlayableNames = new Set();
      const available = new Set();
      const sampleNames =
        samples && typeof samples === 'object' ? Object.keys(samples) : [];
      sampleNames.forEach((name) => {
        const normalised = normaliseAudioName(name);
        if (!normalised) {
          return;
        }
        available.add(normalised);
        knownPlayableNames.add(normalised);
      });
      const totalSamples = available.size;
      const HowlCtor = scope?.Howl;
      const useHowler = typeof HowlCtor === 'function';
      const AudioCtor = !useHowler
        ? scope?.Audio || (typeof Audio !== 'undefined' ? Audio : null)
        : null;
      const aliasSource = scope?.INFINITE_RAILS_AUDIO_ALIASES || null;
      const aliasMap = new Map();
      const ensureKnownPlayableName = (name) => {
        const normalised = normaliseAudioName(name);
        if (!normalised) {
          return null;
        }
        knownPlayableNames.add(normalised);
        return normalised;
      };
      if (aliasSource && typeof aliasSource === 'object') {
        Object.entries(aliasSource).forEach(([name, value]) => {
          const aliasName = ensureKnownPlayableName(name);
          if (!aliasName) {
            return;
          }
          const entries = Array.isArray(value) ? value : [value];
          const filtered = entries
            .map((item) => (typeof item === 'string' ? item.trim() : ''))
            .filter(Boolean);
          if (filtered.length) {
            filtered.forEach((candidate) => ensureKnownPlayableName(candidate));
            aliasMap.set(aliasName, filtered);
          }
        });
      }
      const aliasCache = new Map();
      const aliasNotified = new Set();
      const missingSampleNotified = new Set();
      const bootMissingSamples = new Set();
      const fallbackAlertName = '__fallback_alert__';
      const fallbackAlertSample =
        'UklGRoQJAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YWAJAAAAAEVBlWS7WbElXOCMqWqa6LmT+S88LmOmXJkrieYprc+ZXLUr8902YmE0X1Qx0ewbsZuZG7HR7FQxNF9iYd02K/Nctc+ZKa2J5pkrplwuYy88k/nouWqajKlc4LElu1mVZEVBAAC7vmubRaZP2qQfdFaWZRhGbQbRw9KcWqNn1HcZ11IxZqRK1QwjyZ6ezKCszi8T5U5lZuVOLxOszsygnp4jydUMpEoxZtdSdxln1Fqj0pzRw20GGEaWZXRWpB9P2kWma5u7vgAARUGVZLtZsSVc4IypaprouZP5LzwuY6ZcmSuJ5imtz5lctSvz3TZiYTRfVDHR7Buxm5kbsdHsVDE0X2Jh3TYr81y1z5kprYnmmSumXC5jLzyT+ei5apqMqVzgsSW7WZVkRUEAALu+a5tFpk/apB90VpZlGEZtBtHD0pxao2fUdxnXUjFmpErVDCPJnp7MoKzOLxPlTmVm5U4vE6zOzKCeniPJ1QykSjFm11J3GWfUWqPSnNHDbQYYRpZldFakH0/aRaZrm7u+AABFQZVku1mxJVzgjKlqmui5k/kvPC5jplyZK4nmKa3PmVy1K/PdNmJhNF9UMdHsG7GbmRux0exUMTRfYmHdNivzXLXPmSmtieaZK6ZcLmMvPJP56LlqmoypXOCxJbtZlWRFQQAAu75rm0WmT9qkH3RWlmUYRm0G0cPSnFqjZ9R3GddSMWakStUMI8mensygrM4vE+VOZWblTi8TrM7MoJ6eI8nVDKRKMWbXUncZZ9Rao9Kc0cNtBhhGlmV0VqQfT9pFpmubu74AAEVBlWS7WbElXOCMqWqa6LmT+S88LmOmXJkrieYprc+ZXLUr8902YmE0X1Qx0ewbsZuZG7HR7FQxNF9iYd02K/Nctc+ZKa2J5pkrplwuYy88k/nouWqajKlc4LElu1mVZEVBAAC7vmubRaZP2qQfdFaWZRhGbQbRw9KcWqNn1HcZ11IxZqRK1QwjyZ6ezKCszi8T5U5lZuVOLxOszsygnp4jydUMpEoxZtdSdxln1Fqj0pzRw20GGEaWZXRWpB9P2kWma5u7vgAARUGVZLtZsSVc4IypaprouZP5LzwuY6ZcmSuJ5imtz5lctSvz3TZiYTRfVDHR7Buxm5kbsdHsVDE0X2Jh3TYr81y1z5kprYnmmSumXC5jLzyT+ei5apqMqVzgsSW7WZVkRUEAALu+a5tFpk/apB90VpZlGEZtBtHD0pxao2fUdxnXUjFmpErVDCPJnp7MoKzOLxPlTmVm5U4vE6zOzKCeniPJ1QykSjFm11J3GWfUWqPSnNHDbQYYRpZldFakH0/aRaZrm7u+AABFQZVku1mxJVzgjKlqmui5k/kvPC5jplyZK4nmKa3PmVy1K/PdNmJhNF9UMdHsG7GbmRux0exUMTRfYmHdNivzXLXPmSmtieaZK6ZcLmMvPJP56LlqmoypXOCxJbtZlWRFQQAAu75rm0WmT9qkH3RWlmUYRm0G0cPSnFqjZ9R3GddSMWakStUMI8mensygrM4vE+VOZWblTi8TrM7MoJ6eI8nVDKRKMWbXUncZZ9Rao9Kc0cNtBhhGlmV0VqQfT9pFpmubu74AAEVBlWS7WbElXOCMqWqa6LmT+S88LmOmXJkrieYprc+ZXLUr8902YmE0X1Qx0ewbsZuZG7HR7FQxNF9iYd02K/Nctc+ZKa2J5pkrplwuYy88k/nouWqajKlc4LElu1mVZEVBAAC7vmubRaZP2qQfdFaWZRhGbQbRw9KcWqNn1HcZ11IxZqRK1QwjyZ6ezKCszi8T5U5lZuVOLxOszsygnp4jydUMpEoxZtdSdxln1Fqj0pzRw20GGEaWZXRWpB9P2kWma5u7vgAARUGVZLtZsSVc4IypaprouZP5LzwuY6ZcmSuJ5imtz5lctSvz3TZiYTRfVDHR7Buxm5kbsdHsVDE0X2Jh3TYr81y1z5kprYnmmSumXC5jLzyT+ei5apqMqVzgsSW7WZVkRUEAALu+a5tFpk/apB90VpZlGEZtBtHD0pxao2fUdxnXUjFmpErVDCPJnp7MoKzOLxPlTmVm5U4vE6zOzKCeniPJ1QykSjFm11J3GWfUWqPSnNHDbQYYRpZldFakH0/aRaZrm7u+AABFQZVku1mxJVzgjKlqmui5k/kvPC5jplyZK4nmKa3PmVy1K/PdNmJhNF9UMdHsG7GbmRux0exUMTRfYmHdNivzXLXPmSmtieaZK6ZcLmMvPJP56LlqmoypXOCxJbtZlWRFQQAAu75rm0WmT9qkH3RWlmUYRm0G0cPSnFqjZ9R3GddSMWakStUMI8mensygrM4vE+VOZWblTi8TrM7MoJ6eI8nVDKRKMWbXUncZZ9Rao9Kc0cNtBhhGlmV0VqQfT9pFpmubu74A';
      knownPlayableNames.add(fallbackAlertName);
      const submitAudioFailure = (sampleKey, message, error) => {
        const fallbackMessage = ensureAudioFallbackMessage(message);
        if (typeof this.recordAssetFailure === 'function') {
          const failureKey =
            typeof sampleKey === 'string' && sampleKey.trim().length
              ? `audio:${sampleKey.trim()}`
              : 'audio';
          this.recordAssetFailure(failureKey, {
            fallbackMessage,
            error: error || null,
          });
        }
        return fallbackMessage;
      };
      const getSamplePayload = (name) => {
        if (!name) return null;
        if (name === fallbackAlertName) {
          return fallbackAlertSample;
        }
        if (!samples || typeof samples !== 'object') {
          return null;
        }
        const payload = samples[name];
        return typeof payload === 'string' && payload.trim().length ? payload : null;
      };
      const hasSamplePayload = (name, options = {}) => {
        if (!name || name === fallbackAlertName) {
          return true;
        }
        const payload = getSamplePayload(name);
        if (!payload) {
          if (options?.stage === 'boot') {
            bootMissingSamples.add(name);
          }
          return false;
        }
        return true;
      };
      const resolveAudioName = (name) => {
        const lookupName = normaliseAudioName(name);
        if (!lookupName) {
          return null;
        }
        if (available.has(lookupName)) {
          return hasSamplePayload(lookupName) ? lookupName : null;
        }
        if (aliasCache.has(lookupName)) {
          return aliasCache.get(lookupName);
        }
        const candidates = aliasMap.get(lookupName);
        if (!candidates || !candidates.length) {
          aliasCache.set(lookupName, null);
          return null;
        }
        let resolved = null;
        for (let index = 0; index < candidates.length; index += 1) {
          const candidate = candidates[index];
          if (available.has(candidate) && hasSamplePayload(candidate)) {
            resolved = candidate;
            break;
          }
        }
        aliasCache.set(lookupName, resolved);
        return resolved;
      };
      const aliasIntegrityIssues = [];
      aliasMap.forEach((candidates, aliasName) => {
        if (!candidates || !candidates.length) {
          return;
        }
        let resolved = null;
        candidates.forEach((candidate) => {
          const normalisedCandidate = normaliseAudioName(candidate);
          if (!normalisedCandidate) {
            return;
          }
          ensureKnownPlayableName(normalisedCandidate);
          if (!available.has(normalisedCandidate)) {
            bootMissingSamples.add(normalisedCandidate);
            return;
          }
          if (hasSamplePayload(normalisedCandidate, { stage: 'boot' }) && resolved === null) {
            resolved = normalisedCandidate;
          }
        });
        if (!resolved) {
          aliasIntegrityIssues.push({ aliasName, candidates: [...candidates] });
        }
      });
      available.forEach((sampleName) => {
        hasSamplePayload(sampleName, { stage: 'boot' });
      });
      ['bubble', 'victoryCheer', 'miningA', 'miningB', 'crunch'].forEach((coreName) => {
        ensureKnownPlayableName(coreName);
        hasSamplePayload(coreName, { stage: 'boot' });
      });
      if (!totalSamples && typeof console !== 'undefined' && typeof console.warn === 'function') {
        console.warn(
          'No embedded audio samples were detected. Gameplay actions will fall back to an alert tone until audio assets are restored.',
        );
      }
      if (aliasIntegrityIssues.length && typeof console !== 'undefined' && typeof console.warn === 'function') {
        const detail = aliasIntegrityIssues
          .map((issue) => `${issue.aliasName} → [${issue.candidates.join(', ')}]`)
          .join('; ');
        console.warn(
          `One or more audio aliases do not resolve to an available sample. Missing mappings: ${detail}. A fallback beep will be used until the samples are restored.`,
        );
      }
      const howlCache = useHowler ? new Map() : null;
      const fallbackPlaying = useHowler ? null : new Map();
      let lastCaptionText = null;
      let lastCaptionAt = 0;
      let masterVolume = 1;
      const clampVolume = (value) => {
        if (!Number.isFinite(value)) {
          return 1;
        }
        return Math.max(0, Math.min(1, value));
      };
      const applyMasterVolume = (audio, baseVolume) => {
        if (!audio) return;
        const volume = clampVolume(baseVolume) * masterVolume;
        audio.volume = clampVolume(volume);
      };
      const getCaptionText = (requestedName, resolvedName) => {
        const captions =
          (runtimeScope && typeof runtimeScope.INFINITE_RAILS_AUDIO_CAPTIONS === 'object'
            ? runtimeScope.INFINITE_RAILS_AUDIO_CAPTIONS
            : scope?.INFINITE_RAILS_AUDIO_CAPTIONS) || null;
        if (!captions || typeof captions !== 'object') {
          return null;
        }
        if (requestedName && typeof captions[requestedName] === 'string') {
          return captions[requestedName];
        }
        if (resolvedName && typeof captions[resolvedName] === 'string') {
          return captions[resolvedName];
        }
        return null;
      };

      const announceCaption = (requestedName, resolvedName) => {
        const caption = getCaptionText(requestedName, resolvedName);
        const eventTarget =
          (runtimeScope && typeof runtimeScope.dispatchEvent === 'function' && runtimeScope) ||
          (scope && typeof scope.dispatchEvent === 'function' && scope) ||
          null;
        const EventCtor =
          (runtimeScope && typeof runtimeScope.CustomEvent === 'function' && runtimeScope.CustomEvent) ||
          (scope && typeof scope.CustomEvent === 'function' && scope.CustomEvent) ||
          (typeof CustomEvent === 'function' ? CustomEvent : null);
        if (!caption || !eventTarget || !EventCtor) {
          return;
        }
        const now = Date.now();
        if (caption === lastCaptionText && now - lastCaptionAt < 1200) {
          return;
        }
        lastCaptionText = caption;
        lastCaptionAt = now;
        try {
          eventTarget.dispatchEvent(
            new EventCtor('infinite-rails:audio-caption', {
              detail: {
                caption,
                name: requestedName || resolvedName || null,
                resolvedName: resolvedName || null,
                timestamp: now,
              },
            }),
          );
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Unable to dispatch audio caption event.', error);
          }
        }
      };

      const logAudioPlaybackIssue = (requestedName, resolvedName, info = {}) => {
        const fallbackName = resolvedName || requestedName || 'unknown sample';
        let message =
          typeof info?.message === 'string' && info.message.trim().length
            ? info.message.trim()
            : `Audio sample "${fallbackName}" failed to play.`;
        message = submitAudioFailure(resolvedName || requestedName || null, message, info?.error || null);
        const timestamp = Date.now();
        if (typeof console !== 'undefined' && typeof console.error === 'function') {
          if (info?.error) {
            console.error(message, info.error);
          } else {
            console.error(message);
          }
        }
        const eventTarget =
          (runtimeScope && typeof runtimeScope.dispatchEvent === 'function' && runtimeScope) ||
          (scope && typeof scope.dispatchEvent === 'function' && scope) ||
          null;
        const EventCtor =
          (runtimeScope && typeof runtimeScope.CustomEvent === 'function' && runtimeScope.CustomEvent) ||
          (scope && typeof scope.CustomEvent === 'function' && scope.CustomEvent) ||
          (typeof CustomEvent === 'function' ? CustomEvent : null);
        if (!eventTarget || !EventCtor) {
          return;
        }
        const detail = {
          message,
          requestedName: requestedName || null,
          resolvedName: resolvedName || null,
          code: typeof info?.code === 'string' ? info.code : 'playback-error',
          timestamp,
        };
        const missingSampleFlag =
          detail.code === 'missing-sample' || info?.missingSample === true;
        if (missingSampleFlag) {
          detail.missingSample = true;
          detail.fallbackActive = true;
        }
        if (info?.fallbackActive === true) {
          detail.fallbackActive = true;
        }
        if (info && typeof info.detail !== 'undefined') {
          detail.detail = info.detail;
        }
        const error = info?.error;
        if (error) {
          const errorMessage =
            typeof error === 'string'
              ? error
              : typeof error?.message === 'string'
              ? error.message
              : null;
          const errorName = typeof error?.name === 'string' ? error.name : null;
          const errorCode =
            typeof error === 'object' && error !== null && typeof error.code !== 'undefined'
              ? error.code
              : null;
          if (errorMessage) {
            detail.errorMessage = errorMessage;
          }
          if (errorName) {
            detail.errorName = errorName;
          }
          if (errorCode !== null) {
            detail.errorCode = errorCode;
          }
        }
        try {
          eventTarget.dispatchEvent(new EventCtor('infinite-rails:audio-error', { detail }));
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Unable to dispatch audio error event.', error);
          }
        }
        if (detail.code === 'missing-sample') {
          displayAudioFallbackOverlay(message, {
            code: detail.code,
            requestedName: detail.requestedName,
            resolvedName: detail.resolvedName,
            missingSample: true,
            fallbackActive: true,
            detail: info?.detail,
          });
        }
      };
      const bootMissingSampleList = Array.from(bootMissingSamples).sort();
      const affectedAliasList = aliasIntegrityIssues.map((issue) => issue.aliasName).sort();
      let bootStatusMessage = null;
      if (bootMissingSampleList.length || affectedAliasList.length) {
        const messageParts = [];
        if (bootMissingSampleList.length) {
          if (bootMissingSampleList.length === 1) {
            messageParts.push(`Missing audio sample "${bootMissingSampleList[0]}" detected during startup.`);
          } else {
            messageParts.push(
              `Missing audio samples detected during startup (${bootMissingSampleList.join(', ')}).`,
            );
          }
        } else {
          messageParts.push('Audio samples failed to initialise during startup.');
        }
        if (affectedAliasList.length) {
          if (affectedAliasList.length === 1) {
            messageParts.push(`Affected cue: ${affectedAliasList[0]}.`);
          } else {
            messageParts.push(`Affected cues: ${affectedAliasList.join(', ')}.`);
          }
        }
        messageParts.push('A fallback beep will be used until the audio files are restored.');
        const bootMessage = messageParts.join(' ');
        bootStatusMessage = ensureAudioFallbackMessage(bootMessage);
        logAudioPlaybackIssue(
          bootMissingSampleList[0] || affectedAliasList[0] || null,
          bootMissingSampleList[0] || null,
          {
            message: bootStatusMessage,
            code: 'boot-missing-sample',
            detail: {
              missingSamples: bootMissingSampleList,
              affectedAliases: affectedAliasList,
            },
          },
        );
      } else {
        bootStatusMessage = 'Audio initialised successfully.';
      }
      const bootEventTarget =
        (runtimeScope && typeof runtimeScope.dispatchEvent === 'function' && runtimeScope) ||
        (scope && typeof scope.dispatchEvent === 'function' && scope) ||
        null;
      const BootEventCtor =
        (runtimeScope && typeof runtimeScope.CustomEvent === 'function' && runtimeScope.CustomEvent) ||
        (scope && typeof scope.CustomEvent === 'function' && scope.CustomEvent) ||
        (typeof CustomEvent === 'function' ? CustomEvent : null);
      if (bootEventTarget && BootEventCtor) {
        const detail = {
          missingSamples: bootMissingSampleList,
          affectedAliases: affectedAliasList,
          fallbackActive: Boolean(bootMissingSampleList.length || affectedAliasList.length),
          message: bootStatusMessage,
          timestamp: Date.now(),
        };
        try {
          bootEventTarget.dispatchEvent(new BootEventCtor('infinite-rails:audio-boot-status', { detail }));
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Unable to dispatch audio boot status event.', error);
          }
        }
      }

      if (!useHowler && typeof AudioCtor !== 'function') {
        return {
          has: (name) => {
            const resolved = resolveAudioName(name);
            if (resolved) {
              return true;
            }
            const normalised = normaliseAudioName(name);
            return Boolean(normalised && knownPlayableNames.has(normalised));
          },
          play: () => {},
          playRandom: () => {},
          stopAll: () => {},
          setMasterVolume: () => {},
          getLoadedSampleCount: () => totalSamples,
          _resolve: (name) => {
            const resolved = resolveAudioName(name);
            return resolved;
          },
        };
      }

      const createAudioPlaybackWatchdog = (requestedName, resolvedName, options = {}) => {
        const getTimerScope = () => {
          if (typeof scope?.setTimeout === 'function') {
            return scope;
          }
          if (typeof globalThis !== 'undefined' && typeof globalThis.setTimeout === 'function') {
            return globalThis;
          }
          return null;
        };
        const timerScope = getTimerScope();
        let settled = false;
        let timerId = null;
        const onTimeout = typeof options?.onTimeout === 'function' ? options.onTimeout : null;
        const onSettle = typeof options?.onSettle === 'function' ? options.onSettle : null;
        const clearTimer = () => {
          if (timerId !== null && timerScope && typeof timerScope.clearTimeout === 'function') {
            timerScope.clearTimeout(timerId);
          }
          timerId = null;
        };
        const settle = () => {
          if (settled) {
            return false;
          }
          settled = true;
          clearTimer();
          if (onSettle) {
            try {
              onSettle();
            } catch (error) {
              if (typeof console !== 'undefined' && typeof console.debug === 'function') {
                console.debug('Audio watchdog settle callback failed.', error);
              }
            }
          }
          return true;
        };
        if (timerScope && typeof timerScope.setTimeout === 'function') {
          timerId = timerScope.setTimeout(() => {
            if (settled) {
              return;
            }
            settled = true;
            if (onTimeout) {
              try {
                onTimeout();
              } catch (error) {
                if (typeof console !== 'undefined' && typeof console.debug === 'function') {
                  console.debug('Audio watchdog timeout callback failed.', error);
                }
              }
            }
            if (onSettle) {
              try {
                onSettle();
              } catch (error) {
                if (typeof console !== 'undefined' && typeof console.debug === 'function') {
                  console.debug('Audio watchdog settle callback failed.', error);
                }
              }
            }
            logAudioPlaybackIssue(requestedName, resolvedName, {
              message: `Audio sample "${resolvedName || requestedName || 'unknown sample'}" failed to start within 1 second.`,
              code: 'playback-timeout',
            });
          }, 1000);
        }
        return {
          confirm() {
            settle();
          },
          fail(error, customMessage) {
            if (!settle()) {
              return;
            }
            logAudioPlaybackIssue(requestedName, resolvedName, {
              error,
              message:
                typeof customMessage === 'string' && customMessage.trim().length
                  ? customMessage
                  : `Audio sample "${resolvedName || requestedName || 'unknown sample'}" failed to play.`,
              code: 'playback-error',
            });
          },
        };
      };

      const resumeAudioContext = () => {
        const ctx = scope?.Howler?.ctx;
        const state = typeof ctx?.state === 'string' ? ctx.state : '';
        if (!ctx || state === 'running' || typeof ctx.resume !== 'function') {
          return;
        }
        try {
          const result = ctx.resume();
          if (result && typeof result.catch === 'function') {
            result.catch((error) => {
              if (typeof console !== 'undefined' && typeof console.debug === 'function') {
                console.debug('Audio context resume rejected.', error);
              }
            });
          }
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Audio context resume failed.', error);
          }
        }
      };

      const playInternal = (requestedName, resolvedName, options = {}) => {
        if (!resolvedName) {
          return;
        }
        const samplePayload = getSamplePayload(resolvedName);
        if (!samplePayload) {
          if (resolvedName !== fallbackAlertName) {
            logAudioPlaybackIssue(requestedName, resolvedName, {
              message: `Audio sample "${resolvedName}" could not be loaded.`,
              code: 'missing-sample',
            });
            playFallbackAlert(requestedName, options);
          }
          return;
        }
        resumeAudioContext();
        if (useHowler) {
          let howl = howlCache.get(resolvedName);
          if (!howl) {
            howl = new HowlCtor({
              src: [`data:audio/wav;base64,${samplePayload}`],
              volume: options.volume ?? 1,
              preload: true,
            });
            howlCache.set(resolvedName, howl);
          }
          if (options.volume !== undefined && typeof howl.volume === 'function') {
            howl.volume(options.volume);
          }
          if (options.rate !== undefined && typeof howl.rate === 'function') {
            howl.rate(options.rate);
          }
          if (options.loop !== undefined && typeof howl.loop === 'function') {
            howl.loop(Boolean(options.loop));
          }
          let onPlay;
          let onPlayError;
          let onLoadError;
          const detachWatchers = () => {
            if (typeof howl?.off !== 'function') {
              return;
            }
            if (typeof onPlay === 'function') {
              howl.off('play', onPlay);
            }
            if (typeof onPlayError === 'function') {
              howl.off('playerror', onPlayError);
            }
            if (typeof onLoadError === 'function') {
              howl.off('loaderror', onLoadError);
            }
          };
          const watchdog = createAudioPlaybackWatchdog(requestedName, resolvedName, {
            onTimeout: detachWatchers,
            onSettle: detachWatchers,
          });
          let soundId;
          try {
            soundId = howl.play();
          } catch (error) {
            watchdog.fail(error, `Audio sample "${resolvedName}" failed to play.`);
            return;
          }
          if (soundId === null || typeof soundId === 'undefined') {
            watchdog.fail(null, `Audio sample "${resolvedName}" failed to start playback.`);
            return;
          }
          onPlay = (id) => {
            if (id !== soundId) {
              return;
            }
            watchdog.confirm();
            detachWatchers();
          };
          onPlayError = (id, error) => {
            if (id !== soundId) {
              return;
            }
            watchdog.fail(error, `Audio sample "${resolvedName}" failed to play.`);
            detachWatchers();
          };
          onLoadError = (id, error) => {
            if (id !== null && id !== soundId) {
              return;
            }
            watchdog.fail(error, `Audio sample "${resolvedName}" failed to load.`);
            detachWatchers();
          };
          if (typeof howl?.on === 'function' && typeof howl?.off === 'function') {
            howl.on('play', onPlay);
            howl.on('playerror', onPlayError);
            howl.on('loaderror', onLoadError);
          } else {
            try {
              if (typeof howl?.playing === 'function' && howl.playing(soundId)) {
                watchdog.confirm();
              }
            } catch (error) {
              if (typeof console !== 'undefined' && typeof console.debug === 'function') {
                console.debug('Unable to inspect Howler playback state.', error);
              }
            }
          }
        } else {
          const baseVolume = options.volume !== undefined ? clampVolume(options.volume) : 1;
          const src = `data:audio/wav;base64,${samplePayload}`;
          const instance = new AudioCtor(src);
          instance.preload = 'auto';
          instance.loop = Boolean(options.loop);
          if (options.rate !== undefined && Number.isFinite(options.rate)) {
            try {
              instance.playbackRate = Math.max(0.5, Math.min(4, options.rate));
            } catch (error) {
              if (typeof console !== 'undefined' && typeof console.debug === 'function') {
                console.debug('Unable to apply playback rate to audio element.', error);
              }
            }
          }
          applyMasterVolume(instance, baseVolume);
          let cleanup = () => {
            fallbackPlaying.delete(instance);
          };
          const watchdog = createAudioPlaybackWatchdog(requestedName, resolvedName, {
            onTimeout: () => {
              cleanup();
            },
          });
          const detachStartListeners = () => {
            instance.removeEventListener('play', onPlaybackStarted);
            instance.removeEventListener('playing', onPlaybackStarted);
            instance.removeEventListener('canplay', onPlaybackStarted);
            instance.removeEventListener('canplaythrough', onPlaybackStarted);
          };
          const onPlaybackStarted = () => {
            watchdog.confirm();
            detachStartListeners();
          };
          const onPlaybackEnded = () => {
            watchdog.confirm();
            cleanup();
          };
          const onPlaybackError = (event) => {
            const error = event?.error || instance?.error || null;
            watchdog.fail(error, `Audio sample "${resolvedName}" encountered a playback error.`);
            cleanup();
          };
          cleanup = () => {
            fallbackPlaying.delete(instance);
            instance.removeEventListener('ended', onPlaybackEnded);
            instance.removeEventListener('error', onPlaybackError);
            detachStartListeners();
          };
          instance.addEventListener('play', onPlaybackStarted);
          instance.addEventListener('playing', onPlaybackStarted);
          instance.addEventListener('canplay', onPlaybackStarted);
          instance.addEventListener('canplaythrough', onPlaybackStarted);
          instance.addEventListener('ended', onPlaybackEnded);
          instance.addEventListener('error', onPlaybackError);
          fallbackPlaying.set(instance, baseVolume);
          let playPromise;
          try {
            playPromise = instance.play();
          } catch (error) {
            fallbackPlaying.delete(instance);
            watchdog.fail(error, `Audio sample "${resolvedName}" failed to play.`);
            cleanup();
            return;
          }
          if (playPromise && typeof playPromise.catch === 'function') {
            playPromise.catch((error) => {
              fallbackPlaying.delete(instance);
              watchdog.fail(error, `Audio sample "${resolvedName}" failed to play.`);
              cleanup();
            });
          }
          if (playPromise && typeof playPromise.then === 'function') {
            playPromise.then(() => {
              watchdog.confirm();
            });
          }
        }
        announceCaption(requestedName, resolvedName);
        if (
          requestedName &&
          requestedName !== resolvedName &&
          !aliasNotified.has(requestedName) &&
          typeof console !== 'undefined' &&
          typeof console.debug === 'function'
        ) {
          console.debug(
            `Audio sample "${requestedName}" unavailable — falling back to "${resolvedName}".`,
          );
          aliasNotified.add(requestedName);
        }
      };
      const playFallbackAlert = (requestedName, options = {}) => {
        const fallbackOptions = Object.assign({}, options);
        if (fallbackOptions.volume === undefined) {
          fallbackOptions.volume = 0.7;
        }
        const nameForLog = typeof requestedName === 'string' && requestedName.trim().length ? requestedName : null;
        if (nameForLog) {
          ensureKnownPlayableName(nameForLog);
        }
        if (nameForLog && !missingSampleNotified.has(nameForLog)) {
          logAudioPlaybackIssue(nameForLog, null, {
            message: `Audio sample "${nameForLog}" is unavailable. Playing fallback beep instead.`,
            code: 'missing-sample',
          });
          missingSampleNotified.add(nameForLog);
        }
        playInternal(nameForLog, fallbackAlertName, fallbackOptions);
      };
      const controller = {
        has(name) {
          const resolved = resolveAudioName(name);
          if (resolved) {
            return true;
          }
          const normalised = normaliseAudioName(name);
          return Boolean(normalised && knownPlayableNames.has(normalised));
        },
        play(name, options = {}) {
          const resolved = resolveAudioName(name);
          if (!resolved) {
            playFallbackAlert(name, options);
            return;
          }
          playInternal(name, resolved, options);
        },
        playRandom(names = [], options = {}) {
          const pool = [];
          names.forEach((name) => {
            const resolved = resolveAudioName(name);
            if (resolved) {
              pool.push({ requested: name, resolved });
            }
          });
          if (!pool.length) {
            const first = Array.isArray(names) && names.length ? names[0] : null;
            playFallbackAlert(first, options);
            return;
          }
          const choice = pool[Math.floor(Math.random() * pool.length)];
          playInternal(choice.requested, choice.resolved, options);
        },
        stopAll() {
          if (useHowler) {
            howlCache.forEach((howl) => howl.stop?.());
            if (scope?.Howler?.stop) {
              scope.Howler.stop();
            }
            return;
          }
          Array.from(fallbackPlaying.keys()).forEach((audio) => {
            audio.pause();
            try {
              audio.currentTime = 0;
            } catch (error) {
              if (typeof console !== 'undefined' && typeof console.debug === 'function') {
                console.debug('Unable to reset audio element state.', error);
              }
            }
            fallbackPlaying.delete(audio);
          });
        },
        setMasterVolume(volume) {
          masterVolume = clampVolume(volume);
          if (useHowler) {
            if (scope?.Howler?.volume) {
              scope.Howler.volume(masterVolume);
            }
            return;
          }
          fallbackPlaying.forEach((baseVolume, audio) => applyMasterVolume(audio, baseVolume));
        },
        getLoadedSampleCount() {
          return totalSamples;
        },
        resumeContextIfNeeded() {
          resumeAudioContext();
        },
        _resolve(name) {
          // Exposed for debugging and automated tests.
          return resolveAudioName(name);
        },
      };
      return controller;
    }

    initializeMobileControls() {
      if (!this.mobileControlsRoot) {
        return;
      }
      const controls = this.mobileControlsRoot;
      const controlsVerified = this.verifyMobileControlsDom();
      if (!controlsVerified) {
        this.teardownMobileControls();
        controls.dataset.active = 'false';
        setElementHidden(controls, true);
        this.mobileControlsActive = false;
        this.updatePointerHintForInputMode();
        this.refreshFirstRunTutorialContent();
        return;
      }
      const shouldActivate = Boolean(this.isTouchPreferred);
      if (shouldActivate === this.mobileControlsActive) {
        setElementHidden(controls, !shouldActivate);
        controls.dataset.active = shouldActivate ? 'true' : 'false';
        if (!shouldActivate) {
          this.updatePointerHintForInputMode();
        }
        this.refreshFirstRunTutorialContent();
        return;
      }
      this.teardownMobileControls();
      setElementHidden(controls, !shouldActivate);
      controls.dataset.active = shouldActivate ? 'true' : 'false';
      if (!shouldActivate) {
        this.updatePointerHintForInputMode();
        this.refreshFirstRunTutorialContent();
        return;
      }
      this.hidePointerHint(true);
      const blockDefault = (event) => event.preventDefault();
      controls.addEventListener('contextmenu', blockDefault);
      this.mobileControlDisposers.push(() => controls.removeEventListener('contextmenu', blockDefault));

      const directionButtons = controls.querySelectorAll(
        'button[data-action="up"], button[data-action="down"], button[data-action="left"], button[data-action="right"]'
      );
      directionButtons.forEach((button) => {
        button.addEventListener('pointerdown', this.onTouchButtonPress, { passive: false });
        button.addEventListener('pointerup', this.onTouchButtonRelease);
        button.addEventListener('pointercancel', this.onTouchButtonRelease);
        button.addEventListener('lostpointercapture', this.onTouchButtonRelease);
        button.addEventListener('click', blockDefault);
        this.mobileControlDisposers.push(() => {
          button.removeEventListener('pointerdown', this.onTouchButtonPress);
          button.removeEventListener('pointerup', this.onTouchButtonRelease);
          button.removeEventListener('pointercancel', this.onTouchButtonRelease);
          button.removeEventListener('lostpointercapture', this.onTouchButtonRelease);
          button.removeEventListener('click', blockDefault);
        });
      });

      const actionButton = controls.querySelector('button[data-action="action"]');
      if (actionButton) {
        const handlePointerDown = (event) => {
          event.preventDefault();
          this.markInteraction();
          this.touchActionPending = true;
          this.touchActionStart = performance.now();
        };
        const handlePointerUp = (event) => {
          event.preventDefault();
          this.markInteraction();
          if (!this.touchActionPending) {
            return;
          }
          this.touchActionPending = false;
          const duration = performance.now() - this.touchActionStart;
          if (duration > 260) {
            this.touchJumpRequested = true;
          } else {
            this.mineBlock();
          }
        };
        const handlePointerCancel = () => {
          this.markInteraction();
          this.touchActionPending = false;
        };
        actionButton.addEventListener('pointerdown', handlePointerDown, { passive: false });
        actionButton.addEventListener('pointerup', handlePointerUp);
        actionButton.addEventListener('pointercancel', handlePointerCancel);
        actionButton.addEventListener('click', blockDefault);
        this.mobileControlDisposers.push(() => {
          actionButton.removeEventListener('pointerdown', handlePointerDown);
          actionButton.removeEventListener('pointerup', handlePointerUp);
          actionButton.removeEventListener('pointercancel', handlePointerCancel);
          actionButton.removeEventListener('click', blockDefault);
        });
      }

      const portalButton = controls.querySelector('button[data-action="portal"]');
      if (portalButton) {
        const markPortalInteraction = () => this.markInteraction();
        portalButton.addEventListener('click', this.onPortalButton);
        portalButton.addEventListener('pointerdown', blockDefault, { passive: false });
        portalButton.addEventListener('pointerdown', markPortalInteraction);
        this.mobileControlDisposers.push(() => {
          portalButton.removeEventListener('click', this.onPortalButton);
          portalButton.removeEventListener('pointerdown', blockDefault);
          portalButton.removeEventListener('pointerdown', markPortalInteraction);
        });
      }

      if (this.virtualJoystickEl) {
        this.virtualJoystickEl.addEventListener('pointerdown', this.onJoystickPointerDown, { passive: false });
        window.addEventListener('pointermove', this.onJoystickPointerMove, { passive: false });
        window.addEventListener('pointerup', this.onJoystickPointerUp);
        window.addEventListener('pointercancel', this.onJoystickPointerUp);
        this.mobileControlDisposers.push(() => {
          this.virtualJoystickEl.removeEventListener('pointerdown', this.onJoystickPointerDown);
          window.removeEventListener('pointermove', this.onJoystickPointerMove);
          window.removeEventListener('pointerup', this.onJoystickPointerUp);
          window.removeEventListener('pointercancel', this.onJoystickPointerUp);
        });
      }
      this.mobileControlsActive = true;
      this.refreshFirstRunTutorialContent();
    }

    verifyMobileControlsDom() {
      const controls = this.mobileControlsRoot;
      if (!controls) {
        return false;
      }
      if (!this.virtualJoystickEl && typeof controls.querySelector === 'function') {
        const fallbackJoystick = controls.querySelector('.virtual-joystick');
        if (fallbackJoystick) {
          this.virtualJoystickEl = fallbackJoystick;
        }
      }
      if (!this.virtualJoystickThumb && this.virtualJoystickEl?.querySelector) {
        const thumb = this.virtualJoystickEl.querySelector('.virtual-joystick__thumb');
        if (thumb) {
          this.virtualJoystickThumb = thumb;
        }
      }
      let buttonCount = 0;
      if (typeof controls.querySelectorAll === 'function') {
        try {
          const buttons = controls.querySelectorAll('button[data-action]');
          if (Array.isArray(buttons)) {
            buttonCount = buttons.length;
          } else if (buttons && typeof buttons.length === 'number') {
            buttonCount = buttons.length;
          } else if (buttons && typeof buttons[Symbol.iterator] === 'function') {
            buttonCount = Array.from(buttons).length;
          }
        } catch (error) {
          if (typeof console !== 'undefined') {
            console.warn('Failed to inspect mobile control buttons.', error);
          }
          buttonCount = 0;
        }
      }
      const joystickReady = Boolean(this.virtualJoystickEl);
      const verified = joystickReady && buttonCount > 0;
      controls.dataset.ready = verified ? 'true' : 'false';
      if (!verified && typeof console !== 'undefined') {
        console.warn('Mobile controls unavailable — virtual joystick or buttons missing.');
      }
      return verified;
    }

    attachPointerPreferenceObserver() {
      if (this.detachPointerPreferenceObserver || typeof window === 'undefined') {
        return;
      }
      if (typeof window.matchMedia !== 'function') {
        return;
      }
      try {
        const query = window.matchMedia('(pointer: coarse)');
        this.pointerPreferenceObserver = query;
        const handler = this.onPointerPreferenceChange;
        if (typeof query.addEventListener === 'function') {
          query.addEventListener('change', handler);
          this.detachPointerPreferenceObserver = () => {
            try {
              query.removeEventListener('change', handler);
            } catch (error) {
              console.debug('Unable to detach coarse pointer listener', error);
            }
            this.detachPointerPreferenceObserver = null;
          };
        } else if (typeof query.addListener === 'function') {
          query.addListener(handler);
          this.detachPointerPreferenceObserver = () => {
            try {
              query.removeListener(handler);
            } catch (error) {
              console.debug('Unable to detach coarse pointer listener', error);
            }
            this.detachPointerPreferenceObserver = null;
          };
        }
      } catch (error) {
        console.debug('Unable to observe pointer preference changes', error);
        this.pointerPreferenceObserver = null;
        this.detachPointerPreferenceObserver = null;
      }
    }

    handlePointerPreferenceChange(event) {
      const prefersTouch = Boolean(event?.matches) || this.detectTouchPreferred();
      if (prefersTouch !== this.isTouchPreferred) {
        this.isTouchPreferred = prefersTouch;
      }
      if (prefersTouch !== this.mobileControlsActive) {
        this.initializeMobileControls();
      }
      this.refreshFirstRunTutorialContent();
    }

    getPointerInputTargets() {
      const targets = [];
      if (this.canvas) {
        targets.push(this.canvas);
      }
      const doc =
        this.canvas?.ownerDocument ||
        (typeof document !== 'undefined' ? document : null);
      if (!doc || typeof doc.querySelectorAll !== 'function') {
        return targets;
      }
      let canvases = [];
      try {
        const nodeList = doc.querySelectorAll('canvas');
        if (Array.isArray(nodeList)) {
          canvases = nodeList.slice();
        } else if (nodeList && typeof nodeList.length === 'number') {
          canvases = Array.from(nodeList);
        } else if (nodeList && typeof nodeList[Symbol.iterator] === 'function') {
          canvases = Array.from(nodeList);
        }
      } catch (error) {
        canvases = [];
      }
      if (!canvases.length) {
        return targets;
      }
      const view = doc.defaultView || (typeof window !== 'undefined' ? window : null);
      const getStyle = typeof view?.getComputedStyle === 'function' ? (element) => view.getComputedStyle(element) : null;
      let topmost = null;
      let bestScore = -Infinity;
      canvases.forEach((element, index) => {
        if (!element) {
          return;
        }
        if (getStyle) {
          const style = getStyle(element);
          if (!style) {
            return;
          }
          if (style.display === 'none' || style.visibility === 'hidden' || style.pointerEvents === 'none') {
            return;
          }
          const zIndex = Number.parseFloat(style.zIndex);
          const zScore = Number.isFinite(zIndex) ? zIndex : 0;
          const positionScore = style.position !== 'static' ? 1 : 0;
          const orderScore = index / 1000;
          const score = zScore * 100 + positionScore * 10 + orderScore;
          if (score >= bestScore) {
            bestScore = score;
            topmost = element;
          }
        } else {
          topmost = element;
        }
      });
      if (!topmost && canvases.length) {
        topmost = canvases[canvases.length - 1];
      }
      if (topmost && !targets.includes(topmost)) {
        targets.push(topmost);
      }
      return targets;
    }

    handleGlobalPointerDown(event) {
      if (!event) {
        return;
      }
      const type = event.pointerType || '';
      if (type !== 'touch' && type !== 'pen') {
        return;
      }
      if (!this.isTouchPreferred) {
        this.isTouchPreferred = true;
      }
      if (!this.mobileControlsActive) {
        this.initializeMobileControls();
      }
      this.refreshFirstRunTutorialContent();
    }

    handleGlobalTouchStart() {
      if (!this.isTouchPreferred) {
        this.isTouchPreferred = true;
      }
      if (!this.mobileControlsActive) {
        this.initializeMobileControls();
      }
      this.refreshFirstRunTutorialContent();
    }

    teardownMobileControls() {
      if (this.mobileControlDisposers.length) {
        this.mobileControlDisposers.forEach((dispose) => {
          try {
            dispose();
          } catch (error) {
            console.warn('Failed to remove mobile control handler', error);
          }
        });
      }
      this.mobileControlDisposers = [];
      this.touchButtonStates.up = false;
      this.touchButtonStates.down = false;
      this.touchButtonStates.left = false;
      this.touchButtonStates.right = false;
      this.touchActionPending = false;
      this.touchJumpRequested = false;
      this.resetJoystick();
      if (this.mobileControlsRoot) {
        this.mobileControlsRoot.dataset.active = 'false';
        setElementHidden(this.mobileControlsRoot, true);
      }
      this.mobileControlsActive = false;
      this.updatePointerHintForInputMode();
    }

    resetJoystick() {
      this.joystickPointerId = null;
      this.joystickVector.set(0, 0);
      this.joystickMovementEngaged = false;
      if (this.virtualJoystickThumb) {
        this.virtualJoystickThumb.style.transform = 'translate(0px, 0px)';
      }
      this.refreshHudInteractionState();
    }

    handleJoystickPointerDown(event) {
      if (event.pointerType && event.pointerType !== 'touch' && event.pointerType !== 'pen') {
        return;
      }
      event.preventDefault();
      this.markInteraction();
      this.joystickPointerId = event.pointerId ?? 'touch';
      this.updateJoystickFromPointer(event);
      this.virtualJoystickEl?.setPointerCapture?.(event.pointerId ?? 0);
    }

    handleJoystickPointerMove(event) {
      if (this.joystickPointerId === null) return;
      if (event.pointerId !== undefined && event.pointerId !== this.joystickPointerId) return;
      if (event.pointerType && event.pointerType !== 'touch' && event.pointerType !== 'pen') return;
      event.preventDefault();
      this.markInteraction();
      this.updateJoystickFromPointer(event);
    }

    handleJoystickPointerUp(event) {
      if (this.joystickPointerId === null) return;
      if (event.pointerId !== undefined && event.pointerId !== this.joystickPointerId) return;
      event.preventDefault();
      this.markInteraction();
      this.virtualJoystickEl?.releasePointerCapture?.(event.pointerId ?? 0);
      this.resetJoystick();
    }

    updateJoystickFromPointer(event) {
      if (!this.virtualJoystickEl) return;
      const rect = this.virtualJoystickEl.getBoundingClientRect();
      const radius = rect.width / 2;
      if (radius <= 0) return;
      const centerX = rect.left + radius;
      const centerY = rect.top + radius;
      const dx = event.clientX - centerX;
      const dy = event.clientY - centerY;
      const distance = Math.min(Math.sqrt(dx * dx + dy * dy), radius);
      const angle = Math.atan2(dy, dx);
      const limitedX = Math.cos(angle) * distance;
      const limitedY = Math.sin(angle) * distance;
      const normalisedX = limitedX / radius;
      const normalisedY = limitedY / radius;
      this.joystickVector.set(normalisedX, normalisedY);
      if (this.virtualJoystickThumb) {
        const thumbRadius = radius * 0.65;
        const thumbX = normalisedX * thumbRadius;
        const thumbY = normalisedY * thumbRadius;
        this.virtualJoystickThumb.style.transform = `translate(${thumbX.toFixed(1)}px, ${thumbY.toFixed(1)}px)`;
      }
      const magnitudeSq =
        typeof this.joystickVector.lengthSq === 'function'
          ? this.joystickVector.lengthSq()
          : this.joystickVector.x * this.joystickVector.x + this.joystickVector.y * this.joystickVector.y;
      if (Number.isFinite(magnitudeSq)) {
        if (magnitudeSq > 0.01 && !this.joystickMovementEngaged) {
          this.handleMovementInputDetected('virtual-joystick', { source: 'virtual-joystick' });
          this.joystickMovementEngaged = true;
        } else if (magnitudeSq <= 0.0025) {
          this.joystickMovementEngaged = false;
        }
      }
    }

    handleTouchButtonPress(event) {
      if (event.pointerType && event.pointerType !== 'touch' && event.pointerType !== 'pen') {
        return;
      }
      event.preventDefault();
      this.markInteraction();
      const button = event.currentTarget;
      if (!button) return;
      button.setPointerCapture?.(event.pointerId ?? 0);
      const action = button.dataset?.action;
      if (!action) return;
      if (action === 'up' || action === 'down' || action === 'left' || action === 'right') {
        this.touchButtonStates[action] = true;
        const actionMap = {
          up: 'moveForward',
          down: 'moveBackward',
          left: 'moveLeft',
          right: 'moveRight',
        };
        const mappedAction = actionMap[action];
        if (mappedAction) {
          this.handleMovementInputDetected(mappedAction, { source: 'touch-button' });
        }
      }
    }

    handleTouchButtonRelease(event) {
      const button = event.currentTarget;
      if (!button) return;
      const action = button.dataset?.action;
      if (!action) return;
      this.markInteraction();
      if (action === 'up' || action === 'down' || action === 'left' || action === 'right') {
        this.touchButtonStates[action] = false;
      }
      this.refreshHudInteractionState();
    }

    handlePortalButton(event) {
      event.preventDefault();
      this.markInteraction();
      if (this.tryOpenNearbyChest()) {
        return;
      }
      if (this.portalActivated && this.isPlayerNearPortal()) {
        this.advanceDimension();
        return;
      }
      if (this.portalReady && this.isPlayerNearPortalFrame()) {
        this.ignitePortal('torch');
        return;
      }
      this.placeBlock();
    }

    handleTouchLookPointerDown(event) {
      if (event.pointerType !== 'touch') {
        return;
      }
      if (this.mobileControlsRoot?.contains(event.target)) {
        return;
      }
      event.preventDefault();
      this.markInteraction();
      this.touchLookPointerId = event.pointerId;
      this.touchLookLast = { x: event.clientX, y: event.clientY };
    }

    handleTouchLookPointerMove(event) {
      if (event.pointerType !== 'touch') {
        return;
      }
      if (this.touchLookPointerId !== event.pointerId) {
        return;
      }
      event.preventDefault();
      this.markInteraction();
      if (!this.touchLookLast) {
        this.touchLookLast = { x: event.clientX, y: event.clientY };
        return;
      }
      const dx = event.clientX - this.touchLookLast.x;
      const dy = event.clientY - this.touchLookLast.y;
      this.touchLookLast = { x: event.clientX, y: event.clientY };
      this.yaw -= dx * POINTER_SENSITIVITY * 0.9;
      this.pitch -= dy * POINTER_SENSITIVITY * 0.9;
      const maxPitch = Math.PI / 2 - 0.01;
      this.pitch = Math.max(-maxPitch, Math.min(maxPitch, this.pitch));
    }

    handleTouchLookPointerUp(event) {
      if (event.pointerType !== 'touch') {
        return;
      }
      if (this.touchLookPointerId !== event.pointerId) {
        return;
      }
      this.markInteraction();
      this.touchLookPointerId = null;
      this.touchLookLast = null;
      this.refreshHudInteractionState();
    }

    applyTextureAnisotropy() {
      if (!this.renderer) return;
      const anisotropy = this.renderer.capabilities?.getMaxAnisotropy?.() ?? 1;
      Object.values(this.materials).forEach((material) => {
        if (material?.map) {
          material.map.anisotropy = anisotropy;
          material.map.needsUpdate = true;
        }
      });
    }

    createFirstPersonHands() {
      const THREE = this.THREE;
      if (!THREE || !this.camera) return;
      const cameraHolder = this.cameraBoom || this.playerRig;
      if (cameraHolder && this.camera.parent !== cameraHolder) {
        this.camera.parent?.remove(this.camera);
        cameraHolder.add(this.camera);
      }

      if (this.handGroup) {
        this.disposeEquippedItemModel();
        this.camera.remove(this.handGroup);
      }
      this.handItemAnchor = null;
      this.leftHandGroup = null;
      this.rightHandGroup = null;

      this.handGroup = new THREE.Group();
      this.handGroup.position.set(0.42, -0.46, -0.8);
      this.handGroup.rotation.set(-0.55, 0, 0);
      this.handMaterials = [];
      this.handMaterialsDynamic = true;
      this.handModelLoaded = false;

      const handGeometry = new THREE.BoxGeometry(0.24, 0.46, 0.24);
      const sleeveGeometry = new THREE.BoxGeometry(0.26, 0.22, 0.26);
      const baseMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color('#82c7ff'),
        metalness: 0.1,
        roughness: 0.55,
      });
      const sleeveMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color('#2563eb'),
        metalness: 0.05,
        roughness: 0.75,
      });

      const createHand = (side) => {
        const hand = new THREE.Group();
        const palm = new THREE.Mesh(handGeometry, baseMaterial.clone());
        palm.castShadow = true;
        palm.receiveShadow = true;
        palm.position.set(0, -0.1, 0);
        const sleeve = new THREE.Mesh(sleeveGeometry, sleeveMaterial.clone());
        sleeve.castShadow = false;
        sleeve.receiveShadow = true;
        sleeve.position.set(0, 0.2, 0);
        hand.add(sleeve);
        hand.add(palm);
        hand.position.set(side * 0.32, 0, 0);
        hand.rotation.z = side * -0.12;
        return { group: hand, palm, sleeve };
      };

      const left = createHand(-1);
      const right = createHand(1);
      this.handGroup.add(left.group);
      this.handGroup.add(right.group);
      this.leftHandGroup = left.group;
      this.rightHandGroup = right.group;
      this.camera.add(this.handGroup);
      this.handMaterials = [left.palm.material, right.palm.material, left.sleeve.material, right.sleeve.material];
      this.ensureHandItemAnchor();
      const equipped = this.equippedItemId || this.pendingEquippedItemId;
      if (equipped) {
        this.attachEquippedItemModel(equipped);
      } else {
        this.attachEquippedItemModel(null);
      }
      this.ensurePlayerArmsVisible();
    }

    markInteraction() {
      const now = typeof performance !== 'undefined' ? performance.now() : Date.now();
      this.lastInteractionTimeMs = now;
      if (this.audio && typeof this.audio.resumeContextIfNeeded === 'function') {
        try {
          this.audio.resumeContextIfNeeded();
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Audio context resume threw during interaction.', error);
          }
        }
      }
      this.setHudInteractionState(true, { timeoutMs: HUD_INTERACTION_TIMEOUT_MS });
    }

    isPlayerInteracting() {
      if (!this.started) {
        return false;
      }
      if (this.pointerLocked) {
        return true;
      }
      if (this.pointerLockFallbackActive) {
        if (this.pointerFallbackDragging) {
          return true;
        }
        if (this.pointerFallbackButton !== null) {
          return true;
        }
      }
      if (this.keys?.size) {
        return true;
      }
      if (this.touchLookPointerId !== null) {
        return true;
      }
      if (this.joystickPointerId !== null) {
        return true;
      }
      if (this.joystickVector?.lengthSq && this.joystickVector.lengthSq() > 0.0001) {
        return true;
      }
      const touchStates = this.touchButtonStates;
      if (touchStates && (touchStates.up || touchStates.down || touchStates.left || touchStates.right)) {
        return true;
      }
      return false;
    }

    clearHudInteractionTimer() {
      if (!this.hudInteractionTimeout) {
        return;
      }
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      const clearTimer =
        scope && typeof scope.clearTimeout === 'function'
          ? scope.clearTimeout.bind(scope)
          : typeof clearTimeout === 'function'
            ? clearTimeout
            : null;
      if (typeof clearTimer === 'function') {
        clearTimer(this.hudInteractionTimeout);
      }
      this.hudInteractionTimeout = null;
    }

    setHudInteractionState(active, options = {}) {
      const doc = typeof document !== 'undefined' ? document : null;
      const body = doc?.body || null;
      if (!body) {
        return;
      }
      this.clearHudInteractionTimer();
      if (active) {
        if (!this.hudInteractionActive) {
          body.classList.add('hud-inactive');
          this.hudInteractionActive = true;
        }
        let timeout = options?.timeoutMs;
        if (timeout === undefined || timeout === null) {
          timeout = HUD_INTERACTION_TIMEOUT_MS;
        }
        if (Number.isFinite(timeout) && timeout > 0) {
          const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
          const setTimer =
            scope && typeof scope.setTimeout === 'function'
              ? scope.setTimeout.bind(scope)
              : typeof setTimeout === 'function'
                ? setTimeout
                : null;
          if (typeof setTimer === 'function') {
            this.hudInteractionTimeout = setTimer(() => {
              this.hudInteractionTimeout = null;
              this.setHudInteractionState(false, { source: 'timeout' });
            }, timeout);
          }
        }
        return;
      }
      if (this.isPlayerInteracting()) {
        if (!this.hudInteractionActive) {
          body.classList.add('hud-inactive');
          this.hudInteractionActive = true;
        }
        return;
      }
      if (this.hudInteractionActive) {
        body.classList.remove('hud-inactive');
        this.hudInteractionActive = false;
      }
    }

    refreshHudInteractionState(options = {}) {
      if (this.isPlayerInteracting()) {
        const timeout =
          options && Number.isFinite(options.timeoutMs) ? options.timeoutMs : 0;
        this.setHudInteractionState(true, { timeoutMs: timeout });
        return;
      }
      if (options?.immediate) {
        this.setHudInteractionState(false);
      }
    }

    markGuidanceProgress(reason = 'interaction') {
      const now = this.getHighResTimestamp();
      this.lostGuidanceLastProgressAt = now;
      this.lostGuidanceDismissedUntilProgress = false;
      if (this.lostGuidanceVisible) {
        this.hideLostGuidance({ reason: reason || 'progress' });
      }
    }

    isSceneActive() {
      if (!this.started) {
        return false;
      }
      if (this.pointerLocked) {
        return true;
      }
      if (this.keys?.size) {
        return true;
      }
      if (this.touchLookPointerId !== null) {
        return true;
      }
      if (this.playerActionAnimation) {
        return true;
      }
      if (this.joystickPointerId !== null) {
        return true;
      }
      if (this.touchButtonStates) {
        if (this.touchButtonStates.up || this.touchButtonStates.down || this.touchButtonStates.left || this.touchButtonStates.right) {
          return true;
        }
      }
      if (this.cameraShakeIntensity > 0 && this.cameraShakeTime < this.cameraShakeDuration) {
        return true;
      }
      if (this.velocity?.lengthSq?.() > 0.0001) {
        return true;
      }
      if (Math.abs(this.verticalVelocity ?? 0) > 0.0001) {
        return true;
      }
      if (Array.isArray(this.zombies) && this.zombies.length > 0) {
        return true;
      }
      if (Array.isArray(this.golems) && this.golems.length > 0) {
        return true;
      }
      return false;
    }

    isRenderIdle() {
      const now = typeof performance !== 'undefined' ? performance.now() : Date.now();
      const idleSeconds = (now - (this.lastInteractionTimeMs ?? now)) / 1000;
      if (idleSeconds < this.renderIdleThresholdSeconds) {
        return false;
      }
      return !this.isSceneActive();
    }

    queueCharacterPreload() {
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      if (!scope) {
        if (this.started && !this.rendererUnavailable) {
          this.preloadCharacterModels();
        }
        return;
      }
      this.cancelQueuedModelPreload();
      const executePreload = () => {
        this.modelPreloadHandle = null;
        this.modelPreloadUsingIdle = false;
        if (!this.started || this.rendererUnavailable) {
          return;
        }
        this.preloadCharacterModels();
      };
      if (typeof scope.requestIdleCallback === 'function') {
        this.modelPreloadUsingIdle = true;
        this.modelPreloadHandle = scope.requestIdleCallback(executePreload, {
          timeout: Math.max(500, Math.min(4000, this.assetLoadBudgetMs || 1500)),
        });
        return;
      }
      if (typeof scope.setTimeout === 'function') {
        this.modelPreloadUsingIdle = false;
        this.modelPreloadHandle = scope.setTimeout(executePreload, 0);
        return;
      }
      executePreload();
    }

    cancelQueuedModelPreload() {
      this.cancelLazyModelWarmup();
      if (this.modelPreloadHandle === null) {
        this.modelPreloadUsingIdle = false;
        return;
      }
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      if (scope) {
        if (this.modelPreloadUsingIdle && typeof scope.cancelIdleCallback === 'function') {
          scope.cancelIdleCallback(this.modelPreloadHandle);
        } else if (typeof scope.clearTimeout === 'function') {
          scope.clearTimeout(this.modelPreloadHandle);
        }
      }
      this.modelPreloadHandle = null;
      this.modelPreloadUsingIdle = false;
    }

    cancelLazyModelWarmup() {
      if (this.lazyModelWarmupHandle !== null) {
        const scope =
          typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
        if (scope && typeof scope.clearTimeout === 'function') {
          scope.clearTimeout(this.lazyModelWarmupHandle);
        }
        this.lazyModelWarmupHandle = null;
      }
      this.lazyModelWarmupQueue = [];
    }

    preloadCharacterModels() {
      const eagerKeys = this.lazyAssetLoading ? [] : ['arm', 'steve', 'zombie', 'golem'];
      eagerKeys.forEach((key) => {
        if (!key) return;
        if (this.loadedModels.has(key) || this.modelPromises.has(key)) {
          return;
        }
        this.loadModel(key).catch((error) => {
          this.handleAssetLoadFailure(key, error);
        });
      });
      if (this.lazyAssetLoading) {
        this.enqueueLazyModelWarmup(['steve', 'arm', 'zombie', 'golem']);
      }
    }

    enqueueLazyModelWarmup(keys = []) {
      if (!Array.isArray(keys) || !keys.length) {
        return;
      }
      const pending = keys
        .map((key) => `${key || ''}`.trim())
        .filter((key) => key && !this.loadedModels.has(key) && !this.modelPromises.has(key));
      if (!pending.length) {
        return;
      }
      const merged = new Set(this.lazyModelWarmupQueue);
      pending.forEach((key) => merged.add(key));
      this.lazyModelWarmupQueue = Array.from(merged);
      this.scheduleLazyModelWarmup();
    }

    scheduleLazyModelWarmup() {
      if (!this.lazyModelWarmupQueue.length || this.lazyModelWarmupHandle !== null) {
        return;
      }
      const scope =
        typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      if (!scope || typeof scope.setTimeout !== 'function') {
        this.runLazyModelWarmup();
        return;
      }
      const delay = this.lazyAssetLoading
        ? Math.max(LAZY_ASSET_WARMUP_DELAY_MS, Math.round(this.renderIdleThresholdSeconds * 1000))
        : 0;
      this.lazyModelWarmupHandle = scope.setTimeout(() => {
        this.lazyModelWarmupHandle = null;
        this.runLazyModelWarmup();
      }, delay);
    }

    runLazyModelWarmup() {
      if (!this.lazyModelWarmupQueue.length) {
        return;
      }
      if (!this.started || this.rendererUnavailable) {
        this.lazyModelWarmupQueue = [];
        return;
      }
      if (this.lazyAssetLoading && !this.isRenderIdle()) {
        this.scheduleLazyModelWarmup();
        return;
      }
      const nextKey = this.lazyModelWarmupQueue.shift();
      if (!nextKey) {
        this.scheduleLazyModelWarmup();
        return;
      }
      if (this.loadedModels.has(nextKey) || this.modelPromises.has(nextKey)) {
        this.scheduleLazyModelWarmup();
        return;
      }
      this.loadModel(nextKey)
        .catch((error) => {
          this.handleAssetLoadFailure(nextKey, error);
        })
        .finally(() => {
          this.scheduleLazyModelWarmup();
        });
    }

    isModelLoaderUnavailableError(error) {
      const visited = new Set();
      const inspect = (candidate) => {
        if (!candidate || visited.has(candidate)) {
          return false;
        }
        visited.add(candidate);
        const message =
          typeof candidate.message === 'string' && candidate.message.trim().length
            ? candidate.message.trim().toLowerCase()
            : '';
        if (message) {
          if (message.includes('gltfloader script loaded but did not register')) {
            return true;
          }
          if (message.includes('unable to load gltfloader')) {
            return true;
          }
          if (message.includes('cannot initialise gltfloader')) {
            return true;
          }
          if (
            message.includes('gltfloader') &&
            (message.includes('unavailable') ||
              message.includes('failed') ||
              message.includes('error') ||
              message.includes('missing'))
          ) {
            return true;
          }
        }
        const code = typeof candidate.code === 'string' ? candidate.code.trim().toUpperCase() : '';
        if (code === 'GLTF_LOADER_UNAVAILABLE' || code === 'MODEL_LOADER_UNAVAILABLE') {
          return true;
        }
        if (candidate.cause && inspect(candidate.cause)) {
          return true;
        }
        if (Array.isArray(candidate.errors)) {
          return candidate.errors.some((entry) => inspect(entry));
        }
        return false;
      };
      return inspect(error);
    }

    buildModelLoaderFallbackMessage(key) {
      const friendly = this.describeAssetKey(key);
      if (typeof friendly === 'string' && friendly.trim().length) {
        const label = friendly.trim();
        const capitalised = `${label.charAt(0).toUpperCase()}${label.slice(1)}`;
        return `${capitalised} unavailable — model loader offline. Showing placeholder visuals.`;
      }
      return 'Model loader unavailable — placeholder visuals active.';
    }

    isRunningFromFileProtocol() {
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      const protocol = scope?.location?.protocol ?? (typeof location !== 'undefined' ? location.protocol : null);
      return protocol === 'file:';
    }

    shouldUseEmbeddedModelFallback(error) {
      const message = typeof error?.message === 'string' ? error.message : '';
      if (message && /URL scheme "file" is not supported/i.test(message)) {
        return true;
      }
      if (message && /TypeError: Failed to fetch/i.test(message) && this.isRunningFromFileProtocol()) {
        return true;
      }
      if (message && /Access to XMLHttpRequest at 'file:/i.test(message)) {
        return true;
      }
      return false;
    }

    getEmbeddedModelBundle() {
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      const assets = scope?.INFINITE_RAILS_EMBEDDED_ASSETS;
      if (!assets || typeof assets !== 'object') {
        return null;
      }
      const models = assets.models;
      return models && typeof models === 'object' ? models : null;
    }

    resolveEmbeddedModelSource(key) {
      const models = this.getEmbeddedModelBundle();
      if (!models) {
        return null;
      }
      if (typeof key !== 'string') {
        return null;
      }
      const trimmed = key.trim();
      if (!trimmed) {
        return null;
      }
      const variants = new Set();
      variants.add(trimmed);
      const lowerTrimmed = trimmed.toLowerCase();
      const camelVariant = trimmed.replace(/[-_\s]+([a-zA-Z0-9])/g, (_, ch) => ch.toUpperCase());
      if (camelVariant && camelVariant !== trimmed) {
        variants.add(camelVariant);
        const lowerCamel = camelVariant.charAt(0).toLowerCase() + camelVariant.slice(1);
        variants.add(lowerCamel);
        const upperCamel = camelVariant.charAt(0).toUpperCase() + camelVariant.slice(1);
        variants.add(upperCamel);
      }
      if (/iron/i.test(trimmed) && /golem/i.test(trimmed)) {
        variants.add('ironGolem');
      }
      variants.add(trimmed.replace(/[-_\s]+/g, ''));
      const aliasMap = {
        golem: ['ironGolem'],
        'iron golem': ['ironGolem'],
        irongolem: ['ironGolem'],
        'iron_golem': ['ironGolem'],
        'iron-golem': ['ironGolem'],
      };
      if (aliasMap[lowerTrimmed]) {
        aliasMap[lowerTrimmed].forEach((alias) => variants.add(alias));
      }
      for (const variant of variants) {
        if (typeof variant !== 'string' || !variant) {
          continue;
        }
        const candidate = models[variant];
        if (typeof candidate === 'string' && candidate.trim().length) {
          return { key: variant, data: candidate };
        }
      }
      return null;
    }

    prepareLoadedModelPayload(key, gltf, { url = null } = {}) {
      if (!gltf?.scene) {
        if (url) {
          throw new Error(`Model at ${url} is missing a scene graph.`);
        }
        throw new Error(`Model "${key}" is missing a scene graph.`);
      }
      gltf.scene.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      const payload = { scene: gltf.scene, animations: gltf.animations || [] };
      if (key === 'steve') {
        const metadata = validateSteveAvatarRig(gltf);
        if (metadata) {
          const rigMetadata = Object.freeze({
            ...metadata,
            meshAssignments: { ...metadata.meshAssignments },
            hierarchy: { ...metadata.hierarchy },
            meshExpectations: { ...metadata.meshExpectations },
            meshNameByIndex: { ...metadata.meshNameByIndex },
            missingNodes: metadata.missingNodes.slice(),
            meshMismatches: metadata.meshMismatches.slice(),
            hierarchyIssues: metadata.hierarchyIssues.slice(),
            errors: metadata.errors.slice(),
          });
          payload.metadata = { avatarRig: rigMetadata };
          payload.scene.userData = {
            ...(payload.scene.userData || {}),
            avatarRigMetadata: rigMetadata,
          };
        }
      }
      return payload;
    }

    async loadEmbeddedModelFromBundle(key, context = {}) {
      const models = this.getEmbeddedModelBundle();
      if (!models) {
        return null;
      }
      const allowFallback =
        context.force === true || this.isRunningFromFileProtocol() || this.shouldUseEmbeddedModelFallback(context.error);
      if (!allowFallback) {
        return null;
      }
      const source = this.resolveEmbeddedModelSource(key);
      if (!source) {
        return null;
      }
      try {
        const LoaderClass =
          context.loaderClass || (await ensureGltfLoader(this.THREE));
        const gltf = await new Promise((resolve, reject) => {
          try {
            const loader = new LoaderClass();
            const data = typeof source.data === 'string' ? source.data : JSON.stringify(source.data);
            loader.parse(
              data,
              '',
              (parsed) => resolve(parsed),
              (parseError) => reject(parseError || new Error(`Failed to parse embedded model for ${key}.`)),
            );
          } catch (parseError) {
            reject(parseError);
          }
        });
        const payload = this.prepareLoadedModelPayload(key, gltf, {
          url: context.url ?? `embedded://${source.key}`,
        });
        try {
          Object.defineProperty(payload, '__embeddedModelFallback', {
            value: true,
            enumerable: false,
            configurable: true,
          });
        } catch (definitionError) {
          payload.__embeddedModelFallback = true;
        }
        const friendly = this.describeAssetKey(key);
        const message = friendly
          ? `${friendly.charAt(0).toUpperCase()}${friendly.slice(1)} loaded from embedded bundle.`
          : `Model "${key}" loaded from embedded bundle.`;
        console.info(message);
        if (typeof notifyLiveDiagnostics === 'function') {
          notifyLiveDiagnostics(
            'model',
            message,
            { key, url: context.url ?? null, source: 'embedded-bundle' },
            { level: 'info' },
          );
        }
        return payload;
      } catch (fallbackError) {
        console.warn(`Embedded fallback model load failed for ${key}.`, fallbackError);
        if (typeof notifyLiveDiagnostics === 'function') {
          notifyLiveDiagnostics(
            'model',
            `Embedded fallback model unavailable for ${key}.`,
            {
              key,
              url: context.url ?? null,
              source: 'embedded-bundle',
              error: typeof fallbackError?.message === 'string' ? fallbackError.message : null,
            },
            { level: 'warning' },
          );
        }
        return null;
      }
    }

    shouldPreemptEmbeddedModelLoad(key) {
      if (!this.isRunningFromFileProtocol()) {
        return false;
      }
      return Boolean(this.resolveEmbeddedModelSource(key));
    }

    loadModel(key, overrideUrl) {
      const THREE = this.THREE;
      const url = overrideUrl ? resolveAssetUrl(overrideUrl) : MODEL_URLS[key];
      if (!url) {
        return Promise.reject(new Error(`No model URL configured for key "${key}".`));
      }
      if (this.loadedModels.has(key)) {
        return Promise.resolve(this.loadedModels.get(key));
      }
      if (this.modelPromises.has(key)) {
        return this.modelPromises.get(key);
      }
      this.beginAssetTimer('models', key);
      const attemptLoad = (attempt) => {
        const attemptNumber = Math.max(1, attempt || 1);
        this.assetRetryState.set(key, attemptNumber);
        if (attemptNumber > 1) {
          this.emitGameEvent('asset-retry-attempt', {
            key,
            attempt: attemptNumber,
            limit: this.assetRetryLimit,
            kind: 'models',
            url,
          });
        }
        return ensureGltfLoader(THREE)
          .then((LoaderClass) => {
            const loadFromNetwork = () =>
              new Promise((resolve, reject) => {
                try {
                  const loader = new LoaderClass();
                  loader.load(
                    url,
                    (gltf) => resolve(gltf),
                    undefined,
                    (error) => reject(error || new Error(`Failed to load GLTF: ${url}`)),
                  );
                } catch (error) {
                  reject(error);
                }
              }).then((gltf) => this.prepareLoadedModelPayload(key, gltf, { url }));
            if (this.shouldPreemptEmbeddedModelLoad(key)) {
              return this.loadEmbeddedModelFromBundle(key, {
                url,
                loaderClass: LoaderClass,
                force: true,
              }).then((payload) => {
                if (payload) {
                  return payload;
                }
                return loadFromNetwork();
              });
            }
            return loadFromNetwork();
          })
          .catch((error) => {
            return (async () => {
              const fallbackPayload = await this.loadEmbeddedModelFromBundle(key, { url, error });
              if (fallbackPayload) {
                return fallbackPayload;
              }
              if (attemptNumber < this.assetRetryLimit) {
                const delay = this.computeAssetRetryDelay(attemptNumber);
                this.noteAssetRetry(key, attemptNumber, error, url, delay);
                await this.delay(delay);
                return attemptLoad(attemptNumber + 1);
              }
              throw error;
            })();
          });
      };
      const promise = attemptLoad(1)
        .then((payload) => {
          const attemptsUsed = this.assetRetryState.get(key) || 1;
          const fallbackUsed = Boolean(payload && payload.__embeddedModelFallback);
          if (fallbackUsed) {
            try {
              delete payload.__embeddedModelFallback;
            } catch (cleanupError) {
              payload.__embeddedModelFallback = undefined;
            }
          }
          this.assetRetryState.delete(key);
          this.completeAssetTimer('models', key, { success: true, url });
          this.loadedModels.set(key, payload);
          this.assetFailureCounts.delete(key);
          this.assetRecoveryPendingKeys.delete(key);
          this.clearAssetFailureNoticesForKey(key);
          if (attemptsUsed > 1) {
            this.emitGameEvent('asset-retry-success', {
              key,
              attempts: attemptsUsed,
              url,
            });
          }
          this.maybeHideAssetRecoveryPrompt();
          return payload;
        })
        .catch((error) => {
          const attemptsTried = this.assetRetryState.get(key) || this.assetRetryLimit;
          this.assetRetryState.delete(key);
          const loaderUnavailable = this.isModelLoaderUnavailableError(error);
          this.completeAssetTimer('models', key, {
            success: false,
            url,
            loaderUnavailable,
          });
          if (error && typeof error === 'object') {
            error.__assetFailureHandled = true;
          }
          console.warn(
            `Failed to load model "${key}" from ${url} after ${attemptsTried} attempt(s).`,
            error,
          );
          notifyLiveDiagnostics(
            'model',
            `Failed to load model "${key}" from ${url}.`,
            { key, url, attempts: attemptsTried, error: normaliseLiveDiagnosticError(error) },
          );
          const fallbackOptions = loaderUnavailable
            ? { fallbackMessage: this.buildModelLoaderFallbackMessage(key) }
            : undefined;
          this.handleAssetLoadFailure(key, error, fallbackOptions);
          if (loaderUnavailable) {
            this.recordAssetFailure('script:gltfloader', {
              fallbackMessage:
                'Model loader script unavailable — placeholder visuals active until assets recover.',
              error,
            });
            const fallbackScene = this.createModelFallbackMesh(key, { reason: 'loader-unavailable' });
            if (fallbackScene) {
              const fallbackPayload = { scene: fallbackScene, animations: [] };
              this.loadedModels.set(key, fallbackPayload);
              return fallbackPayload;
            }
          }
          this.modelPromises.delete(key);
          throw error;
        });
      this.modelPromises.set(key, promise);
      return promise;
    }

    enableStrictAssetValidation() {
      this.enforceAssetPreloadStrictness = true;
    }

    collectCriticalTextureKeys() {
      const keys = new Set();
      const register = (value) => {
        if (typeof value !== 'string') {
          return;
        }
        const trimmed = value.trim();
        if (!trimmed) {
          return;
        }
        const withoutPrefix = trimmed.startsWith('texture:') ? trimmed.slice('texture:'.length) : trimmed;
        if (!withoutPrefix || /[/.]/.test(withoutPrefix)) {
          return;
        }
        keys.add(withoutPrefix);
      };
      Object.keys(BASE_TEXTURE_REFERENCES).forEach(register);
      Object.values(BASE_TEXTURE_REFERENCES).forEach(register);
      Object.values(DIMENSION_ASSET_MANIFEST || {}).forEach((entry) => {
        const textureManifest = entry?.assets?.textures;
        if (!textureManifest || typeof textureManifest !== 'object') {
          return;
        }
        Object.keys(textureManifest).forEach(register);
        Object.values(textureManifest).forEach(register);
      });
      return Array.from(keys);
    }

    collectCriticalModelEntries() {
      const entries = [];
      const seen = new Set();
      const addEntry = (key, url = null) => {
        if (typeof key !== 'string') {
          return;
        }
        const trimmedKey = key.trim();
        if (!trimmedKey || seen.has(trimmedKey)) {
          return;
        }
        seen.add(trimmedKey);
        entries.push({ key: trimmedKey, url: url || MODEL_URLS[trimmedKey] || null });
      };
      Object.entries(MODEL_URLS).forEach(([key, url]) => addEntry(key, url));
      Object.values(DIMENSION_ASSET_MANIFEST || {}).forEach((entry) => {
        const manifestModels = entry?.assets?.models;
        if (!manifestModels || typeof manifestModels !== 'object') {
          return;
        }
        Object.entries(manifestModels).forEach(([manifestKey, reference]) => {
          const value = typeof reference === 'string' ? reference.trim() : '';
          const knownKey = value ? MODEL_URL_LOOKUP.byUrl(value) : null;
          if (knownKey) {
            addEntry(knownKey, MODEL_URLS[knownKey]);
            return;
          }
          if (typeof manifestKey === 'string' && manifestKey.trim()) {
            addEntry(manifestKey.trim(), value || null);
          }
        });
      });
      return entries;
    }

    async verifyCriticalAssetAvailability(options = {}) {
      if (this.criticalAssetAvailabilityPromise && options.force !== true) {
        return this.criticalAssetAvailabilityPromise;
      }
      const fetchImpl =
        typeof options.fetch === 'function'
          ? options.fetch
          : typeof fetch === 'function'
            ? fetch.bind(typeof window !== 'undefined' ? window : globalThis)
            : null;
      const timeoutMs = Number.isFinite(options.timeoutMs)
        ? Math.max(300, Math.floor(options.timeoutMs))
        : CRITICAL_ASSET_AVAILABILITY_DEFAULT_TIMEOUT_MS;
      const concurrency = Number.isFinite(options.concurrency)
        ? Math.max(1, Math.min(CRITICAL_ASSET_AVAILABILITY_MAX_CONCURRENCY, Math.floor(options.concurrency)))
        : CRITICAL_ASSET_AVAILABILITY_MAX_CONCURRENCY;
      const timestamp = Date.now();

      const summariseFailures = (failures) =>
        failures.slice(0, CRITICAL_ASSET_AVAILABILITY_MAX_FAILURES).map((failure) => ({
          key: failure.key,
          type: failure.type,
          label: failure.label,
          attempts: failure.attempts.slice(0, 3).map((attempt) => ({
            url: attempt.url,
            status: attempt.status,
            method: attempt.method,
            note: attempt.note,
          })),
        }));

      if (!fetchImpl) {
        const summary = {
          status: 'skipped',
          reason: 'fetch-unavailable',
          total: 0,
          reachable: 0,
          inline: 0,
          missing: [],
          failures: [],
          timestamp,
        };
        this.lastCriticalAssetAvailabilitySummary = summary;
        this.announceCriticalAssetAvailability(summary);
        this.criticalAssetAvailabilityPromise = Promise.resolve(summary);
        return this.criticalAssetAvailabilityPromise;
      }

      const buildAssetsToCheck = () => {
        const assets = [];
        const textures = this.collectCriticalTextureKeys();
        textures.forEach((key) => {
          const normalisedKey = typeof key === 'string' ? key.trim() : '';
          if (!normalisedKey) {
            return;
          }
          const sources = this.resolveAssetSourceCandidates(`texture:${normalisedKey}`);
          const candidates = normaliseAssetAvailabilityCandidates(sources);
          assets.push({
            key: `texture:${normalisedKey}`,
            type: 'texture',
            label: this.describeAssetKey(`texture:${normalisedKey}`),
            candidates,
          });
        });
        const models = this.collectCriticalModelEntries();
        models.forEach(({ key, url }) => {
          if (typeof key !== 'string') {
            return;
          }
          const normalisedKey = key.trim();
          if (!normalisedKey) {
            return;
          }
          const sources = this.resolveAssetSourceCandidates(normalisedKey);
          if (typeof url === 'string' && url.trim().length) {
            sources.push(url);
          }
          const candidates = normaliseAssetAvailabilityCandidates(sources);
          assets.push({
            key: normalisedKey,
            type: 'model',
            label: this.describeAssetKey(normalisedKey),
            candidates,
          });
        });
        return assets;
      };

      const attemptFetch = async (url, init = {}) => {
        const optionsInit = {
          method: 'HEAD',
          cache: 'no-store',
          redirect: 'follow',
          mode: 'cors',
          ...init,
        };
        let timeoutHandle = null;
        const controller = typeof AbortController === 'function' ? new AbortController() : null;
        if (controller) {
          optionsInit.signal = controller.signal;
        }
        const timeoutPromise =
          Number.isFinite(timeoutMs) && timeoutMs > 0
            ? new Promise((resolve) => {
                const scope =
                  (typeof window !== 'undefined' && window) ||
                  (typeof globalThis !== 'undefined' && globalThis) ||
                  null;
                const setTimer = typeof scope?.setTimeout === 'function' ? scope.setTimeout.bind(scope) : setTimeout;
                timeoutHandle = setTimer(() => {
                  timeoutHandle = null;
                  if (controller) {
                    try {
                      controller.abort();
                    } catch (abortError) {}
                  }
                  resolve({ timedOut: true });
                }, timeoutMs);
              })
            : null;
        try {
          const fetchPromise = fetchImpl(url, optionsInit);
          const response = timeoutPromise
            ? await Promise.race([fetchPromise, timeoutPromise])
            : await fetchPromise;
          if (response && response.timedOut) {
            return { ok: false, status: null, timedOut: true, method: optionsInit.method };
          }
          return {
            ok: response.ok || response.type === 'opaque',
            status: response.status ?? null,
            method: optionsInit.method,
            type: response.type || 'default',
          };
        } catch (error) {
          const reason =
            error && typeof error === 'object' && typeof error.name === 'string' && error.name === 'AbortError'
              ? 'aborted'
              : 'network-error';
          return { ok: false, status: null, method: optionsInit.method, note: reason };
        } finally {
          if (timeoutHandle !== null) {
            const scope =
              (typeof window !== 'undefined' && window) ||
              (typeof globalThis !== 'undefined' && globalThis) ||
              null;
            const clearTimer = typeof scope?.clearTimeout === 'function' ? scope.clearTimeout.bind(scope) : clearTimeout;
            try {
              clearTimer(timeoutHandle);
            } catch (error) {}
          }
        }
      };

      const assets = buildAssetsToCheck();
      const results = [];
      const failures = [];
      const missing = [];
      let reachable = 0;
      let inlineCount = 0;

      const checkAsset = async (asset) => {
        const detail = {
          key: asset.key,
          type: asset.type,
          label: asset.label,
          attempts: [],
        };
        const inlineCandidate = asset.candidates.find((candidate) => candidate.inline);
        if (inlineCandidate) {
          inlineCount += 1;
          reachable += 1;
          detail.status = 'inline';
          detail.attempts.push({ url: inlineCandidate.url, status: 'inline', method: 'inline', note: 'embedded' });
          results.push(detail);
          return;
        }
        const networkCandidates = asset.candidates.filter((candidate) => !candidate.inline);
        if (!networkCandidates.length) {
          detail.status = 'missing';
          detail.attempts.push({ url: null, status: null, method: null, note: 'no-sources' });
          missing.push(asset.key);
          failures.push(detail);
          results.push(detail);
          return;
        }
        for (const candidate of networkCandidates) {
          const headResult = await attemptFetch(candidate.url, { method: 'HEAD' });
          detail.attempts.push({
            url: candidate.url,
            status: headResult.status,
            method: headResult.method,
            note: headResult.timedOut ? 'timeout' : headResult.note || null,
          });
          if (headResult.ok) {
            reachable += 1;
            detail.status = 'reachable';
            results.push(detail);
            return;
          }
          if (headResult.status === 405 || headResult.status === 501) {
            const rangeResult = await attemptFetch(candidate.url, {
              method: 'GET',
              headers: { Range: 'bytes=0-0' },
            });
            detail.attempts.push({
              url: candidate.url,
              status: rangeResult.status,
              method: rangeResult.method,
              note: rangeResult.timedOut ? 'timeout' : rangeResult.note || null,
            });
            if (rangeResult.ok) {
              reachable += 1;
              detail.status = 'reachable';
              results.push(detail);
              return;
            }
          }
        }
        detail.status = 'missing';
        missing.push(asset.key);
        failures.push(detail);
        results.push(detail);
      };

      const queue = assets.slice();
      const workers = [];
      for (let i = 0; i < concurrency; i += 1) {
        workers.push(
          (async () => {
            while (queue.length) {
              const asset = queue.shift();
              if (!asset) {
                break;
              }
              try {
                // eslint-disable-next-line no-await-in-loop
                await checkAsset(asset);
              } catch (error) {
                const detail = {
                  key: asset.key,
                  type: asset.type,
                  label: asset.label,
                  attempts: [
                    {
                      url: null,
                      status: null,
                      method: null,
                      note: 'unhandled-error',
                    },
                  ],
                  status: 'missing',
                };
                failures.push(detail);
                missing.push(asset.key);
                results.push(detail);
              }
            }
          })(),
        );
      }

      const execute = async () => {
        await Promise.all(workers);
        const summary = {
          status: missing.length > 0 ? 'missing' : 'ok',
          total: assets.length,
          reachable,
          inline: inlineCount,
          missing,
          failures: summariseFailures(failures),
          timestamp,
        };
        this.lastCriticalAssetAvailabilitySummary = summary;
        this.announceCriticalAssetAvailability(summary);
        return summary;
      };

      this.criticalAssetAvailabilityPromise = execute().catch((error) => {
        const summary = {
          status: 'error',
          total: assets.length,
          reachable,
          inline: inlineCount,
          missing,
          failures: summariseFailures(failures),
          error: error && typeof error === 'object' ? { name: error.name, message: error.message } : { message: String(error) },
          timestamp,
        };
        this.lastCriticalAssetAvailabilitySummary = summary;
        this.announceCriticalAssetAvailability(summary);
        return summary;
      });
      return this.criticalAssetAvailabilityPromise;
    }

    publishCriticalAssetAvailabilityDiagnostics(summary) {
      if (!summary) {
        return;
      }
      const scope =
        (typeof globalThis !== 'undefined' && globalThis)
        || (typeof window !== 'undefined' && window)
        || null;
      const api = scope?.InfiniteRails?.bootDiagnostics ?? null;
      if (!api || typeof api.update !== 'function') {
        return;
      }
      let snapshot = null;
      if (typeof api.getSnapshot === 'function') {
        try {
          snapshot = api.getSnapshot();
        } catch (error) {
          snapshot = null;
        }
      }
      if (!snapshot) {
        snapshot = {
          timestamp: new Date().toISOString(),
          status: summary.status === 'missing' ? 'warning' : summary.status === 'error' ? 'warning' : 'ok',
          phase: 'asset-verification',
          sections: { engine: [], assets: [], models: [], ui: [] },
        };
      } else {
        snapshot = JSON.parse(JSON.stringify(snapshot));
        snapshot.timestamp = new Date().toISOString();
      }
      const ensureSections = ['engine', 'assets', 'models', 'ui'];
      snapshot.sections = snapshot.sections && typeof snapshot.sections === 'object' ? snapshot.sections : {};
      ensureSections.forEach((section) => {
        if (!Array.isArray(snapshot.sections[section])) {
          snapshot.sections[section] = [];
        }
      });
      const filteredAssets = snapshot.sections.assets.filter((entry) => {
        if (!entry || typeof entry !== 'object') {
          return true;
        }
        if (!entry.detail || typeof entry.detail !== 'object') {
          return true;
        }
        return entry.detail.category !== 'critical-asset-availability';
      });
      snapshot.sections.assets = filteredAssets;
      const missingCount = Array.isArray(summary.missing) ? summary.missing.length : 0;
      const severity =
        summary.status === 'missing'
          ? 'warning'
          : summary.status === 'error'
            ? 'warning'
            : summary.status === 'skipped'
              ? 'ok'
              : 'ok';
      const message =
        summary.status === 'missing'
          ? `Availability check detected ${missingCount} missing critical asset${missingCount === 1 ? '' : 's'}.`
          : summary.status === 'error'
            ? 'Availability check failed — probe error.'
            : summary.status === 'skipped'
              ? 'Availability check skipped — fetch unavailable.'
              : 'Availability check passed — all critical assets reachable.';
      snapshot.sections.assets.push({
        severity,
        message,
        detail: {
          category: 'critical-asset-availability',
          status: summary.status,
          total: summary.total,
          missing: summary.missing ? summary.missing.slice(0, 12) : [],
          reachable: summary.reachable ?? 0,
          inline: summary.inline ?? 0,
          failures: summary.failures ? summary.failures.slice(0, CRITICAL_ASSET_AVAILABILITY_MAX_FAILURES) : [],
          timestamp: summary.timestamp ?? Date.now(),
        },
      });
      if (summary.status === 'missing' || summary.status === 'error') {
        snapshot.status = snapshot.status === 'error' ? 'error' : 'warning';
      }
      this.lastBootDiagnostics = snapshot;
      try {
        api.update(snapshot);
      } catch (error) {}
    }

    announceCriticalAssetAvailability(summary) {
      if (!summary) {
        return;
      }
      const consoleRef = typeof console !== 'undefined' ? console : null;
      const missingCount = Array.isArray(summary.missing) ? summary.missing.length : 0;
      const baseDetail = {
        status: summary.status,
        total: summary.total,
        reachable: summary.reachable,
        inline: summary.inline,
        missing: summary.missing,
        failures: summary.failures,
        timestamp: summary.timestamp,
        reason: summary.reason ?? null,
        error: summary.error ?? null,
      };
      const emitDetail = {
        status: summary.status,
        total: summary.total,
        reachable: summary.reachable,
        inline: summary.inline,
        missing: summary.missing ? summary.missing.slice(0, 12) : [],
        failures: summary.failures || [],
        timestamp: summary.timestamp ?? Date.now(),
        reason: summary.reason ?? null,
      };
      if (summary.status === 'skipped') {
        const message = 'Critical asset availability check skipped — fetch API unavailable in this environment.';
        if (consoleRef?.info) {
          consoleRef.info(message, baseDetail);
        }
        this.emitGameEvent('asset-availability', emitDetail);
        return;
      }
      if (summary.status === 'error') {
        const message = 'Critical asset availability check failed — probe encountered an error.';
        if (consoleRef?.warn) {
          consoleRef.warn(message, baseDetail);
        }
        if (typeof notifyLiveDiagnostics === 'function') {
          notifyLiveDiagnostics('assets', message, baseDetail, { level: 'warning' });
        }
        this.emitGameEvent('asset-availability', emitDetail);
        this.publishCriticalAssetAvailabilityDiagnostics(summary);
        return;
      }
      if (missingCount > 0) {
        const listPreview = summary.missing.slice(0, 3).join(', ');
        const suffix = missingCount > 3 ? `, +${missingCount - 3} more` : '';
        const message = `Critical asset availability check detected ${missingCount} missing asset${missingCount === 1 ? '' : 's'} (${listPreview}${suffix}).`;
        if (consoleRef?.warn) {
          consoleRef.warn(message, baseDetail);
        }
        if (typeof notifyLiveDiagnostics === 'function') {
          notifyLiveDiagnostics('assets', message, baseDetail, { level: 'warning' });
        }
        this.emitGameEvent('asset-availability', emitDetail);
        this.publishCriticalAssetAvailabilityDiagnostics(summary);
        return;
      }
      const successMessage = 'Critical asset availability check passed — all critical assets reachable.';
      if (consoleRef?.info) {
        consoleRef.info(successMessage, baseDetail);
      }
      if (typeof notifyLiveDiagnostics === 'function') {
        notifyLiveDiagnostics('assets', successMessage, baseDetail, { level: 'info' });
      }
      this.emitGameEvent('asset-availability', emitDetail);
      this.publishCriticalAssetAvailabilityDiagnostics(summary);
    }

    preloadRequiredAssets() {
      if (this.criticalAssetPreloadPromise) {
        return this.criticalAssetPreloadPromise;
      }
      this.enableStrictAssetValidation();
      if (typeof this.verifyCriticalAssetAvailability === 'function') {
        try {
          this.verifyCriticalAssetAvailability();
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Failed to schedule asset availability verification.', error);
          }
        }
      }
      const textureKeys = this.collectCriticalTextureKeys();
      const modelEntries = this.collectCriticalModelEntries();
      const tasks = [];
      textureKeys.forEach((key) => {
        tasks.push(
          this.loadExternalVoxelTexture(key)
            .then((texture) => {
              if (!texture || (this.textureFallbackMissingKeys?.has?.(key) && this.enforceAssetPreloadStrictness)) {
                const error = new Error(`Texture "${key}" failed to load.`);
                if (this.enforceAssetPreloadStrictness) {
                  this.recordAssetFailure(`texture:${key}`, {
                    fallbackMessage: `Texture "${key}" failed to load. Reload to try again.`,
                    error,
                  });
                  this.abortDueToAssetFailure(`Texture "${key}" failed to load. Reload to try again.`, {
                    stage: 'texture-preload',
                    error,
                    key: `texture:${key}`,
                  });
                }
                throw error;
              }
              return texture;
            })
            .catch((error) => {
              throw error instanceof Error ? error : new Error(`Texture "${key}" failed to load.`);
            }),
        );
      });
      modelEntries.forEach(({ key, url }) => {
        tasks.push(
          this.loadModel(key, url).catch((error) => {
            throw error instanceof Error ? error : new Error(`Model "${key}" failed to load.`);
          }),
        );
      });
      if (!tasks.length) {
        this.criticalAssetPreloadFailed = false;
        this.criticalAssetPreloadComplete = true;
        this.criticalAssetPreloadPromise = Promise.resolve(true);
        return this.criticalAssetPreloadPromise;
      }
      this.criticalAssetPreloadPromise = Promise.allSettled(tasks).then((results) => {
        const failure = results.find((result) => result.status === 'rejected');
        if (failure) {
          this.criticalAssetPreloadFailed = true;
          this.criticalAssetPreloadComplete = false;
          const reason = failure.reason instanceof Error
            ? failure.reason
            : new Error('Critical asset preload failed.');
          throw reason;
        }
        this.criticalAssetPreloadFailed = false;
        this.criticalAssetPreloadComplete = true;
        return true;
      });
      return this.criticalAssetPreloadPromise;
    }

    abortDueToAssetFailure(message, context = {}) {
      this.criticalAssetPreloadFailed = true;
      this.criticalAssetPreloadComplete = false;
      const detailMessage = typeof message === 'string' && message.trim().length
        ? message.trim()
        : 'Critical assets failed to load. Reload to try again.';
      const scope =
        (typeof window !== 'undefined' && window) ||
        (typeof globalThis !== 'undefined' && globalThis) ||
        null;
      if (this.animationFrame !== null) {
        const cancelFrame =
          typeof scope?.cancelAnimationFrame === 'function'
            ? scope.cancelAnimationFrame.bind(scope)
            : typeof cancelAnimationFrame === 'function'
              ? cancelAnimationFrame
              : null;
        if (cancelFrame) {
          cancelFrame(this.animationFrame);
        }
        this.animationFrame = null;
      }
      this.cancelQueuedModelPreload();
      if (!this.rendererUnavailable || context?.force === true) {
        this.presentRendererFailure(detailMessage, {
          stage: context.stage || 'asset-load',
          error: context.error || null,
          errorName: context.error?.name || undefined,
          errorStack: context.error?.stack || undefined,
        });
      } else {
        this.rendererFailureMessage = detailMessage;
      }
      this.started = false;
    }

    async cloneModelScene(key, overrideUrl) {
      try {
        const payload = await this.loadModel(key, overrideUrl);
        if (!payload?.scene) {
          return null;
        }
        const clone = payload.scene.clone(true);
        clone.traverse((child) => {
          if (child.isMesh) {
            if (Array.isArray(child.material)) {
              child.material = child.material.map((material) => (material?.clone ? material.clone() : material));
            } else if (child.material?.clone) {
              child.material = child.material.clone();
            }
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        const metadata = payload.metadata ? { ...payload.metadata } : null;
        if (metadata?.avatarRig) {
          clone.userData = {
            ...(clone.userData || {}),
            avatarRigMetadata: metadata.avatarRig,
          };
        }
        return metadata ? { scene: clone, animations: payload.animations, metadata } : { scene: clone, animations: payload.animations };
      } catch (error) {
        if (!error || error.__assetFailureHandled !== true) {
          this.handleAssetLoadFailure(key, error);
        }
        const fallbackScene = this.createModelFallbackMesh(key, { reason: 'failed' });
        if (fallbackScene) {
          return { scene: fallbackScene, animations: [] };
        }
        return null;
      }
    }

    createModelFallbackErrorOverlay(options = {}) {
      const THREE = this.THREE;
      if (!THREE) {
        return null;
      }
      const label = typeof options.label === 'string' && options.label.trim().length
        ? options.label.trim()
        : 'MODEL ERROR';
      const detail = typeof options.detail === 'string' && options.detail.trim().length ? options.detail.trim() : '';
      const width = Number.isFinite(options.width) && options.width > 0 ? options.width : 1.6;
      const height = Number.isFinite(options.height) && options.height > 0 ? options.height : 0.55;
      const offsetY = Number.isFinite(options.offsetY) ? options.offsetY : height * 1.2;
      const renderOrder = Number.isFinite(options.renderOrder) ? options.renderOrder : 12;
      const reason = typeof options.reason === 'string' && options.reason.trim().length
        ? options.reason.trim()
        : 'failed';
      const key = typeof options.key === 'string' && options.key.trim().length ? options.key.trim() : 'asset';
      const name = typeof options.name === 'string' && options.name.trim().length
        ? options.name.trim()
        : 'PlaceholderErrorOverlay';
      const backgroundColor = options.backgroundColor || 'rgba(220, 38, 38, 0.9)';
      const borderColor = options.borderColor || 'rgba(248, 250, 252, 0.45)';
      const textColor = options.textColor || '#f8fafc';
      const detailColor = options.detailColor || '#fecaca';
      const textureWidth = Math.max(128, Math.floor(options.textureWidth || 512));
      const textureHeight = Math.max(64, Math.floor(options.textureHeight || 256));
      const doc = options.doc || (typeof document !== 'undefined' ? document : null);
      let canvas = null;
      let context = null;
      if (doc && typeof doc.createElement === 'function') {
        canvas = doc.createElement('canvas');
        if (canvas) {
          canvas.width = textureWidth;
          canvas.height = textureHeight;
          context = canvas.getContext('2d');
        }
      }
      if (!context && typeof OffscreenCanvas === 'function') {
        try {
          canvas = new OffscreenCanvas(textureWidth, textureHeight);
          context = canvas.getContext('2d');
        } catch (error) {
          context = null;
          canvas = null;
        }
      }
      if (context) {
        context.clearRect(0, 0, textureWidth, textureHeight);
        context.fillStyle = backgroundColor;
        context.fillRect(0, 0, textureWidth, textureHeight);
        const borderSize = Math.max(2, Math.floor(textureHeight * 0.05));
        if (borderSize > 0) {
          if (typeof context.strokeRect === 'function') {
            context.strokeStyle = borderColor;
            context.lineWidth = borderSize;
            context.strokeRect(borderSize / 2, borderSize / 2, textureWidth - borderSize, textureHeight - borderSize);
          } else {
            context.fillStyle = borderColor;
            context.fillRect(0, 0, textureWidth, borderSize);
            context.fillRect(0, textureHeight - borderSize, textureWidth, borderSize);
            context.fillRect(0, 0, borderSize, textureHeight);
            context.fillRect(textureWidth - borderSize, 0, borderSize, textureHeight);
          }
        }
        const canRenderText = typeof context.fillText === 'function';
        if (canRenderText) {
          context.fillStyle = textColor;
          context.textAlign = 'center';
          context.textBaseline = 'middle';
          const headerSize = Math.max(18, Math.floor(textureHeight * (detail ? 0.34 : 0.42)));
          if ('font' in context) {
            context.font = `bold ${headerSize}px sans-serif`;
          }
          context.fillText(label.toUpperCase(), textureWidth / 2, textureHeight * (detail ? 0.38 : 0.5));
          if (detail) {
            context.fillStyle = detailColor;
            const detailSize = Math.max(14, Math.floor(textureHeight * 0.2));
            if ('font' in context) {
              context.font = `600 ${detailSize}px sans-serif`;
            }
            context.fillText(detail, textureWidth / 2, textureHeight * 0.73);
          }
        } else {
          context.fillStyle = textColor;
          const bandHeight = Math.max(4, Math.floor(textureHeight * 0.12));
          const bandY = Math.floor(textureHeight * (detail ? 0.36 : 0.44));
          context.fillRect(borderSize, bandY, textureWidth - borderSize * 2, bandHeight);
          if (detail) {
            context.fillStyle = detailColor;
            const detailHeight = Math.max(3, Math.floor(textureHeight * 0.08));
            const detailY = Math.floor(textureHeight * 0.7);
            context.fillRect(borderSize, detailY, textureWidth - borderSize * 2, detailHeight);
          }
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.anisotropy = 1;
        texture.magFilter = THREE.LinearFilter;
        texture.minFilter = THREE.LinearFilter;
        texture.generateMipmaps = false;
        texture.needsUpdate = true;
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        material.depthWrite = false;
        material.depthTest = false;
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(width, height, 1);
        sprite.position.set(0, offsetY, 0);
        sprite.center.set(0.5, 0);
        sprite.renderOrder = renderOrder;
        sprite.name = name;
        sprite.userData = {
          ...(sprite.userData || {}),
          placeholder: true,
          placeholderOverlay: true,
          placeholderKey: key,
          placeholderReason: reason,
          placeholderSource: 'model-fallback-overlay',
        };
        return sprite;
      }
      const geometry = new THREE.PlaneGeometry(width, height);
      const material = new THREE.MeshBasicMaterial({
        color: '#b91c1c',
        transparent: true,
        opacity: 0.85,
        depthWrite: false,
        depthTest: false,
        side: THREE.DoubleSide,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(0, offsetY, 0);
      mesh.renderOrder = renderOrder;
      mesh.name = name;
      mesh.userData = {
        ...(mesh.userData || {}),
        placeholder: true,
        placeholderOverlay: true,
        placeholderKey: key,
        placeholderReason: reason,
        placeholderSource: 'model-fallback-overlay',
      };
      return mesh;
    }

    attachModelFallbackErrorOverlay(target, options = {}) {
      if (!target || typeof target.add !== 'function') {
        return null;
      }
      const overlay = this.createModelFallbackErrorOverlay(options);
      if (!overlay) {
        return null;
      }
      try {
        target.add(overlay);
      } catch (error) {
        if (typeof console !== 'undefined' && typeof console.warn === 'function') {
          console.warn('Failed to attach model fallback error overlay.', error);
        }
        return null;
      }
      target.userData = {
        ...(target.userData || {}),
        placeholder: true,
        placeholderOverlays: Array.isArray(target.userData?.placeholderOverlays)
          ? Array.from(new Set([...target.userData.placeholderOverlays, overlay.name || 'overlay']))
          : [overlay.name || 'overlay'],
      };
      return overlay;
    }

    createModelFallbackMesh(key, options = {}) {
      const THREE = this.THREE;
      if (!THREE) {
        return null;
      }
      const reasonLabel =
        typeof options.reason === 'string' && options.reason.trim().length ? options.reason.trim() : 'failed';
      const normalisedKey = typeof key === 'string' && key ? key.toLowerCase() : '';
      const applyPlaceholderMetadata = (object, placeholderKey) => {
        if (!object) {
          return null;
        }
        object.userData = {
          ...(object.userData || {}),
          placeholder: true,
          placeholderKey: placeholderKey || normalisedKey || 'asset',
          placeholderReason: reasonLabel,
          placeholderSource: 'model-fallback',
        };
        return object;
      };
      const defaultEmissive = '#111827';
      const showErrorOverlay = reasonLabel === 'failed' || reasonLabel === 'loader-unavailable';
      const buildPrimitiveFallback = (shape, config = {}) => {
        const safeShape = typeof shape === 'string' && shape ? shape : 'box';
        const primitiveName = config.name || `${normalisedKey || 'asset'}-primitive-fallback`;
        const color = config.color ?? options.color ?? '#9ca3af';
        let geometry;
        if (safeShape === 'sphere') {
          const radius = Number.isFinite(config.radius) && config.radius > 0 ? config.radius : 0.75;
          const widthSegments = Math.max(8, Math.floor(config.widthSegments ?? 24));
          const heightSegments = Math.max(8, Math.floor(config.heightSegments ?? 16));
          geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
        } else {
          const width = Number.isFinite(config.width) && config.width > 0 ? config.width : config.size || 1;
          const height = Number.isFinite(config.height) && config.height > 0 ? config.height : config.size || 1;
          const depth = Number.isFinite(config.depth) && config.depth > 0 ? config.depth : config.size || 1;
          geometry = new THREE.BoxGeometry(width, height, depth);
        }
        const material = new THREE.MeshStandardMaterial({
          color,
          roughness: config.roughness ?? 0.78,
          metalness: config.metalness ?? 0.14,
          emissive: config.emissive ?? defaultEmissive,
          emissiveIntensity: config.emissiveIntensity ?? 0.18,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.name = primitiveName;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        return mesh;
      };
      const withPrimitiveFallback = (object, placeholderKey, config = {}) => {
        if (object) {
          return applyPlaceholderMetadata(object, placeholderKey);
        }
        if (typeof console !== 'undefined' && typeof console.warn === 'function') {
          console.warn(
            `Placeholder mesh generation failed for ${normalisedKey || 'asset'} — reverting to primitive fallback.`,
            { reason: reasonLabel },
          );
        }
        const primitive = buildPrimitiveFallback(config.shape || 'box', config);
        return applyPlaceholderMetadata(primitive, placeholderKey);
      };
      switch (normalisedKey) {
        case 'steve': {
          const placeholder = this.buildAvatarPlaceholderMesh(reasonLabel);
          if (placeholder) {
            placeholder.name = 'PlayerAvatarFallback';
          }
          return withPrimitiveFallback(
            placeholder,
            'steve',
            {
              shape: 'box',
              width: 0.6,
              height: 1.8,
              depth: 0.4,
              color: this.getAvatarPlaceholderColor(reasonLabel),
              name: 'PlayerAvatarPrimitiveFallback',
              emissive: '#1e3a8a',
            },
          );
        }
        case 'zombie': {
          const material = new THREE.MeshStandardMaterial({
            color: '#47a34b',
            roughness: 0.68,
            metalness: 0.18,
            emissive: '#14532d',
            emissiveIntensity: 0.22,
          });
          const geometry = new THREE.BoxGeometry(0.9, 1.8, 0.9);
          const mesh = new THREE.Mesh(geometry, material);
          mesh.name = 'ZombieFallback';
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          const placeholder = withPrimitiveFallback(
            mesh,
            'zombie',
            {
              shape: 'box',
              width: 0.9,
              height: 1.8,
              depth: 0.9,
              color: '#47a34b',
              name: 'ZombiePrimitiveFallback',
              emissive: '#14532d',
              emissiveIntensity: 0.22,
              roughness: 0.68,
              metalness: 0.18,
            },
          );
          if (placeholder && showErrorOverlay) {
            this.attachModelFallbackErrorOverlay(placeholder, {
              key: 'zombie',
              reason: reasonLabel,
              label: 'MODEL ERROR',
              detail: 'Zombie rig unavailable',
              width: 1.65,
              height: 0.6,
              offsetY: 1.45,
              backgroundColor: 'rgba(220, 38, 38, 0.92)',
              borderColor: 'rgba(248, 250, 252, 0.45)',
              textColor: '#f8fafc',
              detailColor: '#fecaca',
              name: 'ZombieErrorOverlay',
            });
          }
          return placeholder;
        }
        case 'golem': {
          const actor = this.createGolemActor();
          if (actor) {
            actor.traverse((child) => {
              if (child.isMesh && child.material?.emissive) {
                child.material.emissiveIntensity = Math.max(child.material.emissiveIntensity || 0.18, 0.25);
              }
            });
            actor.name = 'GolemFallback';
          }
          const placeholder = withPrimitiveFallback(
            actor,
            'golem',
            {
              shape: 'box',
              width: 1.4,
              height: 2.6,
              depth: 0.9,
              color: '#9ca3af',
              name: 'GolemPrimitiveFallback',
              emissive: '#1f2937',
            },
          );
          if (placeholder && showErrorOverlay) {
            this.attachModelFallbackErrorOverlay(placeholder, {
              key: 'golem',
              reason: reasonLabel,
              label: 'MODEL ERROR',
              detail: 'Golem rig unavailable',
              width: 1.9,
              height: 0.65,
              offsetY: 1.85,
              backgroundColor: 'rgba(234, 88, 12, 0.9)',
              borderColor: 'rgba(254, 243, 199, 0.4)',
              textColor: '#fffbeb',
              detailColor: '#fed7aa',
              name: 'GolemErrorOverlay',
            });
          }
          return placeholder;
        }
        case 'chest': {
          const chest = this.createChestMesh(this.dimensionSettings || null);
          if (chest) {
            chest.name = 'ChestFallback';
          }
          return withPrimitiveFallback(
            chest,
            'chest',
            {
              shape: 'box',
              width: 0.9,
              height: 0.9,
              depth: 0.9,
              color: '#b45309',
              name: 'ChestPrimitiveFallback',
              emissive: '#451a03',
            },
          );
        }
        case 'portal':
        case 'portal-core':
        case 'portal-frame': {
          const portal = this.createPortalPlaceholderMesh(this.dimensionSettings || null);
          if (portal) {
            portal.name = 'PortalFallback';
          }
          return withPrimitiveFallback(
            portal,
            'portal-core',
            {
              shape: 'sphere',
              radius: 1.1,
              color: '#7c3aed',
              emissive: '#4c1d95',
              emissiveIntensity: 0.28,
              name: 'PortalPrimitiveFallback',
            },
          );
        }
        default: {
          const size = Number.isFinite(options.size) && options.size > 0 ? options.size : 1;
          const mesh = buildPrimitiveFallback('box', {
            size,
            color: options.color || '#9ca3af',
            name: `${normalisedKey || 'asset'}-fallback`,
            emissive: '#1f2937',
            emissiveIntensity: 0.12,
            roughness: 0.82,
            metalness: 0.12,
          });
          return applyPlaceholderMetadata(mesh, normalisedKey || 'asset');
        }
      }
    }

    createProceduralAnimationClip(label, options = {}) {
      const THREE = this.THREE;
      if (!THREE) return null;
      switch (label) {
        case 'idle': {
          const offsetY = Number.isFinite(options.idleYOffset) ? options.idleYOffset : 0;
          const idleTrack = new THREE.NumberKeyframeTrack('.rotation[y]', [0, 1.5, 3], [0, 0.1, 0]);
          const bobTrack = new THREE.NumberKeyframeTrack(
            '.position[y]',
            [0, 1.5, 3],
            [offsetY, offsetY + 0.05, offsetY],
          );
          return new THREE.AnimationClip('ProceduralIdle', 3, [idleTrack, bobTrack]);
        }
        case 'walk': {
          const stride = Math.max(0.45, Math.min(1.2, Number.isFinite(options.walkStride) ? options.walkStride : 0.8));
          const sway = Math.max(0.08, Math.min(0.35, Number.isFinite(options.walkSway) ? options.walkSway : 0.18));
          const duration = Math.max(0.6, Number.isFinite(options.walkDuration) ? options.walkDuration : stride);
          const swayTrack = new THREE.NumberKeyframeTrack(
            '.rotation[y]',
            [0, duration * 0.5, duration],
            [-sway, sway, -sway],
          );
          const bobTrack = new THREE.NumberKeyframeTrack('.position[y]', [0, duration * 0.5, duration], [0, 0.08, 0]);
          return new THREE.AnimationClip('ProceduralWalk', duration, [swayTrack, bobTrack]);
        }
        case 'attack': {
          const swing = Math.max(0.25, Math.min(Math.PI / 2, Number.isFinite(options.attackSwing) ? options.attackSwing : 0.6));
          const forward = Math.max(0.1, Math.min(0.6, Number.isFinite(options.attackForward) ? options.attackForward : 0.35));
          const duration = Math.max(0.4, Number.isFinite(options.attackDuration) ? options.attackDuration : 0.6);
          const swingTrack = new THREE.NumberKeyframeTrack(
            '.rotation[x]',
            [0, duration * 0.5, duration],
            [0, -swing, 0],
          );
          const thrustTrack = new THREE.NumberKeyframeTrack(
            '.position[z]',
            [0, duration * 0.5, duration],
            [0, -forward, 0],
          );
          return new THREE.AnimationClip('ProceduralAttack', duration, [swingTrack, thrustTrack]);
        }
        default:
          return null;
      }
    }

    getAnimationLabelKeywords(options = {}) {
      return {
        idle: options.idleKeywords || ['idle', 'breath', 'stand', 'rest'],
        walk: options.walkKeywords || ['walk', 'run', 'move', 'locomotion'],
        attack: options.attackKeywords || ['attack', 'punch', 'hit', 'swing', 'strike'],
      };
    }

    resolveMissingAnimationChannels(animations, requiredKeywords = {}) {
      if (!requiredKeywords || typeof requiredKeywords !== 'object') {
        return [];
      }
      const clips = Array.isArray(animations) ? animations : [];
      const missing = [];
      Object.entries(requiredKeywords).forEach(([label, keywords]) => {
        if (!Array.isArray(keywords) || keywords.length === 0) {
          return;
        }
        const lowerKeywords = keywords.map((keyword) => `${keyword}`.toLowerCase()).filter((keyword) => keyword.length);
        if (!lowerKeywords.length) {
          return;
        }
        const hasMatch = clips.some((clip) => {
          if (!clip) {
            return false;
          }
          const clipName = typeof clip.name === 'string' ? clip.name.toLowerCase() : '';
          const nameMatches = clipName.length
            ? lowerKeywords.some((keyword) => clipName.includes(keyword))
            : false;
          if (nameMatches) {
            return true;
          }
          if (!Array.isArray(clip.tracks) || clip.tracks.length === 0) {
            return false;
          }
          return clip.tracks.some((track) => {
            const trackName = typeof track?.name === 'string' ? track.name.toLowerCase() : '';
            return trackName.length ? lowerKeywords.some((keyword) => trackName.includes(keyword)) : false;
          });
        });
        if (!hasMatch) {
          missing.push(label);
        }
      });
      return missing;
    }

    prepareAnimationRig(key, model, animations = [], options = {}) {
      const THREE = this.THREE;
      if (!THREE || !model) {
        return null;
      }
      const clips = Array.isArray(animations) ? animations.slice() : [];
      const used = new Set();
      const takeClip = (predicate) => {
        for (let i = 0; i < clips.length; i += 1) {
          if (used.has(i)) continue;
          const clip = clips[i];
          if (!clip) continue;
          if (!predicate || predicate(clip, i)) {
            used.add(i);
            return clip;
          }
        }
        return null;
      };
      const keywordsMap = this.getAnimationLabelKeywords(options);
      const fallbackClip = (label) => {
        if (options.fallbackClips && options.fallbackClips[label]) {
          return options.fallbackClips[label];
        }
        return this.createProceduralAnimationClip(label, options.fallbackContext || {});
      };
      const findClip = (label) => {
        const keywords = keywordsMap[label] || [];
        if (keywords.length) {
          const keywordMatch = takeClip((clip) => {
            const name = `${clip?.name ?? ''}`.toLowerCase();
            return keywords.some((keyword) => name.includes(keyword));
          });
          if (keywordMatch) {
            return keywordMatch;
          }
        }
        const anyClip = takeClip();
        if (anyClip) {
          return anyClip;
        }
        return fallbackClip(label);
      };
      const mixer = new THREE.AnimationMixer(model);
      const actions = {};
      const registerAction = (label) => {
        const clip = findClip(label);
        if (!clip) {
          return null;
        }
        const action = mixer.clipAction(clip);
        if (!action) {
          return null;
        }
        action.reset();
        action.enabled = true;
        action.setLoop(THREE.LoopRepeat, Infinity);
        action.clampWhenFinished = false;
        action.play();
        action.setEffectiveWeight(0);
        actions[label] = action;
        return action;
      };
      registerAction('idle');
      registerAction('walk');
      registerAction('attack');
      const rig = {
        key: key || 'entity',
        root: model,
        mixer,
        actions,
        state: null,
        baseState: null,
        activePulse: null,
      };
      const defaultState = options.defaultState || 'idle';
      if (actions[defaultState]) {
        this.setAnimationRigState(rig, defaultState, { fade: 0, forceDuringPulse: true });
      } else if (actions.idle) {
        this.setAnimationRigState(rig, 'idle', { fade: 0, forceDuringPulse: true });
      }
      return rig;
    }

    configurePlayerAnimationRig(model, animations = [], options = {}) {
      if (!model) {
        if (this.playerAnimationRig) {
          this.disposeAnimationRig(this.playerAnimationRig);
        }
        this.playerAnimationRig = null;
        this.playerMixer = null;
        this.playerIdleAction = null;
        return null;
      }
      const defaultState = options.defaultState || 'idle';
      if (this.playerAnimationRig && this.playerAnimationRig.root === model) {
        this.setAnimationRigState(this.playerAnimationRig, defaultState, {
          fade: 0,
          forceDuringPulse: true,
          force: true,
        });
        this.playerMixer = this.playerAnimationRig.mixer || null;
        this.playerIdleAction = this.playerAnimationRig.actions?.idle || null;
        return this.playerAnimationRig;
      }
      if (this.playerAnimationRig) {
        this.disposeAnimationRig(this.playerAnimationRig);
      }
      const rig = this.prepareAnimationRig('steve', model, animations, {
        ...options,
        defaultState,
        fallbackContext: {
          idleYOffset: -PLAYER_EYE_HEIGHT,
          ...(options?.fallbackContext || {}),
        },
      });
      this.playerAnimationRig = rig || null;
      this.playerMixer = rig?.mixer || null;
      this.playerIdleAction = rig?.actions?.idle || null;
      if (rig) {
        this.setAnimationRigState(rig, defaultState, {
          fade: 0,
          forceDuringPulse: true,
          force: true,
        });
      }
      return rig;
    }

    primePlayerLocomotionAnimations(rig = null) {
      const targetRig = rig || this.playerAnimationRig;
      if (!targetRig || !targetRig.actions) {
        return false;
      }
      const previousState = targetRig.state || targetRig.baseState || null;
      const locomotionStates = ['idle', 'walk'];
      let primed = false;
      locomotionStates.forEach((state) => {
        const action = targetRig.actions[state];
        if (!action) {
          return;
        }
        this.setAnimationRigState(targetRig, state, {
          fade: 0,
          forceDuringPulse: true,
          force: true,
        });
        if (targetRig.mixer && typeof targetRig.mixer.update === 'function') {
          try {
            targetRig.mixer.update(0);
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Unable to prime animation mixer state.', { state, error });
            }
          }
        }
        primed = true;
      });
      const fallbackState = previousState && targetRig.actions[previousState] ? previousState : 'idle';
      if (primed && fallbackState) {
        this.setAnimationRigState(targetRig, fallbackState, {
          fade: 0,
          forceDuringPulse: true,
          force: true,
        });
      }
      return primed;
    }

    applyPlayerForcedPose(reason = 'forced-pose') {
      this.playerAnimationWatchdog = this.playerAnimationWatchdog || {
        restartAttempts: 0,
        forcedPose: false,
        cooldownUntil: 0,
      };
      this.playerAnimationWatchdog.forcedPose = true;
      const avatar = this.playerAvatar || null;
      if (!avatar) {
        return false;
      }
      if (!avatar.userData || typeof avatar.userData !== 'object') {
        avatar.userData = {};
      }
      avatar.userData.forcedPose = reason;
      const resolveLimb = (name) => {
        if (!avatar || typeof avatar.traverse !== 'function') {
          return null;
        }
        let result = avatar.getObjectByName?.(name) || null;
        if (result) {
          return result;
        }
        avatar.traverse((child) => {
          if (!result && child?.name === name) {
            result = child;
          }
        });
        return result;
      };
      const leftArm = resolveLimb('LeftArm');
      const rightArm = resolveLimb('RightArm');
      const armRotation = -Math.PI / 4;
      if (leftArm && leftArm.rotation) {
        leftArm.rotation.x = armRotation;
        leftArm.rotation.y = 0;
      }
      if (rightArm && rightArm.rotation) {
        rightArm.rotation.x = armRotation;
        rightArm.rotation.y = 0;
      }
      if (typeof this.ensurePlayerArmsVisible === 'function') {
        try {
          this.ensurePlayerArmsVisible();
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Failed to ensure player arms visible for forced pose.', error);
          }
        }
      }
      if (!this.handGroup && typeof this.createFirstPersonHands === 'function') {
        try {
          this.createFirstPersonHands();
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Failed to create first person hands during forced pose.', error);
          }
        }
      }
      return true;
    }

    setAnimationRigState(rig, state, options = {}) {
      if (!rig || !rig.actions) {
        return;
      }
      rig.baseState = state;
      const action = rig.actions[state];
      if (!action) {
        return;
      }
      if (rig.activePulse && options.forceDuringPulse !== true) {
        return;
      }
      if (rig.state === state && options.force !== true) {
        return;
      }
      const THREE = this.THREE;
      const fade = Math.max(0, Number.isFinite(options.fade) ? options.fade : 0.2);
      const previousState = rig.state;
      const previousAction = previousState ? rig.actions[previousState] : null;
      action.enabled = true;
      action.clampWhenFinished = false;
      action.setLoop(THREE.LoopRepeat, Infinity);
      action.play();
      if (fade > 0 && previousAction && previousAction !== action) {
        action.reset();
        action.fadeIn(fade);
        previousAction.fadeOut(fade);
      } else {
        action.reset();
        action.setEffectiveWeight(1);
        if (previousAction && previousAction !== action) {
          previousAction.setEffectiveWeight(0);
        }
      }
      Object.entries(rig.actions).forEach(([name, other]) => {
        if (other === action) {
          return;
        }
        if (rig.activePulse && rig.activePulse.state === name) {
          return;
        }
        if (fade > 0 && other === previousAction && previousAction !== action) {
          return;
        }
        other.enabled = true;
        other.play();
        other.setLoop(THREE.LoopRepeat, Infinity);
        other.clampWhenFinished = false;
        other.setEffectiveWeight(0);
      });
      rig.state = state;
    }

    triggerAnimationRigPulse(rig, state, options = {}) {
      if (!rig || !rig.actions) {
        return false;
      }
      const action = rig.actions[state];
      if (!action) {
        return false;
      }
      const fadeIn = Math.max(0, Number.isFinite(options.fadeIn) ? options.fadeIn : 0.1);
      const fadeOut = Math.max(0, Number.isFinite(options.fadeOut) ? options.fadeOut : 0.18);
      const clip = typeof action.getClip === 'function' ? action.getClip() : action._clip;
      const clipDuration = clip && Number.isFinite(clip.duration) ? clip.duration : 0.6;
      const duration = Math.max(0.05, Number.isFinite(options.duration) ? options.duration : clipDuration);
      const fallbackState = options.fallbackState || rig.baseState || rig.state || 'idle';
      action.reset();
      action.enabled = true;
      action.setLoop(THREE.LoopOnce, 1);
      action.clampWhenFinished = true;
      action.play();
      if (fadeIn > 0) {
        action.fadeIn(fadeIn);
      } else {
        action.setEffectiveWeight(1);
      }
      if (fallbackState && rig.actions[fallbackState] && rig.actions[fallbackState] !== action) {
        const baseAction = rig.actions[fallbackState];
        if (fadeOut > 0) {
          baseAction.fadeOut(fadeOut);
        } else {
          baseAction.setEffectiveWeight(0);
        }
      }
      rig.activePulse = {
        state,
        remaining: duration,
        fallbackState,
        fadeOut,
      };
      rig.state = state;
      return true;
    }

    updateAnimationRig(rig, delta) {
      if (!rig || !rig.mixer) {
        return;
      }
      try {
        rig.mixer.update(delta);
      } catch (error) {
        if (typeof console !== 'undefined' && typeof console.debug === 'function') {
          console.debug('Animation mixer update failed.', { key: rig.key, error });
        }
      }
      if (rig.activePulse) {
        rig.activePulse.remaining -= delta;
        if (rig.activePulse.remaining <= 0) {
          const { state, fallbackState, fadeOut } = rig.activePulse;
          const action = rig.actions?.[state] || null;
          if (action) {
            action.clampWhenFinished = false;
            action.setLoop(this.THREE.LoopRepeat, Infinity);
            if (fadeOut > 0) {
              action.fadeOut(fadeOut);
            } else {
              action.setEffectiveWeight(0);
            }
          }
          rig.activePulse = null;
          const targetState = fallbackState || rig.baseState || 'idle';
          if (targetState) {
            const fadeBack = Number.isFinite(fadeOut) ? Math.max(0, fadeOut) : 0.2;
            this.setAnimationRigState(rig, targetState, {
              fade: fadeBack,
              forceDuringPulse: true,
              force: true,
            });
          }
        }
      }
    }

    disposeAnimationRig(rig) {
      if (!rig) {
        return;
      }
      if (rig.actions) {
        Object.values(rig.actions).forEach((action) => {
          if (!action) return;
          try {
            action.stop();
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Failed to stop animation action cleanly.', error);
            }
          }
        });
      }
      if (rig.mixer) {
        try {
          rig.mixer.stopAllAction();
          if (rig.root && typeof rig.mixer.uncacheRoot === 'function') {
            rig.mixer.uncacheRoot(rig.root);
          }
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Unable to dispose animation mixer cleanly.', error);
          }
        }
      }
    }

    getAvatarPlaceholderColor(reason = 'loading') {
      const reasonLabel = typeof reason === 'string' && reason.trim().length ? reason.trim() : 'loading';
      if (reasonLabel === 'failed') {
        return 0xf97316;
      }
      if (reasonLabel === 'boot') {
        return 0x22d3ee;
      }
      return 0x3b82f6;
    }

    buildAvatarPlaceholderMesh(reason = 'loading') {
      const THREE = this.THREE;
      if (!THREE) {
        return null;
      }
      const reasonLabel = typeof reason === 'string' && reason.trim().length ? reason.trim() : 'loading';
      const placeholderColor = this.getAvatarPlaceholderColor(reasonLabel);
      const material = new THREE.MeshStandardMaterial({ color: placeholderColor, metalness: 0.12, roughness: 0.58 });
      const geometry = new THREE.BoxGeometry(0.6, 1.8, 0.4);
      const placeholder = new THREE.Mesh(geometry, material);
      placeholder.name = 'PlayerAvatarPlaceholder';
      placeholder.position.set(0, -PLAYER_EYE_HEIGHT, 0);
      placeholder.castShadow = true;
      placeholder.receiveShadow = true;
      placeholder.userData = {
        ...(placeholder.userData || {}),
        placeholder: true,
        placeholderKey: 'steve',
        placeholderReason: reasonLabel,
        placeholderSource: 'model-fallback',
      };
      return placeholder;
    }

    ensurePlayerAvatarPlaceholder(reason = 'loading') {
      const THREE = this.THREE;
      if (!THREE || !this.playerRig) {
        return null;
      }
      if (this.playerAvatar && !this.playerAvatar.userData?.placeholder) {
        return this.playerAvatar;
      }
      const reasonLabel = typeof reason === 'string' && reason.trim().length ? reason.trim() : 'loading';
      const severityOrder = { boot: 0, loading: 1, failed: 2 };
      const placeholderColor = this.getAvatarPlaceholderColor(reasonLabel);
      if (this.playerAvatar && this.playerAvatar.userData?.placeholder) {
        const currentReason = this.playerAvatar.userData.placeholderReason || 'loading';
        const currentSeverity = severityOrder[currentReason] ?? 0;
        const nextSeverity = severityOrder[reasonLabel] ?? 0;
        if (nextSeverity < currentSeverity) {
          this.configurePlayerAnimationRig(this.playerAvatar, [], { defaultState: 'idle' });
          this.playerHeadAttachment = this.playerAvatar;
          return this.playerAvatar;
        }
        if (this.playerAvatar.material?.color) {
          this.playerAvatar.material.color.set(placeholderColor);
        }
        this.playerAvatar.userData.placeholderReason = reasonLabel;
        this.playerAvatar.userData.placeholderKey = 'steve';
        this.playerAvatar.userData.placeholderSource = this.playerAvatar.userData.placeholderSource || 'ensure';
        if (this.camera && this.camera.parent !== this.playerAvatar) {
          try {
            this.playerAvatar.add(this.camera);
            this.camera.position.copy(this.firstPersonCameraOffset);
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Unable to reparent camera to placeholder avatar.', error);
            }
        }
      }
      this.applyCameraPerspective(this.cameraPerspective);
      this.ensurePlayerArmsVisible();
      this.configurePlayerAnimationRig(this.playerAvatar, [], { defaultState: 'idle' });
      this.playerHeadAttachment = this.playerAvatar;
      this.emitGameEvent('avatar-placeholder-activated', {
        key: 'steve',
        reason: reasonLabel,
      });
      return this.playerAvatar;
      }
      const placeholder = this.buildAvatarPlaceholderMesh(reasonLabel);
      if (!placeholder) {
        return null;
      }
      placeholder.userData.placeholderSource = 'ensure';
      if (this.playerAvatar && this.playerRig?.remove) {
        try {
          this.playerRig.remove(this.playerAvatar);
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Unable to remove previous avatar placeholder cleanly.', error);
          }
        }
      }
      this.playerRig.add(placeholder);
      this.playerAvatar = placeholder;
      this.playerHeadAttachment = placeholder;
      if (this.camera && placeholder && this.camera.parent !== placeholder) {
        try {
          placeholder.add(this.camera);
          this.camera.position.copy(this.firstPersonCameraOffset);
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Unable to attach camera to avatar placeholder.', error);
          }
        }
      }
      this.applyCameraPerspective(this.cameraPerspective);
      this.ensurePlayerArmsVisible();
      this.configurePlayerAnimationRig(placeholder, [], { defaultState: 'idle' });
      this.playerHeadAttachment = placeholder;
      this.emitGameEvent('avatar-placeholder-activated', {
        key: 'steve',
        reason: reasonLabel,
      });
      return placeholder;
    }

    async loadFirstPersonArms(sessionId = this.activeSessionId) {
      if (!this.handGroup) return;
      const currentSessionId = sessionId;
      let asset = null;
      try {
        asset = await this.cloneModelScene('arm');
      } catch (error) {
        asset = null;
        this.handleAssetLoadFailure('arm', error);
      }
      if (currentSessionId !== this.activeSessionId || !this.handGroup) {
        if (asset?.scene) {
          disposeObject3D(asset.scene);
        }
        return;
      }
      if (!asset?.scene) {
        this.ensurePlayerArmsVisible();
        this.handleAssetLoadFailure('arm', null, {
          fallbackMessage: 'First-person hands unavailable — showing simplified explorer overlay.',
        });
        return;
      }
      if (typeof this.handGroup.clear === 'function') {
        this.handGroup.clear();
      }
      const leftArm = asset.scene;
      leftArm.position.set(-0.32, -0.1, -0.58);
      leftArm.rotation.set(-0.32, 0.32, 0.12);
      let rightAsset = null;
      try {
        rightAsset = await this.cloneModelScene('arm');
      } catch (error) {
        rightAsset = null;
        this.handleAssetLoadFailure('arm', error);
      }
      if (currentSessionId !== this.activeSessionId || !this.handGroup) {
        disposeObject3D(leftArm);
        if (rightAsset?.scene) {
          disposeObject3D(rightAsset.scene);
        }
        return;
      }
      if (!rightAsset?.scene) {
        this.handGroup.add(leftArm);
        this.handMaterials = [];
        leftArm.traverse((child) => {
          if (child.isMesh && child.material) {
            if (Array.isArray(child.material)) {
              this.handMaterials.push(...child.material.filter(Boolean));
            } else {
              this.handMaterials.push(child.material);
            }
          }
        });
        this.handMaterialsDynamic = false;
        this.handModelLoaded = true;
        this.ensurePlayerArmsVisible();
        this.handleAssetLoadFailure('arm', null, {
          fallbackMessage: 'First-person hands partially loaded — rendering single arm fallback.',
        });
        return;
      }
      const rightArm = rightAsset.scene;
      rightArm.position.set(0.32, -0.1, -0.58);
      rightArm.rotation.set(-0.32, -0.32, -0.12);
      rightArm.rotation.y = Math.PI;
      this.handGroup.add(leftArm);
      this.handGroup.add(rightArm);
      this.handMaterials = [];
      this.handGroup.traverse((child) => {
        if (child.isMesh && child.material) {
          if (Array.isArray(child.material)) {
            this.handMaterials.push(...child.material.filter(Boolean));
          } else {
            this.handMaterials.push(child.material);
          }
        }
      });
      this.handMaterialsDynamic = false;
      this.handModelLoaded = true;
      this.ensurePlayerArmsVisible();
    }

    async loadPlayerCharacter(options = {}) {
      if (!this.playerRig) {
        this.playerAvatarLoaded = false;
        return false;
      }
      const THREE = this.THREE;
      const sessionId = this.activeSessionId;
      this.playerAvatarLoaded = false;
      const maxAttempts = Number.isFinite(options?.maxAttempts)
        ? Math.max(1, Math.floor(options.maxAttempts))
        : 3;
      this.playerAvatarMetadata = null;
      this.ensurePlayerAvatarPlaceholder('boot');
      let asset = null;
      let attempt = 0;
      let rigMetadata = null;
      while (attempt < maxAttempts) {
        attempt += 1;
        let candidate = null;
        try {
          candidate = await this.cloneModelScene('steve');
        } catch (error) {
          candidate = null;
        }
        if (sessionId !== this.activeSessionId) {
          if (candidate?.scene) {
            disposeObject3D(candidate.scene);
          }
          this.playerAvatarLoaded = false;
          return false;
        }
        const isPlaceholder = candidate?.scene?.userData?.placeholder === true;
        const candidateRigMetadata = candidate?.metadata?.avatarRig || null;
        const rigMetadataValid = candidateRigMetadata?.valid === true;
        if (candidate?.scene && !isPlaceholder && rigMetadataValid) {
          rigMetadata = candidateRigMetadata;
          asset = candidate;
          break;
        }
        const rigError =
          candidate?.scene && !isPlaceholder && !rigMetadataValid
            ? (() => {
                const error = new Error('Explorer avatar rig metadata unavailable.');
                error.code = 'PLAYER_AVATAR_METADATA_MISSING';
                return error;
              })()
            : null;
        const message = (() => {
          if (rigError) {
            return 'Explorer avatar rig metadata unavailable — placeholder visuals active while the model reinitialises.';
          }
          return attempt < maxAttempts
            ? `Explorer avatar still loading (attempt ${attempt} of ${maxAttempts}) — placeholder visuals active until detailed models return.`
            : `Explorer avatar unavailable after ${maxAttempts} attempt(s) — placeholder visuals remain active.`;
        })();
        this.handleAssetLoadFailure('steve', rigError, { fallbackMessage: message });
        if (candidate?.scene) {
          disposeObject3D(candidate.scene);
        }
        if (attempt >= maxAttempts) {
          break;
        }
        const delayMs =
          typeof this.computeAssetRetryDelay === 'function'
            ? this.computeAssetRetryDelay(attempt)
            : 700;
        await this.delay(delayMs);
        if (sessionId !== this.activeSessionId) {
          this.playerAvatarLoaded = false;
          return false;
        }
      }
      if (!asset?.scene) {
        console.warn('Player avatar model unavailable after retries — using placeholder rig.');
        this.ensurePlayerAvatarPlaceholder('failed');
        this.playerAvatarLoaded = false;
        this.primePlayerLocomotionAnimations();
        return false;
      }
      const model = asset.scene;
      model.name = 'PlayerAvatar';
      model.position.set(0, -PLAYER_EYE_HEIGHT, 0);
      model.scale.setScalar(0.98);
      model.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      if (this.playerAnimationRig) {
        this.disposeAnimationRig(this.playerAnimationRig);
        this.playerAnimationRig = null;
      } else if (this.playerMixer) {
        this.playerMixer.stopAllAction();
        this.playerMixer = null;
        this.playerIdleAction = null;
      }

      const animationKeywords = this.getAnimationLabelKeywords();
      const missingChannels = this.resolveMissingAnimationChannels(asset.animations, {
        idle: animationKeywords.idle,
        walk: animationKeywords.walk,
      });
      if (missingChannels.length) {
        const formattedMissing = missingChannels
          .map((channel) => `${channel}`.trim())
          .filter((channel) => channel.length)
          .map((channel) => channel.charAt(0).toUpperCase() + channel.slice(1));
        const missingLabel = formattedMissing.join(', ') || 'Idle, Walk';
        console.error(
          `Player model missing animation channel(s): ${missingLabel}. Falling back to placeholder avatar mesh.`,
        );
        disposeObject3D(model);
        if (this.playerAvatar && !this.playerAvatar.userData?.placeholder) {
          if (this.camera && this.camera.parent === this.playerAvatar) {
            try {
              this.playerAvatar.remove(this.camera);
              if (this.cameraBoom && typeof this.cameraBoom.add === 'function') {
                this.cameraBoom.add(this.camera);
              } else if (this.playerRig && typeof this.playerRig.add === 'function') {
                this.playerRig.add(this.camera);
              }
            } catch (error) {
              if (typeof console !== 'undefined' && typeof console.debug === 'function') {
                console.debug('Unable to detach camera from invalid avatar model.', error);
              }
            }
          }
          try {
            if (this.playerRig && typeof this.playerRig.remove === 'function') {
              this.playerRig.remove(this.playerAvatar);
            }
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Unable to remove invalid avatar model from rig.', error);
            }
          }
          disposeObject3D(this.playerAvatar);
          this.playerAvatar = null;
        }
        if (this.playerAnimationRig) {
          this.disposeAnimationRig(this.playerAnimationRig);
        }
        this.playerAnimationRig = null;
        this.playerMixer = null;
        this.playerIdleAction = null;
        this.playerHeadAttachment = null;
        const animationError = new Error(`Missing animation channel(s): ${missingLabel}`);
        animationError.code = 'PLAYER_ANIMATION_CHANNELS_MISSING';
        this.handleAssetLoadFailure('steve', animationError, {
          fallbackMessage: `Explorer avatar animation data incomplete — using fallback mesh until ${missingLabel} animation returns.`,
        });
        if (this.playerAvatar?.userData) {
          this.playerAvatar.userData.placeholderSource = 'missing-animations';
        }
        const placeholder = this.ensurePlayerAvatarPlaceholder('failed');
        if (placeholder) {
          this.configurePlayerAnimationRig(placeholder, [], { defaultState: 'idle' });
          this.playerHeadAttachment = placeholder;
        }
        this.playerAvatarLoaded = false;
        this.primePlayerLocomotionAnimations();
        return false;
      }

      if (this.playerAvatar) {
        this.playerRig.remove(this.playerAvatar);
        disposeObject3D(this.playerAvatar);
        this.playerAvatar = null;
      }

      this.playerRig.add(model);
      this.playerAvatar = model;
      this.playerAvatarMetadata = rigMetadata;

      const head = model.getObjectByName('HeadPivot') || model.getObjectByName('Head');
      this.playerHeadAttachment = head && head.isObject3D ? head : model;
      if (this.handGroup && this.handGroup.parent !== this.camera) {
        this.camera.add(this.handGroup);
      }

      this.applyCameraPerspective(this.cameraPerspective);

      this.configurePlayerAnimationRig(model, asset.animations, {
        defaultState: 'idle',
      });
      console.info('Steve visible in scene — GLTF rig active.');
      console.info(
        'Avatar visibility confirmed — verify animation rig initialises correctly if the player appears static.',
      );
      this.ensurePlayerArmsVisible();
      this.primePlayerLocomotionAnimations();
      this.playerAvatarLoaded = true;
      return true;
    }

    flagEntityModelUpgradeFailure(entity, key) {
      if (!entity?.mesh) {
        return false;
      }
      const mesh = entity.mesh;
      mesh.userData = {
        ...(mesh.userData || {}),
        placeholder: true,
        placeholderKey: key,
        placeholderReason: 'failed',
        placeholderSource: 'model-upgrade-failed',
      };
      const overlayName = key === 'golem' ? 'GolemErrorOverlay' : 'ZombieErrorOverlay';
      const hasOverlay = Array.isArray(mesh.children)
        ? mesh.children.some((child) => child?.userData?.placeholderOverlay && child.name === overlayName)
        : false;
      if (!hasOverlay) {
        const overlayOptions =
          key === 'golem'
            ? {
                key: 'golem',
                reason: 'failed',
                label: 'MODEL ERROR',
                detail: 'Golem rig unavailable',
                width: 1.9,
                height: 0.65,
                offsetY: 1.85,
                backgroundColor: 'rgba(234, 88, 12, 0.9)',
                borderColor: 'rgba(254, 243, 199, 0.4)',
                textColor: '#fffbeb',
                detailColor: '#fed7aa',
                name: overlayName,
              }
            : {
                key: 'zombie',
                reason: 'failed',
                label: 'MODEL ERROR',
                detail: 'Zombie rig unavailable',
                width: 1.65,
                height: 0.6,
                offsetY: 1.45,
                backgroundColor: 'rgba(220, 38, 38, 0.92)',
                borderColor: 'rgba(248, 250, 252, 0.45)',
                textColor: '#f8fafc',
                detailColor: '#fecaca',
                name: overlayName,
              };
        this.attachModelFallbackErrorOverlay(mesh, overlayOptions);
      }
      if (entity.animation) {
        this.disposeAnimationRig(entity.animation);
        entity.animation = null;
      }
      entity.placeholder = true;
      return true;
    }

    upgradeZombie(zombie) {
      this.cloneModelScene('zombie')
        .then((asset) => {
          if (!this.zombieGroup) return;
          if (!this.zombies.includes(zombie)) return;
          const placeholder = zombie.mesh;
          if (!asset?.scene) {
            this.flagEntityModelUpgradeFailure(zombie, 'zombie');
            return;
          }
          const model = asset.scene;
          model.name = `ZombieModel-${zombie.id}`;
          if (placeholder) {
            model.position.copy(placeholder.position);
            model.rotation.copy(placeholder.rotation);
          }
          model.scale.setScalar(0.95);
          this.zombieGroup.add(model);
          if (placeholder) {
            this.zombieGroup.remove(placeholder);
            disposeObject3D(placeholder);
          }
          zombie.mesh = model;
          zombie.placeholder = model?.userData?.placeholder === true;
          if (zombie.animation) {
            this.disposeAnimationRig(zombie.animation);
          }
          if (!zombie.placeholder) {
            zombie.animation = this.prepareAnimationRig(`zombie-${zombie.id}`, model, asset.animations, {
              defaultState: 'walk',
            });
            if (zombie.animation) {
              this.setAnimationRigState(zombie.animation, 'walk', { fade: 0, forceDuringPulse: true });
            }
          } else {
            zombie.animation = null;
          }
        })
        .catch((error) => {
          console.error('Failed to upgrade zombie model', error);
          if (this.zombies.includes(zombie)) {
            this.flagEntityModelUpgradeFailure(zombie, 'zombie');
          }
        });
    }

    upgradeGolem(golem) {
      this.cloneModelScene('golem')
        .then((asset) => {
          if (!this.golemGroup) return;
          if (!this.golems.includes(golem)) return;
          const placeholder = golem.mesh;
          if (!asset?.scene) {
            this.flagEntityModelUpgradeFailure(golem, 'golem');
            return;
          }
          const model = asset.scene;
          model.name = `GolemModel-${golem.id ?? 'actor'}`;
          if (placeholder) {
            model.position.copy(placeholder.position);
            model.rotation.copy(placeholder.rotation);
          }
          model.scale.setScalar(1.1);
          this.golemGroup.add(model);
          if (placeholder) {
            this.golemGroup.remove(placeholder);
            disposeObject3D(placeholder);
          }
          golem.mesh = model;
          golem.placeholder = model?.userData?.placeholder === true;
          if (golem.animation) {
            this.disposeAnimationRig(golem.animation);
          }
          if (!golem.placeholder) {
            golem.animation = this.prepareAnimationRig(`golem-${golem.id ?? 'actor'}`, model, asset.animations, {
              defaultState: 'idle',
            });
            if (golem.animation) {
              this.setAnimationRigState(golem.animation, 'idle', { fade: 0, forceDuringPulse: true });
            }
          } else {
            golem.animation = null;
          }
        })
        .catch((error) => {
          console.error('Failed to upgrade golem model', error);
          if (this.golems.includes(golem)) {
            this.flagEntityModelUpgradeFailure(golem, 'golem');
          }
        });
    }

    applyDimensionSettings(index) {
      const themeCount = DIMENSION_THEME.length;
      if (themeCount === 0) {
        if (typeof console !== 'undefined' && typeof console.error === 'function') {
          console.error(
            `Dimension theme load attempt failed for index ${index}. No dimension themes are registered.`,
          );
        }
        this.dimensionSettings = null;
        this.dimensionTerrainProfile = DEFAULT_TERRAIN_PROFILE;
        this.applyTerrainProfileToCaps(this.dimensionTerrainProfile);
        this.currentSpeed = PLAYER_BASE_SPEED;
        this.gravityScale = 1;
        this.netheriteChallengePlanned = false;
        if (typeof this.resetNetheriteChallenge === 'function') {
          this.resetNetheriteChallenge();
        }
        return;
      }
      const safeIndex = ((index % themeCount) + themeCount) % themeCount;
      let resolvedIndex = safeIndex;
      let theme = DIMENSION_THEME[safeIndex] ?? null;
      if (!theme) {
        const fallbackIndex = DIMENSION_THEME.findIndex((candidate) => Boolean(candidate));
        const fallbackTheme = fallbackIndex >= 0 ? DIMENSION_THEME[fallbackIndex] : null;
        if (typeof console !== 'undefined') {
          const logger = typeof console.warn === 'function' ? console.warn : console.log;
          if (typeof logger === 'function') {
            const fallbackMessage = fallbackTheme
              ? `Falling back to theme "${fallbackTheme.id ?? `index-${fallbackIndex}`}".`
              : 'No fallback theme is available.';
            logger(
              `Dimension theme load attempt missing for index ${safeIndex} (requested ${index}). ${fallbackMessage}`,
            );
          }
        }
        if (fallbackTheme) {
          theme = fallbackTheme;
          resolvedIndex = fallbackIndex;
        }
      }
      if (!theme) {
        const logKey = `${index}:${safeIndex}`;
        if (!reportedMissingThemeLoads.has(logKey) && typeof console !== 'undefined') {
          reportedMissingThemeLoads.add(logKey);
          const logger = typeof console.error === 'function' ? console.error : console.log;
          if (typeof logger === 'function') {
            logger(
              `Dimension theme load attempt failed for index ${index} (resolved ${safeIndex}). Theme entry is unavailable.`,
            );
          }
        }
        this.dimensionSettings = null;
        this.dimensionTerrainProfile = DEFAULT_TERRAIN_PROFILE;
        this.applyTerrainProfileToCaps(this.dimensionTerrainProfile);
        this.currentSpeed = PLAYER_BASE_SPEED;
        this.gravityScale = 1;
        this.netheriteChallengePlanned = false;
        if (typeof this.resetNetheriteChallenge === 'function') {
          this.resetNetheriteChallenge();
        }
        return;
      }
      this.currentDimensionIndex = resolvedIndex;
      this.dimensionSettings = theme;
      this.dimensionTerrainProfile = theme?.terrainProfile || DEFAULT_TERRAIN_PROFILE;
      ensureDimensionThemeManifestCoverage(theme);
      this.applyTerrainProfileToCaps(this.dimensionTerrainProfile);
      this.currentSpeed = PLAYER_BASE_SPEED * (theme.speedMultiplier ?? 1);
      this.gravityScale = theme.gravity ?? 1;
      this.netheriteChallengePlanned = theme.id === 'netherite';
      if (!this.netheriteChallengePlanned) {
        this.resetNetheriteChallenge();
      }

      const { palette } = theme;
      if (palette?.grass) this.materials.grass.color.set(palette.grass);
      if (palette?.dirt) this.materials.dirt.color.set(palette.dirt);
      if (palette?.stone) this.materials.stone.color.set(palette.stone);
      if (palette?.rails) this.materials.rails.color.set(palette.rails);
      if (palette?.dirt) {
        this.dayGroundColor.set(palette.dirt);
        this.nightGroundColor.copy(this.dayGroundColor).offsetHSL(-0.05, -0.12, -0.35);
      }
      if (palette?.rails) {
        this.materials.portal.uniforms.uColorA.value.set(palette.rails);
      }
      if (palette?.grass) {
        this.materials.portal.uniforms.uColorB.value.set(palette.grass);
      }
      if (this.handMaterialsDynamic && this.handMaterials.length) {
        const palmColor = palette?.grass || '#82c7ff';
        const sleeveColor = palette?.rails || '#2563eb';
        this.handMaterials.forEach((material, index) => {
          if (!material?.color) return;
          if (index <= 1) {
            material.color.set(palmColor);
          } else {
            material.color.set(sleeveColor);
          }
        });
      }
      if (this.scene?.background && theme.sky) {
        this.scene.background.set(theme.sky);
      }
      if (this.scene?.fog && theme.fog) {
        this.scene.fog.color.set(theme.fog);
      }
      if (theme.sky) {
        this.daySkyColor.set(theme.sky);
        this.nightSkyColor.copy(this.daySkyColor).offsetHSL(-0.02, -0.12, -0.45);
        this.duskSkyColor.copy(this.daySkyColor).offsetHSL(0.06, 0.08, -0.18);
      }
      if (theme.fog) {
        this.dayFogColor.set(theme.fog);
        this.nightFogColor.copy(this.dayFogColor).offsetHSL(-0.04, -0.1, -0.32);
      }
      if (this.hemiLight && theme.hemi) {
        this.hemiLight.color.set(theme.hemi);
      }
      if (this.sunLight && theme.sun) {
        this.sunLight.color.set(theme.sun);
        this.daySunColor.set(theme.sun);
      }
      if (this.moonLight) {
        this.nightMoonColor.copy(this.daySkyColor).offsetHSL(0.12, -0.05, -0.35);
        this.moonLight.color.copy(this.nightMoonColor);
      }
      this.updateDayNightCycle();
      this.updateDimensionInfoPanel();
      console.info(
        `Dimension activation notice — ${theme.name} assets should now be visible. If the environment loads empty, confirm theme registration and manifest entries for this dimension.`,
      );
    }

    applyTerrainProfileToCaps(profile) {
      const baseConfig = this.baseTerrainConfig || {
        minColumnHeight: MIN_COLUMN_HEIGHT,
        maxColumnHeight: MAX_COLUMN_HEIGHT,
        voxelBudget: DEFAULT_TERRAIN_VOXEL_CAP,
      };
      const baseMin = Math.max(1, Math.floor(baseConfig.minColumnHeight ?? MIN_COLUMN_HEIGHT));
      const baseMax = Math.max(baseMin, Math.floor(baseConfig.maxColumnHeight ?? MAX_COLUMN_HEIGHT));
      const baseBudget = Math.max(
        WORLD_SIZE * WORLD_SIZE * baseMin,
        Math.floor(baseConfig.voxelBudget ?? DEFAULT_TERRAIN_VOXEL_CAP),
      );
      const minOverride = Number.isFinite(profile?.minHeight)
        ? Math.max(1, Math.floor(profile.minHeight))
        : baseMin;
      const maxOverride = Number.isFinite(profile?.maxHeight)
        ? Math.max(minOverride, Math.floor(profile.maxHeight))
        : baseMax;
      const budgetMultiplier = Number.isFinite(profile?.voxelBudgetMultiplier)
        ? Math.max(0.1, profile.voxelBudgetMultiplier)
        : 1;
      const budgetOffset = Number.isFinite(profile?.voxelBudgetOffset)
        ? Math.floor(profile.voxelBudgetOffset)
        : 0;
      const requestedBudget = Math.max(0, Math.floor(baseBudget * budgetMultiplier + budgetOffset));
      const minBudgetRequirement = WORLD_SIZE * WORLD_SIZE * minOverride;
      const maxTerrainCap = Math.min(MAX_TERRAIN_VOXELS, DEFAULT_TERRAIN_VOXEL_CAP);
      const safeBudget = Math.max(minBudgetRequirement, Math.min(requestedBudget, maxTerrainCap));
      this.minColumnHeight = minOverride;
      this.maxColumnHeight = Math.min(Math.max(minOverride, maxOverride), MAX_COLUMN_HEIGHT);
      this.maxTerrainVoxels = Math.max(minBudgetRequirement, safeBudget);
      return {
        minColumnHeight: this.minColumnHeight,
        maxColumnHeight: this.maxColumnHeight,
        maxTerrainVoxels: this.maxTerrainVoxels,
      };
    }

    ensureWorldRootGroups() {
      const THREE = this.THREE;
      if (!THREE || typeof THREE.Group !== 'function') {
        return;
      }
      if (!(this.worldRoot instanceof THREE.Group)) {
        this.worldRoot = new THREE.Group();
        this.worldRoot.name = 'WorldRoot';
        if (this.scene && typeof this.scene.add === 'function') {
          try {
            this.scene.add(this.worldRoot);
          } catch (error) {
            console.error('Failed to attach regenerated world root to the scene.', error);
            notifyLiveDiagnostics(
              'scene',
              'Failed to attach regenerated world root to the scene.',
              { error: normaliseLiveDiagnosticError(error) },
              { level: 'warning' },
            );
          }
        }
      }
      if (!(this.terrainGroup instanceof THREE.Group)) {
        this.terrainGroup = new THREE.Group();
        this.terrainGroup.name = 'TerrainGroup';
      }
      if (
        this.worldRoot &&
        typeof this.worldRoot.add === 'function' &&
        this.terrainGroup &&
        this.terrainGroup.parent !== this.worldRoot
      ) {
        try {
          this.worldRoot.add(this.terrainGroup);
        } catch (error) {
          console.error('Failed to attach regenerated terrain group to the world root.', error);
          notifyLiveDiagnostics(
            'scene',
            'Failed to attach regenerated terrain group to the world root.',
            { error: normaliseLiveDiagnosticError(error) },
            { level: 'warning' },
          );
        }
      }
      if (!(this.columns instanceof Map)) {
        this.columns = new Map();
      }
      if (!Array.isArray(this.terrainChunkGroups)) {
        this.terrainChunkGroups = [];
      }
      if (!(this.terrainChunkMap instanceof Map)) {
        this.terrainChunkMap = new Map();
      }
      if (!(this.dirtyTerrainChunks instanceof Set)) {
        this.dirtyTerrainChunks = new Set();
      }
    }

    registerStreamedHeightmap(payload) {
      if (!payload) {
        return false;
      }
      this.pendingHeightmapStream = payload;
      return true;
    }

    consumeStreamedHeightmapPayload(expectedDimensionKey) {
      const payload = this.pendingHeightmapStream;
      if (!payload) {
        return null;
      }
      this.pendingHeightmapStream = null;
      let matrix = null;
      if (Array.isArray(payload)) {
        matrix = payload;
      } else if (Array.isArray(payload?.matrix)) {
        matrix = payload.matrix;
      } else if (Array.isArray(payload?.tiles)) {
        matrix = payload.tiles;
      } else if (Array.isArray(payload?.heightmap)) {
        matrix = payload.heightmap;
      }
      const dimensionKeyRaw =
        typeof payload?.dimension === 'string' && payload.dimension.trim().length
          ? payload.dimension.trim()
          : typeof payload?.id === 'string' && payload.id.trim().length
            ? payload.id.trim()
            : typeof payload?.key === 'string' && payload.key.trim().length
              ? payload.key.trim()
              : null;
      const dimensionKey = dimensionKeyRaw || expectedDimensionKey || null;
      if (!matrix) {
        return { matrix: null, dimensionKey, reason: 'stream-empty' };
      }
      return { matrix, dimensionKey, reason: null };
    }

    applyHeightmapBudget(matrix, options) {
      const minColumnHeight = Math.max(1, Math.floor(options.minColumnHeight ?? MIN_COLUMN_HEIGHT));
      const maxColumnHeight = Math.max(minColumnHeight, Math.floor(options.maxColumnHeight ?? MAX_COLUMN_HEIGHT));
      const voxelBudget = Math.max(0, Math.floor(options.voxelBudget ?? DEFAULT_TERRAIN_VOXEL_CAP));
      const totalColumns = WORLD_SIZE * WORLD_SIZE;
      const result = createHeightmapMatrix(WORLD_SIZE, minColumnHeight);
      let remainingVoxels = Math.max(voxelBudget, totalColumns * minColumnHeight);
      let cappedColumns = 0;
      let voxelCount = 0;
      for (let gx = 0; gx < WORLD_SIZE; gx += 1) {
        for (let gz = 0; gz < WORLD_SIZE; gz += 1) {
          const columnIndex = gx * WORLD_SIZE + gz;
          const rawValue = matrix?.[gx]?.[gz];
          const desiredHeightRaw = Number.isFinite(rawValue) ? rawValue : minColumnHeight;
          const desiredHeight = Math.max(
            minColumnHeight,
            Math.min(maxColumnHeight, Math.round(desiredHeightRaw)),
          );
          const columnsRemaining = totalColumns - columnIndex - 1;
          const reservedForRemaining = Math.max(0, columnsRemaining * minColumnHeight);
          const budgetForColumn = Math.max(minColumnHeight, remainingVoxels - reservedForRemaining);
          let columnHeight = Math.min(desiredHeight, maxColumnHeight, budgetForColumn, remainingVoxels);
          if (columnHeight < minColumnHeight) {
            columnHeight = Math.min(minColumnHeight, remainingVoxels);
          }
          if (columnHeight < desiredHeight) {
            cappedColumns += 1;
          }
          remainingVoxels = Math.max(0, remainingVoxels - columnHeight);
          result[gx][gz] = columnHeight;
          voxelCount += columnHeight;
        }
      }
      return {
        matrix: result,
        meta: {
          voxelCount,
          cappedColumns,
          remainingVoxels,
        },
      };
    }

    generateProceduralHeightmap(options) {
      const profile = options?.profile || DEFAULT_TERRAIN_PROFILE;
      const minColumnHeight = Math.max(1, Math.floor(options?.minColumnHeight ?? MIN_COLUMN_HEIGHT));
      const maxColumnHeight = Math.max(minColumnHeight, Math.floor(options?.maxColumnHeight ?? MAX_COLUMN_HEIGHT));
      const voxelBudget = Math.max(0, Math.floor(options?.voxelBudget ?? DEFAULT_TERRAIN_VOXEL_CAP));
      const dimensionIndex = Number.isFinite(options?.dimensionIndex) ? options.dimensionIndex : 0;
      const baseHeight = Number.isFinite(profile?.baseHeight)
        ? profile.baseHeight
        : DEFAULT_TERRAIN_PROFILE.baseHeight;
      const falloffStrength = Number.isFinite(profile?.falloffStrength)
        ? profile.falloffStrength
        : DEFAULT_TERRAIN_PROFILE.falloffStrength;
      const falloffRadius = Math.max(
        0.1,
        Number.isFinite(profile?.falloffRadius) ? profile.falloffRadius : DEFAULT_TERRAIN_PROFILE.falloffRadius,
      );
      const falloffExponent = Math.max(
        0.1,
        Number.isFinite(profile?.falloffExponent)
          ? profile.falloffExponent
          : DEFAULT_TERRAIN_PROFILE.falloffExponent,
      );
      const noiseFrequency = Math.max(
        0.01,
        Number.isFinite(profile?.noiseFrequency)
          ? profile.noiseFrequency
          : DEFAULT_TERRAIN_PROFILE.noiseFrequency,
      );
      const noiseAmplitude = Number.isFinite(profile?.noiseAmplitude)
        ? profile.noiseAmplitude
        : DEFAULT_TERRAIN_PROFILE.noiseAmplitude;
      const secondaryFrequency = Math.max(
        0.01,
        Number.isFinite(profile?.secondaryFrequency)
          ? profile.secondaryFrequency
          : DEFAULT_TERRAIN_PROFILE.secondaryFrequency,
      );
      const secondaryAmplitude = Number.isFinite(profile?.secondaryAmplitude)
        ? profile.secondaryAmplitude
        : DEFAULT_TERRAIN_PROFILE.secondaryAmplitude;
      const ridgeFrequency = Math.max(
        0,
        Number.isFinite(profile?.ridgeFrequency)
          ? profile.ridgeFrequency
          : DEFAULT_TERRAIN_PROFILE.ridgeFrequency,
      );
      const ridgeAmplitude = Math.max(
        0,
        Number.isFinite(profile?.ridgeAmplitude)
          ? profile.ridgeAmplitude
          : DEFAULT_TERRAIN_PROFILE.ridgeAmplitude,
      );
      const rimHeightBias = Number.isFinite(profile?.rimHeightBias)
        ? profile.rimHeightBias
        : DEFAULT_TERRAIN_PROFILE.rimHeightBias;
      const centerHeightBias = Number.isFinite(profile?.centerHeightBias)
        ? profile.centerHeightBias
        : DEFAULT_TERRAIN_PROFILE.centerHeightBias;
      const seedMultiplier = Number.isFinite(profile?.seedMultiplier)
        ? profile.seedMultiplier
        : DEFAULT_TERRAIN_PROFILE.seedMultiplier;
      const dimensionSeedBase = (dimensionIndex + 1) * seedMultiplier;
      const seedOffsetX = dimensionSeedBase * 0.137;
      const seedOffsetZ = dimensionSeedBase * 0.173;
      const half = WORLD_SIZE / 2;
      const matrix = createHeightmapMatrix(WORLD_SIZE, minColumnHeight);
      const totalColumns = WORLD_SIZE * WORLD_SIZE;
      let remainingVoxels = Math.max(voxelBudget, totalColumns * minColumnHeight);
      let cappedColumns = 0;
      let voxelCount = 0;
      for (let gx = 0; gx < WORLD_SIZE; gx += 1) {
        for (let gz = 0; gz < WORLD_SIZE; gz += 1) {
          const offsetX = gx - half;
          const offsetZ = gz - half;
          const columnIndex = gx * WORLD_SIZE + gz;
          const distance = Math.hypot(offsetX, offsetZ);
          const falloffBase = Math.max(0, 1 - distance / (WORLD_SIZE * falloffRadius));
          const falloff = Math.pow(falloffBase, falloffExponent);
          const primaryNoise = pseudoRandom(
            (gx + seedOffsetX) * noiseFrequency,
            (gz - seedOffsetZ) * noiseFrequency,
          );
          const secondaryNoise = pseudoRandom(
            (gz + seedOffsetZ) * secondaryFrequency,
            (gx - seedOffsetX) * secondaryFrequency,
          );
          let heightSample =
            baseHeight +
            falloff * falloffStrength +
            primaryNoise * noiseAmplitude +
            secondaryNoise * secondaryAmplitude +
            falloff * centerHeightBias +
            (1 - falloff) * rimHeightBias;
          if (ridgeAmplitude > 0 && ridgeFrequency > 0) {
            const ridgeNoise = pseudoRandom(
              (gx - seedOffsetZ) * ridgeFrequency + seedOffsetX,
              (gz + seedOffsetX) * ridgeFrequency - seedOffsetZ,
            );
            const ridgeValue = Math.abs(ridgeNoise - 0.5) * 2 * ridgeAmplitude;
            heightSample += ridgeValue;
          }
          const desiredHeight = Math.max(minColumnHeight, Math.round(heightSample));
          const cappedHeight = Math.min(desiredHeight, maxColumnHeight);
          const columnsRemaining = totalColumns - columnIndex - 1;
          const reservedForRemaining = Math.max(0, columnsRemaining * minColumnHeight);
          const budgetForColumn = Math.max(minColumnHeight, remainingVoxels - reservedForRemaining);
          let columnHeight = Math.min(cappedHeight, maxColumnHeight, budgetForColumn, remainingVoxels);
          if (columnHeight < minColumnHeight) {
            columnHeight = Math.min(minColumnHeight, remainingVoxels);
          }
          if (columnHeight < desiredHeight) {
            cappedColumns += 1;
          }
          remainingVoxels = Math.max(0, remainingVoxels - columnHeight);
          matrix[gx][gz] = columnHeight;
          voxelCount += columnHeight;
        }
      }
      return {
        matrix,
        meta: {
          voxelCount,
          cappedColumns,
          remainingVoxels,
        },
      };
    }

    resolveHeightmapMatrix(options) {
      const {
        dimensionKey,
        profile,
        minColumnHeight,
        maxColumnHeight,
        voxelBudget,
        preferSeeded = false,
        forcedFallbackReason = null,
      } = options;
      let fallbackReason = typeof forcedFallbackReason === 'string' && forcedFallbackReason
        ? forcedFallbackReason
        : null;
      let fallbackFromStream = Boolean(fallbackReason);
      let streamCandidate = null;
      if (!preferSeeded) {
        streamCandidate = this.consumeStreamedHeightmapPayload(dimensionKey);
        if (streamCandidate?.reason) {
          fallbackReason = streamCandidate.reason;
          fallbackFromStream = true;
        }
        if (streamCandidate?.matrix) {
          const dimensionMatches =
            !streamCandidate.dimensionKey ||
            !dimensionKey ||
            streamCandidate.dimensionKey === dimensionKey;
          if (!dimensionMatches) {
            fallbackReason = 'dimension-mismatch';
            fallbackFromStream = true;
          } else {
            const validation = validateHeightmapMatrix(streamCandidate.matrix, WORLD_SIZE);
            if (validation.valid) {
              const applied = this.applyHeightmapBudget(validation.matrix, {
                minColumnHeight,
                maxColumnHeight,
                voxelBudget,
              });
              this.heightmapStreamState = 'streamed';
              this.heightmapStreamLastError = null;
              return {
                matrix: applied.matrix,
                meta: applied.meta,
                source: 'streamed',
                fallbackReason: null,
                fallbackFromStream: false,
              };
            }
            fallbackReason = validation.reason ?? 'invalid-stream-heightmap';
            fallbackFromStream = true;
          }
        }
      }
      const cacheKey =
        typeof dimensionKey === 'string' && dimensionKey.trim().length
          ? dimensionKey.trim()
          : 'default';
      let cachedMatrix = null;
      if (this.seededHeightmapCache instanceof Map && this.seededHeightmapCache.has(cacheKey)) {
        cachedMatrix = cloneHeightmapMatrix(this.seededHeightmapCache.get(cacheKey));
      }
      if (fallbackFromStream) {
        this.heightmapStreamFailureCount = (this.heightmapStreamFailureCount || 0) + 1;
        this.heightmapStreamLastError = fallbackReason;
      }
      if (cachedMatrix) {
        const applied = this.applyHeightmapBudget(cachedMatrix, {
          minColumnHeight,
          maxColumnHeight,
          voxelBudget,
        });
        this.heightmapStreamState = fallbackFromStream ? 'fallback-cache' : 'seeded-cache';
        return {
          matrix: applied.matrix,
          meta: applied.meta,
          source: fallbackFromStream ? 'fallback-cache' : 'seeded-cache',
          fallbackReason,
          fallbackFromStream,
        };
      }
      const generated = this.generateProceduralHeightmap({
        profile,
        minColumnHeight,
        maxColumnHeight,
        voxelBudget,
        dimensionIndex: this.currentDimensionIndex ?? 0,
      });
      if (this.seededHeightmapCache instanceof Map) {
        this.seededHeightmapCache.set(cacheKey, cloneHeightmapMatrix(generated.matrix));
      }
      if (fallbackReason && !fallbackFromStream) {
        fallbackFromStream = true;
      }
      this.heightmapStreamState = fallbackFromStream ? 'fallback-generated' : 'seeded-generated';
      return {
        matrix: cloneHeightmapMatrix(generated.matrix),
        meta: generated.meta,
        source: fallbackFromStream ? 'fallback-generated' : 'seeded-generated',
        fallbackReason,
        fallbackFromStream,
      };
    }

    buildTerrain(options = {}) {
      const THREE = this.THREE;
      const buildReasonRaw = typeof options.reason === 'string' ? options.reason.trim() : '';
      const buildReason = buildReasonRaw.length ? buildReasonRaw : 'world-load';
      const navmeshReasonRaw = typeof options.navmeshReason === 'string' ? options.navmeshReason.trim() : '';
      const navmeshReason =
        navmeshReasonRaw.length > 0
          ? navmeshReasonRaw
          : NAVMESH_RELOAD_REASONS.has(buildReason)
            ? buildReason
            : `${buildReason}-navmesh`;
      this.ensureWorldRootGroups();
      const resetTerrainState = () => {
        this.clearChests();
        this.columns.clear();
        this.heightMap = createHeightmapMatrix(WORLD_SIZE, 0);
        this.initialHeightMap = createHeightmapMatrix(WORLD_SIZE, 0);
        const existingChunks = Array.isArray(this.terrainGroup?.children)
          ? Array.from(this.terrainGroup.children)
          : [];
        existingChunks.forEach((child) => {
          this.terrainGroup.remove(child);
          disposeObject3D(child);
        });
        this.terrainChunkGroups = [];
        this.terrainChunkMap.clear();
        this.dirtyTerrainChunks.clear();
        this.cancelNavigationMeshMaintenance();
        if (!this.navigationMeshes) {
          this.navigationMeshes = new Map();
        } else {
          this.navigationMeshes.clear();
        }
        if (!this.dirtyNavigationChunks) {
          this.dirtyNavigationChunks = new Set();
        } else {
          this.dirtyNavigationChunks.clear();
        }
        if (this.aiMovementWarningLog instanceof Map) {
          this.aiMovementWarningLog.clear();
        }
        this.navigationMeshGeneration += 1;
        const meshInitTimestamp = Date.now();
        if (!this.navigationMeshSummary) {
          this.navigationMeshSummary = {
            chunkCount: 0,
            walkableCells: 0,
            reason: 'pending',
            updatedAt: meshInitTimestamp,
          };
        } else {
          this.navigationMeshSummary.chunkCount = 0;
          this.navigationMeshSummary.walkableCells = 0;
          this.navigationMeshSummary.reason = 'pending';
          this.navigationMeshSummary.updatedAt = meshInitTimestamp;
        }
        this.lastCullingCameraValid = false;
      };
      const totalColumns = WORLD_SIZE * WORLD_SIZE;
      const minColumnHeight = Math.max(1, Math.floor(this.minColumnHeight ?? MIN_COLUMN_HEIGHT));
      const maxColumnHeight = Math.max(minColumnHeight, Math.floor(this.maxColumnHeight ?? MAX_COLUMN_HEIGHT));
      const targetBudget = Number.isFinite(this.maxTerrainVoxels)
        ? Math.max(0, Math.floor(this.maxTerrainVoxels))
        : DEFAULT_TERRAIN_VOXEL_CAP;
      const maxTerrainCap = Math.min(MAX_TERRAIN_VOXELS, DEFAULT_TERRAIN_VOXEL_CAP);
      const safeBudget = Math.max(totalColumns * minColumnHeight, Math.min(targetBudget, maxTerrainCap));
      const voxelBudget = Math.min(maxTerrainCap, safeBudget);
      const profile = this.dimensionTerrainProfile || DEFAULT_TERRAIN_PROFILE;
      const dimensionKey =
        typeof this.dimensionSettings?.id === 'string' && this.dimensionSettings.id.trim().length
          ? this.dimensionSettings.id.trim()
          : `dimension-${this.currentDimensionIndex ?? 0}`;
      const evaluateTerrainIntegrity = (metrics) => {
        const issues = [];
        const {
          chunkCount,
          expectedChunkCount,
          emptyChunkKeys,
          terrainMeshCount,
          voxelCount,
          minDetectedHeight,
        } = metrics;
        const worldRootValid = this.worldRoot instanceof THREE.Group;
        const terrainGroupValid =
          this.terrainGroup instanceof THREE.Group && this.terrainGroup.children.length > 0;
        const chunkArrayValid = Array.isArray(this.terrainChunkGroups) && this.terrainChunkGroups.length > 0;
        const heightMapValid =
          Array.isArray(this.heightMap) &&
          this.heightMap.length === WORLD_SIZE &&
          this.heightMap.every((row) => Array.isArray(row) && row.length === WORLD_SIZE);
        if (!worldRootValid) issues.push('world-root-missing');
        if (!terrainGroupValid) issues.push('terrain-group-missing');
        if (!chunkArrayValid) issues.push('terrain-chunk-array-empty');
        if (!heightMapValid) issues.push('heightmap-invalid');
        if (!Number.isFinite(voxelCount) || voxelCount <= 0) issues.push('voxel-count-empty');
        if (!Number.isFinite(terrainMeshCount) || terrainMeshCount <= 0)
          issues.push('terrain-meshes-empty');
        if (terrainMeshCount !== voxelCount) issues.push('mesh-voxel-mismatch');
        if (!Number.isFinite(chunkCount) || chunkCount !== expectedChunkCount)
          issues.push('chunk-count-mismatch');
        if (Array.isArray(emptyChunkKeys) && emptyChunkKeys.length > 0)
          issues.push('empty-terrain-chunks');
        if (!Number.isFinite(minDetectedHeight) || minDetectedHeight <= 0)
          issues.push('non-positive-ground');
        return { valid: issues.length === 0, issues };
      };
      const applyHeightmapToTerrain = (heightmapResult) => {
        const heightMatrix = Array.isArray(heightmapResult?.matrix)
          ? heightmapResult.matrix
          : createHeightmapMatrix(WORLD_SIZE, minColumnHeight);
        const heightMeta = heightmapResult?.meta || {};
        const half = WORLD_SIZE / 2;
        let voxelCount = 0;
        let minDetectedHeight = Infinity;
        let maxDetectedHeight = -Infinity;
        for (let gx = 0; gx < WORLD_SIZE; gx += 1) {
          for (let gz = 0; gz < WORLD_SIZE; gz += 1) {
            const offsetX = gx - half;
            const offsetZ = gz - half;
            const worldX = offsetX * BLOCK_SIZE;
            const worldZ = offsetZ * BLOCK_SIZE;
            const rawHeight = heightMatrix?.[gx]?.[gz];
            const columnHeight = Math.max(
              minColumnHeight,
              Math.min(maxColumnHeight, Math.round(Number.isFinite(rawHeight) ? rawHeight : minColumnHeight)),
            );
            this.heightMap[gx][gz] = columnHeight;
            this.initialHeightMap[gx][gz] = columnHeight;
            if (columnHeight < minDetectedHeight) minDetectedHeight = columnHeight;
            if (columnHeight > maxDetectedHeight) maxDetectedHeight = columnHeight;
            const columnKey = `${gx}|${gz}`;
            const column = [];
            const chunkKey = this.getTerrainChunkKey(gx, gz);
            const chunk = this.ensureTerrainChunk(chunkKey);
            for (let level = 0; level < columnHeight; level += 1) {
              const isSurface = level === columnHeight - 1;
              const blockType = isSurface
                ? 'grass-block'
                : level > columnHeight - 3
                  ? 'dirt'
                  : 'stone';
              const material =
                blockType === 'grass-block'
                  ? this.materials.grass
                  : blockType === 'dirt'
                    ? this.materials.dirt
                    : this.materials.stone;
              const mesh = new THREE.Mesh(this.blockGeometry, material);
              mesh.castShadow = isSurface;
              mesh.receiveShadow = true;
              mesh.position.set(worldX, level * BLOCK_SIZE + BLOCK_SIZE / 2, worldZ);
              mesh.visible = true;
              mesh.userData = {
                columnKey,
                level,
                gx,
                gz,
                blockType,
                chunkKey,
              };
              mesh.matrixAutoUpdate = false;
              mesh.updateMatrix();
              chunk.add(mesh);
              column.push(mesh);
              voxelCount += 1;
            }
            this.columns.set(columnKey, column);
          }
        }
        const cappedColumns = Math.max(0, Math.floor(heightMeta.cappedColumns ?? 0));
        const chunkGridSize = Math.max(1, Math.ceil(WORLD_SIZE / Math.max(1, this.terrainChunkSize)));
        const expectedChunkCount = chunkGridSize * chunkGridSize;
        const existingChunkKeys = new Set(
          Array.isArray(this.terrainChunkGroups)
            ? this.terrainChunkGroups.map((chunk) => chunk?.userData?.chunkKey).filter(Boolean)
            : [],
        );
        const missingChunkKeys = [];
        for (let cx = 0; cx < chunkGridSize; cx += 1) {
          for (let cz = 0; cz < chunkGridSize; cz += 1) {
            const key = `${cx}|${cz}`;
            if (!existingChunkKeys.has(key)) {
              missingChunkKeys.push(key);
              const chunk = this.ensureTerrainChunk(key);
              existingChunkKeys.add(key);
              if (typeof console !== 'undefined') {
                console.warn('Restoring missing terrain chunk group.', { chunkKey: key });
              }
            }
          }
        }
        this.terrainChunkGroups.forEach((chunk) => {
          this.recalculateTerrainChunkBounds(chunk);
        });
        const emptyChunkKeys = [];
        const terrainMeshCount = this.terrainChunkGroups.reduce((sum, chunk) => {
          if (!chunk) {
            return sum;
          }
          if (!chunk.children.length) {
            emptyChunkKeys.push(chunk?.userData?.chunkKey ?? null);
          }
          return sum + chunk.children.length;
        }, 0);
        const navigationSummary = this.refreshNavigationMeshes({ reason: navmeshReason });
        const navSummaryTimestamp = Date.now();
        if (!this.navigationMeshSummary) {
          this.navigationMeshSummary = {
            chunkCount: navigationSummary.chunkCount,
            walkableCells: navigationSummary.walkableCells,
            reason: navmeshReason,
            updatedAt: navSummaryTimestamp,
          };
        } else {
          this.navigationMeshSummary.chunkCount = navigationSummary.chunkCount;
          this.navigationMeshSummary.walkableCells = navigationSummary.walkableCells;
          this.navigationMeshSummary.reason = navmeshReason;
          this.navigationMeshSummary.updatedAt = navSummaryTimestamp;
        }
        if (typeof console !== 'undefined') {
          console.info(
            `Navigation mesh initialization summary — ${navigationSummary.chunkCount} chunk meshes prepared with ${navigationSummary.walkableCells} walkable surfaces (${navmeshReason}). If mobs stop moving, inspect chunk hydration and navmesh rebuilding.`,
          );
        }
        this.terrainCullingAccumulator = this.terrainCullingInterval;
        const voxelsUsed = voxelCount;
        const budgetRemaining = Math.max(0, voxelBudget - voxelsUsed);
        this.terrainVoxelBudget = voxelBudget;
        this.terrainVoxelUsage = voxelsUsed;
        const chunkCount = Array.isArray(this.terrainChunkGroups) ? this.terrainChunkGroups.length : 0;
        if (typeof console !== 'undefined') {
          const columnCount = WORLD_SIZE * WORLD_SIZE;
          console.info(
            `Terrain heightmap source — ${heightmapResult?.source ?? 'unknown'}. Stream fallback count: ${this.heightmapStreamFailureCount}.`,
          );
          console.info(
            `World generation summary — ${columnCount} columns created. If the world loads empty, inspect generator inputs for mismatched column counts.`,
          );
          console.info(
            `Terrain block placement summary — ${voxelCount} blocks placed across ${terrainMeshCount} meshes. For missing terrain, review the heightmap generator and chunk hydration routines.`,
          );
          console.info(
            `Terrain chunk population summary — ${chunkCount} chunks loaded. Investigate the streaming manager if this number stalls unexpectedly.`,
          );
          if (chunkCount <= 0 || voxelCount <= 0) {
            console.error('Terrain generation produced no active chunk groups or voxels.', {
              chunkCount,
              voxelCount,
              voxelBudget,
            });
          }
          if (cappedColumns > 0) {
            console.info(
              `Terrain voxel budget applied: ${cappedColumns} columns trimmed to stay under ${voxelBudget} voxels`,
            );
          }
          if (terrainMeshCount !== voxelCount) {
            console.error('Terrain mesh count mismatch detected.', {
              terrainMeshCount,
              voxelCount,
            });
          }
          const filteredEmptyChunks = emptyChunkKeys.filter(Boolean);
          if (filteredEmptyChunks.length) {
            console.error('Empty terrain chunks detected after generation.', { emptyChunks: filteredEmptyChunks });
          }
          if (voxelBudget < MAX_TERRAIN_VOXELS || budgetRemaining === 0) {
            console.info(`Terrain voxel cap enforced at ${voxelsUsed}/${voxelBudget} blocks.`);
          }
        }
        const integrity = evaluateTerrainIntegrity({
          chunkCount,
          expectedChunkCount,
          emptyChunkKeys: emptyChunkKeys.filter(Boolean),
          terrainMeshCount,
          voxelCount,
          minDetectedHeight,
        });
        if (!integrity.valid && typeof console !== 'undefined') {
          console.error('Terrain integrity issues detected after build.', { issues: integrity.issues });
        }
        return {
          summary: {
            heightmapSource: heightmapResult?.source ?? 'unknown',
            fallbackReason: heightmapResult?.fallbackReason ?? null,
            fallbackFromStream: Boolean(heightmapResult?.fallbackFromStream),
            voxelBudget,
            voxelsUsed,
            budgetRemaining,
            cappedColumns,
            voxelCount,
            terrainMeshCount,
            chunkCount,
            expectedChunkCount,
            missingChunkKeys,
            emptyChunkKeys: emptyChunkKeys.filter(Boolean),
            streamState: this.heightmapStreamState,
            streamFailureCount: this.heightmapStreamFailureCount,
            heightmapReportedVoxels: Number.isFinite(heightMeta.voxelCount)
              ? Math.floor(heightMeta.voxelCount)
              : null,
            heightmapReportedRemaining: Number.isFinite(heightMeta.remainingVoxels)
              ? Math.max(0, Math.floor(heightMeta.remainingVoxels))
              : null,
            minDetectedHeight,
            maxDetectedHeight,
            integrity,
          },
          heightmapResult,
        };
      };
      const executeTerrainBuild = (preferSeeded = false, forcedFallbackReason = null) => {
        resetTerrainState();
        const heightmapResult = this.resolveHeightmapMatrix({
          dimensionKey,
          profile,
          minColumnHeight,
          maxColumnHeight,
          voxelBudget,
          preferSeeded,
          forcedFallbackReason,
        });
        return applyHeightmapToTerrain(heightmapResult);
      };
      let { summary, heightmapResult } = executeTerrainBuild(false, null);
      if (!summary?.integrity?.valid && heightmapResult?.source === 'streamed') {
        if (typeof console !== 'undefined') {
          console.error('Streamed heightmap failed validation. Regenerating terrain with seeded fallback.', {
            issues: summary.integrity?.issues || ['unknown'],
          });
        }
        ({ summary, heightmapResult } = executeTerrainBuild(true, 'terrain-integrity-invalid'));
      }
      this.lastTerrainBuildSummary = summary;
      this.portalAnchorGrid = this.computePortalAnchorGrid();
      const anchorWorldX = (this.portalAnchorGrid.x - WORLD_SIZE / 2) * BLOCK_SIZE;
      const anchorWorldZ = (this.portalAnchorGrid.z - WORLD_SIZE / 2) * BLOCK_SIZE;
      if (this.portalAnchor?.set) {
        this.portalAnchor.set(anchorWorldX, 0, anchorWorldZ);
      }
    }

    populateSceneAfterTerrain(options = {}) {
      const reasonRaw = typeof options.reason === 'string' ? options.reason.trim() : '';
      const reason = reasonRaw.length ? reasonRaw : 'terrain-ready';
      const populationErrors = [];
      const populationContext = { reason, errors: populationErrors, reportedMissing: false };
      this.lastScenePopulationSummaryContext = populationContext;
      const recordPopulationError = (asset, error) => {
        const consoleDetail = { asset, reason };
        if (error) {
          consoleDetail.error = error;
        }
        if (typeof console !== 'undefined' && typeof console.error === 'function') {
          console.error(`Scene population step failed for ${asset}.`, consoleDetail);
        }
        populationErrors.push({ asset, error });
        const diagnosticDetail = {
          asset,
          reason,
          error: normaliseLiveDiagnosticError(error),
        };
        if (typeof notifyLiveDiagnostics === 'function') {
          notifyLiveDiagnostics('scene', `Scene population step failed for ${asset}.`, diagnosticDetail, {
            level: 'error',
          });
        }
      };
      const invokeStep = (asset, handler) => {
        if (typeof handler !== 'function') {
          return;
        }
        try {
          handler();
        } catch (error) {
          recordPopulationError(asset, error);
        }
      };

      invokeStep('terrain-ground', () => {
        const THREE = this.THREE;
        const terrainGroup = this.terrainGroup || null;
        if (!terrainGroup) {
          throw new Error('Terrain group unavailable after build.');
        }
        let targetParent = null;
        if (this.worldRoot instanceof THREE.Group && typeof this.worldRoot.add === 'function') {
          targetParent = this.worldRoot;
        } else if (this.scene && typeof this.scene.add === 'function') {
          targetParent = this.scene;
        }
        if (!targetParent) {
          throw new Error('No valid scene root available for terrain group attachment.');
        }
        if (
          terrainGroup.parent &&
          terrainGroup.parent !== targetParent &&
          typeof terrainGroup.parent.remove === 'function'
        ) {
          try {
            terrainGroup.parent.remove(terrainGroup);
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Failed to detach terrain group from previous parent.', error);
            }
          }
        }
        if (terrainGroup.parent !== targetParent) {
          try {
            targetParent.add(terrainGroup);
          } catch (error) {
            const attachError = new Error('Terrain group could not be attached to the scene root.');
            attachError.cause = error;
            throw attachError;
          }
        }
      });

      invokeStep('terrain-blocks', () => {
        const terrainGroup = this.terrainGroup || null;
        const chunkGroups = Array.isArray(this.terrainChunkGroups) ? this.terrainChunkGroups : [];
        if (!terrainGroup) {
          throw new Error('Terrain group missing while validating block meshes.');
        }
        if (!chunkGroups.length) {
          throw new Error('Terrain chunk groups are empty after terrain generation.');
        }
        let attachedChunkCount = 0;
        for (const chunk of chunkGroups) {
          if (!chunk) {
            continue;
          }
          if (chunk.parent !== terrainGroup && typeof terrainGroup.add === 'function') {
            terrainGroup.add(chunk);
          }
          if (chunk.parent === terrainGroup) {
            attachedChunkCount += 1;
          }
        }
        if (attachedChunkCount <= 0) {
          throw new Error('No terrain chunk groups are attached to the terrain group.');
        }
      });

      invokeStep('player-avatar', () => {
        this.positionPlayer();
      });

      invokeStep('loot-chests', () => {
        this.spawnDimensionChests();
      });

      const mobOptions = typeof options.mobs === 'object' && options.mobs !== null ? options.mobs : {};
      invokeStep('mob-actors', () => {
        this.populateInitialMobs(mobOptions);
      });

      if (typeof this.summariseRequiredSceneNodes === 'function') {
        const summary = this.summariseRequiredSceneNodes();
        this.lastScenePopulationSummary = summary || null;
        if (summary && !summary.allPresent) {
          populationContext.reportedMissing = true;
          this.reportMissingSceneObjects(summary, { reason, errors: populationErrors });
        } else {
          populationContext.reportedMissing = false;
        }
        return summary;
      }
      this.lastScenePopulationSummary = null;
      populationContext.reportedMissing = false;
      return null;
    }

    rebindEntityChunkAnchors(context = {}) {
      const reason = typeof context.reason === 'string' && context.reason.trim().length
        ? context.reason.trim()
        : 'chunk-rebind';
      const summary = {
        reason,
        player: { chunkKey: null, rebound: false },
        chests: { total: 0, rebound: 0, missing: 0 },
        zombies: { total: 0, rebound: 0, missing: 0, despawned: 0 },
        golems: { total: 0, rebound: 0, missing: 0, despawned: 0 },
        errors: [],
      };
      try {
        const playerPosition = this.getPlayerWorldPosition(this.tmpVector3);
        const chunkKey = this.getChunkKeyForWorldPosition(playerPosition.x, playerPosition.z);
        this.playerChunkKey = chunkKey || null;
        if (chunkKey) {
          summary.player = { chunkKey, rebound: true };
        } else {
          summary.player = { chunkKey: null, rebound: false };
          summary.errors.push({ scope: 'player', reason: 'chunk-missing' });
        }
      } catch (error) {
        summary.errors.push({ scope: 'player', error });
      }

      const bindMeshToChunk = (mesh, chunkKey) => {
        if (!mesh) {
          return;
        }
        if (!mesh.userData || typeof mesh.userData !== 'object') {
          mesh.userData = {};
        }
        mesh.userData.chunkKey = chunkKey || null;
      };

      if (Array.isArray(this.chests)) {
        for (const chest of this.chests) {
          summary.chests.total += 1;
          if (!chest?.mesh) {
            summary.chests.missing += 1;
            continue;
          }
          const chunkKey = this.getChunkKeyForWorldPosition(chest.mesh.position.x, chest.mesh.position.z);
          if (chunkKey) {
            chest.chunkKey = chunkKey;
            bindMeshToChunk(chest.mesh, chunkKey);
            summary.chests.rebound += 1;
          } else {
            summary.chests.missing += 1;
            bindMeshToChunk(chest.mesh, null);
          }
        }
      }

      const reconcileMobCollection = (actorType, collection, bucket) => {
        if (!Array.isArray(collection)) {
          return;
        }
        for (const mob of collection.slice()) {
          if (!mob?.mesh) {
            bucket.missing += 1;
            continue;
          }
          bucket.total += 1;
          const chunkKey = this.getChunkKeyForWorldPosition(mob.mesh.position.x, mob.mesh.position.z);
          const result = this.handleNavmeshFailureForMob(actorType, mob, {
            chunkKey,
            reason,
          });
          if (result?.action === 'rehomed') {
            bucket.rebound += 1;
            bindMeshToChunk(mob.mesh, actorType === 'golem' ? mob.chunkKey : mob.navChunkKey);
          } else if (result?.action === 'despawned') {
            bucket.despawned += 1;
          } else {
            bindMeshToChunk(mob.mesh, chunkKey || null);
          }
        }
      };

      reconcileMobCollection('zombie', this.zombies, summary.zombies);
      reconcileMobCollection('golem', this.golems, summary.golems);

      return summary;
    }

    detectChunkDebugFlag() {
      if (typeof window === 'undefined') {
        return false;
      }
      try {
        const params = new URLSearchParams(window.location.search || '');
        return params.get('debugChunks') === '1';
      } catch (error) {
        console.debug('Unable to parse chunk debug flag.', error);
        return false;
      }
    }

    getTerrainChunkKey(gx, gz) {
      const size = this.terrainChunkSize;
      const chunkX = Math.floor(gx / size);
      const chunkZ = Math.floor(gz / size);
      return `${chunkX}|${chunkZ}`;
    }

    parseTerrainChunkKey(chunkKey) {
      if (typeof chunkKey !== 'string' || !chunkKey) {
        return { chunkX: 0, chunkZ: 0, valid: false };
      }
      const [chunkXRaw, chunkZRaw] = chunkKey.split('|');
      const parsedX = Number.parseInt(chunkXRaw ?? '', 10);
      const parsedZ = Number.parseInt(chunkZRaw ?? '', 10);
      const chunkX = Number.isFinite(parsedX) ? parsedX : 0;
      const chunkZ = Number.isFinite(parsedZ) ? parsedZ : 0;
      return { chunkX, chunkZ, valid: Number.isFinite(parsedX) && Number.isFinite(parsedZ) };
    }

    getChunkKeyForWorldPosition(x, z) {
      if (!Number.isFinite(x) || !Number.isFinite(z)) {
        return null;
      }
      const halfWorld = WORLD_SIZE / 2;
      const gridX = Math.floor(x / BLOCK_SIZE + halfWorld);
      const gridZ = Math.floor(z / BLOCK_SIZE + halfWorld);
      if (gridX < 0 || gridX >= WORLD_SIZE || gridZ < 0 || gridZ >= WORLD_SIZE) {
        return null;
      }
      return this.getTerrainChunkKey(gridX, gridZ);
    }

    ensureTerrainChunk(chunkKey) {
      let chunk = this.terrainChunkMap.get(chunkKey);
      if (chunk) {
        return chunk;
      }
      const THREE = this.THREE;
      const { chunkX, chunkZ } = this.parseTerrainChunkKey(chunkKey);
      chunk = new THREE.Group();
      chunk.name = `TerrainChunk-${chunkX}-${chunkZ}`;
      chunk.visible = true;
      chunk.userData = {
        chunkKey,
        chunkX,
        chunkZ,
        minY: 0,
        maxY: BLOCK_SIZE,
        boundingSphere: new THREE.Sphere(new THREE.Vector3(), BLOCK_SIZE),
      };
      this.terrainChunkMap.set(chunkKey, chunk);
      this.terrainChunkGroups.push(chunk);
      this.terrainGroup.add(chunk);
      return chunk;
    }

    recalculateTerrainChunkBounds(chunk) {
      if (!chunk) return;
      const data = chunk.userData || {};
      let minY = Infinity;
      let maxY = -Infinity;
      for (const child of chunk.children) {
        if (!child?.position) continue;
        const y = child.position.y;
        const childMin = y - BLOCK_SIZE / 2;
        const childMax = y + BLOCK_SIZE / 2;
        if (childMin < minY) minY = childMin;
        if (childMax > maxY) maxY = childMax;
      }
      if (!Number.isFinite(minY)) {
        minY = 0;
        maxY = BLOCK_SIZE;
        chunk.visible = false;
      } else {
        chunk.visible = true;
      }
      data.minY = minY;
      data.maxY = maxY;
      const size = this.terrainChunkSize;
      const halfWorld = WORLD_SIZE / 2;
      const startX = data.chunkX * size;
      const startZ = data.chunkZ * size;
      const centerOffsetX = startX - halfWorld + (size - 1) / 2;
      const centerOffsetZ = startZ - halfWorld + (size - 1) / 2;
      const centerX = centerOffsetX * BLOCK_SIZE;
      const centerZ = centerOffsetZ * BLOCK_SIZE;
      const centerY = (minY + maxY) / 2;
      const horizontalExtent = (size * BLOCK_SIZE) / 2;
      const verticalExtent = Math.max(BLOCK_SIZE * 0.5, (maxY - minY) / 2 + BLOCK_SIZE * 0.5);
      const radius = Math.sqrt(horizontalExtent * horizontalExtent * 2 + verticalExtent * verticalExtent);
      if (!data.boundingSphere) {
        data.boundingSphere = new this.THREE.Sphere(new this.THREE.Vector3(centerX, centerY, centerZ), radius);
      } else {
        data.boundingSphere.center.set(centerX, centerY, centerZ);
        data.boundingSphere.radius = radius;
      }
      chunk.userData = data;
    }

    cancelNavigationMeshMaintenance(clearReason = true) {
      if (this.navigationMeshMaintenanceHandle !== null) {
        const globalScope = typeof globalThis !== 'undefined' ? globalThis : undefined;
        const scope = typeof window !== 'undefined' ? window : globalScope;
        const cancelIdle = scope?.cancelIdleCallback;
        const clearTimer =
          typeof scope?.clearTimeout === 'function'
            ? scope.clearTimeout.bind(scope)
            : typeof globalScope?.clearTimeout === 'function'
              ? globalScope.clearTimeout.bind(globalScope)
              : clearTimeout;
        if (typeof this.navigationMeshMaintenanceCancel === 'function') {
          try {
            this.navigationMeshMaintenanceCancel(this.navigationMeshMaintenanceHandle);
          } catch (error) {
            if (typeof cancelIdle === 'function') {
              try {
                cancelIdle(this.navigationMeshMaintenanceHandle);
              } catch (_) {
                clearTimer(this.navigationMeshMaintenanceHandle);
              }
            } else {
              clearTimer(this.navigationMeshMaintenanceHandle);
            }
          }
        } else if (typeof cancelIdle === 'function') {
          try {
            cancelIdle(this.navigationMeshMaintenanceHandle);
          } catch (_) {
            clearTimer(this.navigationMeshMaintenanceHandle);
          }
        } else {
          clearTimer(this.navigationMeshMaintenanceHandle);
        }
        this.navigationMeshMaintenanceHandle = null;
        this.navigationMeshMaintenanceCancel = null;
      }
      if (clearReason) {
        this.navigationMeshMaintenanceReason = null;
      }
    }

    scheduleNavigationMeshMaintenance(reason = 'terrain-update') {
      if (!(this.dirtyTerrainChunks instanceof Set)) {
        this.dirtyTerrainChunks = new Set();
      }
      const dirtyTerrain = this.dirtyTerrainChunks.size > 0;
      const dirtyNavigation =
        this.dirtyNavigationChunks instanceof Set && this.dirtyNavigationChunks.size > 0;
      this.navigationMeshMaintenanceReason = reason;
      if (!dirtyTerrain && !dirtyNavigation) {
        this.cancelNavigationMeshMaintenance(false);
        return false;
      }
      if (this.navigationMeshMaintenanceHandle !== null) {
        return false;
      }
      const globalScope = typeof globalThis !== 'undefined' ? globalThis : undefined;
      const scope = typeof window !== 'undefined' ? window : globalScope;
      const requestIdle = scope?.requestIdleCallback;
      const cancelIdle = scope?.cancelIdleCallback;
      const setTimer =
        typeof scope?.setTimeout === 'function'
          ? scope.setTimeout.bind(scope)
          : typeof globalScope?.setTimeout === 'function'
            ? globalScope.setTimeout.bind(globalScope)
            : setTimeout;
      const clearTimer =
        typeof scope?.clearTimeout === 'function'
          ? scope.clearTimeout.bind(scope)
          : typeof globalScope?.clearTimeout === 'function'
            ? globalScope.clearTimeout.bind(globalScope)
            : clearTimeout;
      const invokeMaintenance = () => {
        this.navigationMeshMaintenanceHandle = null;
        this.navigationMeshMaintenanceCancel = null;
        this.refreshDirtyTerrainChunks({ reason });
      };
      if (typeof requestIdle === 'function') {
        try {
          this.navigationMeshMaintenanceHandle = requestIdle(invokeMaintenance, { timeout: 120 });
          if (typeof cancelIdle === 'function') {
            this.navigationMeshMaintenanceCancel = cancelIdle.bind(scope);
          }
          return true;
        } catch (error) {
          console.debug('requestIdleCallback scheduling for navmesh maintenance failed; falling back.', error);
        }
      }
      this.navigationMeshMaintenanceCancel = clearTimer;
      this.navigationMeshMaintenanceHandle = setTimer(invokeMaintenance, 0);
      return true;
    }

    markTerrainChunkDirty(chunkKey) {
      if (!chunkKey || !this.terrainChunkMap.has(chunkKey)) return;
      this.dirtyTerrainChunks.add(chunkKey);
      if (this.dirtyNavigationChunks) {
        this.dirtyNavigationChunks.add(chunkKey);
      }
      this.scheduleNavigationMeshMaintenance('terrain-update');
    }

    refreshDirtyTerrainChunks(options = {}) {
      this.cancelNavigationMeshMaintenance(false);
      const reason = options.reason ?? this.navigationMeshMaintenanceReason ?? 'terrain-update';
      const dirtyNavCount = this.dirtyNavigationChunks?.size ?? 0;
      if (!this.dirtyTerrainChunks.size && !dirtyNavCount) return;
      const keys = new Set();
      for (const key of this.dirtyTerrainChunks) {
        keys.add(key);
      }
      if (dirtyNavCount) {
        for (const key of this.dirtyNavigationChunks) {
          keys.add(key);
        }
      }
      if (!keys.size) {
        this.dirtyTerrainChunks.clear();
        if (this.dirtyNavigationChunks) {
          this.dirtyNavigationChunks.clear();
        }
        return;
      }
      let navMeshesUpdated = 0;
      for (const key of keys) {
        const chunk = this.terrainChunkMap.get(key);
        if (!chunk) {
          if (this.navigationMeshes instanceof Map) {
            this.navigationMeshes.delete(key);
          }
          continue;
        }
        if (this.dirtyTerrainChunks.has(key)) {
          this.recalculateTerrainChunkBounds(chunk);
        }
        const navmesh = this.rebuildNavigationMeshForChunk(key, { reason });
        if (navmesh) {
          navMeshesUpdated += 1;
        }
      }
      this.dirtyTerrainChunks.clear();
      if (this.dirtyNavigationChunks) {
        this.dirtyNavigationChunks.clear();
      }
      if (navMeshesUpdated > 0) {
        const meshRegistry = this.navigationMeshes instanceof Map ? this.navigationMeshes : null;
        const totalWalkable = meshRegistry
          ? Array.from(meshRegistry.values()).reduce((sum, mesh) => sum + (mesh?.walkableCellCount ?? 0), 0)
          : 0;
        const chunkCount = meshRegistry ? meshRegistry.size : 0;
        const timestamp = Date.now();
        if (!this.navigationMeshSummary) {
          this.navigationMeshSummary = {
            chunkCount,
            walkableCells: totalWalkable,
            reason,
            updatedAt: timestamp,
          };
        } else {
          this.navigationMeshSummary.chunkCount = chunkCount;
          this.navigationMeshSummary.walkableCells = totalWalkable;
          this.navigationMeshSummary.reason = reason;
          this.navigationMeshSummary.updatedAt = timestamp;
        }
        if (typeof console !== 'undefined') {
          console.info(
            `Navigation mesh delta refresh — ${navMeshesUpdated} chunk meshes rebuilt (${totalWalkable} walkable surfaces tracked, reason: ${reason}).`,
          );
        }
      }
      this.navigationMeshMaintenanceReason = null;
    }

    warnAiMovementFailure(actorType, detail = {}) {
      if (typeof console === 'undefined' || typeof console.warn !== 'function') {
        return;
      }
      if (!(this.aiMovementWarningLog instanceof Map)) {
        this.aiMovementWarningLog = new Map();
      }
      const typeKey = typeof actorType === 'string' && actorType.trim().length ? actorType.trim() : 'unknown';
      const chunkRaw =
        typeof detail.chunkKey === 'string' && detail.chunkKey.trim().length
          ? detail.chunkKey.trim()
          : detail.chunkKey === null || detail.chunkKey === undefined
            ? null
            : String(detail.chunkKey);
      const stageKey = typeof detail.stage === 'string' && detail.stage.trim().length ? detail.stage.trim() : 'general';
      const reasonKey = typeof detail.reason === 'string' && detail.reason.trim().length ? detail.reason.trim() : 'unspecified';
      const throttleMs = Number.isFinite(detail.throttleMs) ? Math.max(0, detail.throttleMs) : 6000;
      const key = `${typeKey}:${chunkRaw ?? 'none'}:${stageKey}:${reasonKey}`;
      const now = Date.now();
      const lastWarn = this.aiMovementWarningLog.get(key) || 0;
      if (now - lastWarn < throttleMs) {
        return;
      }
      this.aiMovementWarningLog.set(key, now);
      const context = { ...detail, actorType: typeKey, chunkKey: chunkRaw, stage: stageKey, reason: reasonKey };
      console.warn(
        'AI movement failure detected. Verify navigation mesh rebuild scheduling and terrain coverage.',
        context,
      );
    }

    ensureNavigationMeshForActorChunk(actorType, chunkKey, options = {}) {
      if (!chunkKey) {
        this.warnAiMovementFailure(actorType, { ...options, chunkKey: null, reason: 'chunk-missing' });
        return null;
      }
      const navmesh = this.ensureNavigationMeshForChunk(chunkKey, options);
      if (!navmesh || !navmesh.walkableCellCount) {
        this.warnAiMovementFailure(actorType, {
          ...options,
          chunkKey,
          reason: navmesh ? 'navmesh-empty' : 'navmesh-missing',
          walkableCells: navmesh?.walkableCellCount ?? 0,
        });
      }
      return navmesh;
    }

    ensureNavigationMeshForActorPosition(actorType, x, z, options = {}) {
      if (!Number.isFinite(x) || !Number.isFinite(z)) {
        this.warnAiMovementFailure(actorType, { ...options, chunkKey: null, reason: 'position-invalid', x, z });
        return null;
      }
      const chunkKey = this.getChunkKeyForWorldPosition(x, z);
      const navmesh = this.ensureNavigationMeshForWorldPosition(x, z);
      if (!chunkKey) {
        this.warnAiMovementFailure(actorType, { ...options, chunkKey: null, reason: 'chunk-missing', x, z });
        return navmesh;
      }
      if (!navmesh || !navmesh.walkableCellCount) {
        this.warnAiMovementFailure(actorType, {
          ...options,
          chunkKey,
          reason: navmesh ? 'navmesh-empty' : 'navmesh-missing',
          x,
          z,
        });
      }
      return navmesh;
    }

    handleNavmeshFailureForMob(actorType, mob, context = {}) {
      const reason = typeof context.reason === 'string' && context.reason.trim().length
        ? context.reason.trim()
        : 'navmesh-missing';
      if (!mob || !mob.mesh) {
        return { action: 'ignored', reason, error: 'invalid-mob' };
      }
      const mesh = mob.mesh;
      const candidateChunks = [];
      const stageOptions = { reason: `${reason}-rebind`, stage: 'chunk-rebind' };
      const initialChunk =
        (typeof context.chunkKey === 'string' && context.chunkKey.trim()) ||
        (typeof mob.navChunkKey === 'string' && mob.navChunkKey.trim()) ||
        (typeof mob.chunkKey === 'string' && mob.chunkKey.trim()) ||
        this.getChunkKeyForWorldPosition(mesh.position.x, mesh.position.z);
      if (initialChunk) {
        candidateChunks.push(initialChunk);
      }
      if (typeof mob.chunkKey === 'string' && mob.chunkKey.trim() && !candidateChunks.includes(mob.chunkKey)) {
        candidateChunks.push(mob.chunkKey.trim());
      }
      if (typeof mob.navChunkKey === 'string' && mob.navChunkKey.trim() && !candidateChunks.includes(mob.navChunkKey)) {
        candidateChunks.push(mob.navChunkKey.trim());
      }
      const playerPosition = this.getPlayerWorldPosition ? this.getPlayerWorldPosition(this.tmpVector3) : null;
      if (playerPosition) {
        const playerChunk = this.getChunkKeyForWorldPosition(playerPosition.x, playerPosition.z);
        if (playerChunk && !candidateChunks.includes(playerChunk)) {
          candidateChunks.push(playerChunk);
        }
      }
      let recoveredNavmesh = null;
      let recoveredChunk = null;
      for (const chunkKey of candidateChunks) {
        const navmesh = this.ensureNavigationMeshForActorChunk(actorType, chunkKey, {
          ...stageOptions,
          [`${actorType}Id`]: mob.id ?? null,
        });
        if (navmesh?.walkableCellCount > 0 && Array.isArray(navmesh.cells) && navmesh.cells.length > 0) {
          recoveredNavmesh = navmesh;
          recoveredChunk = chunkKey;
          break;
        }
      }
      if (!recoveredNavmesh) {
        const fallbackNavmesh = this.ensureNavigationMeshForWorldPosition(mesh.position.x, mesh.position.z, {
          reason: `${reason}-world-fallback`,
          stage: 'chunk-rebind',
          [`${actorType}Id`]: mob.id ?? null,
        });
        if (fallbackNavmesh?.walkableCellCount > 0 && Array.isArray(fallbackNavmesh.cells) && fallbackNavmesh.cells.length > 0) {
          recoveredNavmesh = fallbackNavmesh;
          recoveredChunk = fallbackNavmesh.key || this.getChunkKeyForWorldPosition(mesh.position.x, mesh.position.z);
        }
      }
      if (recoveredNavmesh) {
        const cell = recoveredNavmesh.cells[0];
        const offset = actorType === 'golem' ? 1.1 : actorType === 'zombie' ? 0.9 : 1;
        if (Number.isFinite(cell.worldX) && Number.isFinite(cell.worldZ)) {
          const surfaceY = Number.isFinite(cell.surfaceY)
            ? cell.surfaceY
            : this.sampleGroundHeight(cell.worldX, cell.worldZ);
          mesh.position.set(cell.worldX, surfaceY + offset, cell.worldZ);
        }
        if (!mesh.userData || typeof mesh.userData !== 'object') {
          mesh.userData = {};
        }
        mesh.userData.chunkKey = recoveredChunk;
        if (actorType === 'golem') {
          mob.chunkKey = recoveredChunk;
        } else {
          mob.navChunkKey = recoveredChunk;
        }
        return { action: 'rehomed', reason, navmesh: recoveredNavmesh };
      }
      const group = actorType === 'golem' ? this.golemGroup : actorType === 'zombie' ? this.zombieGroup : null;
      const collection = actorType === 'golem' ? this.golems : actorType === 'zombie' ? this.zombies : null;
      if (Array.isArray(collection)) {
        const index = collection.indexOf(mob);
        if (index >= 0) {
          collection.splice(index, 1);
        }
      }
      if (group?.remove && mob.mesh) {
        try {
          group.remove(mob.mesh);
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Failed to detach mob mesh during navmesh failure cleanup.', error);
          }
        }
      }
      if (mob.mesh) {
        disposeObject3D(mob.mesh);
      }
      return { action: 'despawned', reason };
    }

    ensureNavigationMeshForWorldPosition(x, z, options = {}) {
      const chunkKey = this.getChunkKeyForWorldPosition(x, z);
      if (!chunkKey) {
        return null;
      }
      return this.ensureNavigationMeshForChunk(chunkKey, options);
    }

    ensureNavigationMeshForChunk(chunkKey, options = {}) {
      if (!chunkKey) {
        return null;
      }
      if (!(this.navigationMeshes instanceof Map)) {
        this.navigationMeshes = new Map();
      }
      if (this.dirtyNavigationChunks?.has(chunkKey)) {
        return this.rebuildNavigationMeshForChunk(chunkKey, { reason: options.reason ?? 'ensure-dirty' });
      }
      const navmesh = this.navigationMeshes.get(chunkKey) || null;
      if (navmesh) {
        this.validateNavigationMesh(navmesh, { chunkKey, reason: options.reason ?? 'ensure-existing' });
        return navmesh;
      }
      return this.rebuildNavigationMeshForChunk(chunkKey, { reason: options.reason ?? 'ensure-missing' });
    }

    rebuildNavigationMeshForChunk(chunkKey, options = {}) {
      if (!chunkKey) {
        return null;
      }
      if (!(this.navigationMeshes instanceof Map)) {
        this.navigationMeshes = new Map();
      }
      const chunk = this.terrainChunkMap.get(chunkKey) || null;
      if (!chunk && typeof console !== 'undefined') {
        console.error('Navigation mesh rebuild fallback — chunk missing, deriving mesh from height map.', {
          chunkKey,
          reason: options.reason ?? 'rebuild',
        });
      }
      const navmesh = this.computeNavigationMeshForChunk(chunkKey, chunk);
      if (!navmesh) {
        this.navigationMeshes.delete(chunkKey);
        if (this.dirtyNavigationChunks) {
          this.dirtyNavigationChunks.delete(chunkKey);
        }
        return null;
      }
      this.navigationMeshBuildCounter += 1;
      navmesh.revision = this.navigationMeshBuildCounter;
      navmesh.lastUpdateReason = options.reason ?? 'rebuild';
      this.navigationMeshes.set(chunkKey, navmesh);
      if (this.dirtyNavigationChunks) {
        this.dirtyNavigationChunks.delete(chunkKey);
      }
      this.validateNavigationMesh(navmesh, { chunkKey, reason: options.reason ?? 'rebuild' });
      return navmesh;
    }

    computeNavigationMeshForChunk(chunkKey, chunk = null) {
      if (!chunkKey) {
        return null;
      }
      if (!Array.isArray(this.heightMap) || !this.heightMap.length) {
        return null;
      }
      const { chunkX, chunkZ } = this.parseTerrainChunkKey(chunkKey);
      const chunkSize = this.terrainChunkSize;
      const halfWorld = WORLD_SIZE / 2;
      const cells = [];
      let minX = Infinity;
      let maxX = -Infinity;
      let minZ = Infinity;
      let maxZ = -Infinity;
      let minY = Infinity;
      let maxY = -Infinity;
      let walkableCells = 0;
      for (let localX = 0; localX < chunkSize; localX += 1) {
        const gridX = chunkX * chunkSize + localX;
        const columnRow = this.heightMap[gridX];
        if (!columnRow) continue;
        for (let localZ = 0; localZ < chunkSize; localZ += 1) {
          const gridZ = chunkZ * chunkSize + localZ;
          const columnHeight = columnRow[gridZ] ?? 0;
          if (columnHeight <= 0) continue;
          const surfaceY = columnHeight * BLOCK_SIZE;
          const worldX = (gridX - halfWorld) * BLOCK_SIZE;
          const worldZ = (gridZ - halfWorld) * BLOCK_SIZE;
          cells.push({
            gridX,
            gridZ,
            columnHeight,
            surfaceY,
            worldX,
            worldZ,
          });
          walkableCells += 1;
          if (worldX < minX) minX = worldX;
          if (worldX > maxX) maxX = worldX;
          if (worldZ < minZ) minZ = worldZ;
          if (worldZ > maxZ) maxZ = worldZ;
          if (surfaceY < minY) minY = surfaceY;
          if (surfaceY > maxY) maxY = surfaceY;
        }
      }
      if (chunk?.userData) {
        const chunkData = chunk.userData;
        if (!Number.isFinite(minY) && Number.isFinite(chunkData.minY)) {
          minY = chunkData.minY;
        }
        if (!Number.isFinite(maxY) && Number.isFinite(chunkData.maxY)) {
          maxY = chunkData.maxY;
        }
      }
      const bounds = {
        minX: Number.isFinite(minX) ? minX - BLOCK_SIZE * 0.5 : 0,
        maxX: Number.isFinite(maxX) ? maxX + BLOCK_SIZE * 0.5 : 0,
        minZ: Number.isFinite(minZ) ? minZ - BLOCK_SIZE * 0.5 : 0,
        maxZ: Number.isFinite(maxZ) ? maxZ + BLOCK_SIZE * 0.5 : 0,
        minY: Number.isFinite(minY) ? minY : 0,
        maxY: Number.isFinite(maxY) ? maxY : 0,
      };
      return {
        key: chunkKey,
        chunkX,
        chunkZ,
        generation: this.navigationMeshGeneration,
        walkableCellCount: walkableCells,
        cells,
        bounds,
        updatedAt: Date.now(),
      };
    }

    validateNavigationMesh(navmesh, context = {}) {
      if (!navmesh) {
        if (typeof console !== 'undefined') {
          console.error('Navigation mesh validation failed — mesh missing.', context);
        }
        return false;
      }
      if (!Array.isArray(navmesh.cells)) {
        if (typeof console !== 'undefined') {
          console.error('Navigation mesh validation failed — missing cell data.', {
            ...context,
            navmeshKey: navmesh.key,
          });
        }
        return false;
      }
      if (navmesh.walkableCellCount !== navmesh.cells.length) {
        navmesh.walkableCellCount = navmesh.cells.length;
      }
      const bounds = navmesh.bounds || {};
      const boundKeys = ['minX', 'maxX', 'minZ', 'maxZ', 'minY', 'maxY'];
      let boundsValid = true;
      for (const key of boundKeys) {
        if (!Number.isFinite(bounds[key])) {
          boundsValid = false;
          break;
        }
      }
      if (!boundsValid && typeof console !== 'undefined') {
        console.error('Navigation mesh validation warning — bounds unavailable or invalid.', {
          ...context,
          chunkKey: context.chunkKey ?? navmesh.key,
        });
      }
      if (!navmesh.cells.length && typeof console !== 'undefined') {
        console.error('Navigation mesh validation warning — chunk contains no walkable cells.', {
          ...context,
          chunkKey: context.chunkKey ?? navmesh.key,
        });
      }
      return boundsValid;
    }

    refreshNavigationMeshes(options = {}) {
      if (!(this.navigationMeshes instanceof Map)) {
        this.navigationMeshes = new Map();
      }
      const summary = {
        chunkCount: 0,
        walkableCells: 0,
        reason: options.reason ?? 'bulk-refresh',
        updatedAt: Date.now(),
      };
      for (const [chunkKey] of this.terrainChunkMap) {
        const navmesh = this.rebuildNavigationMeshForChunk(chunkKey, {
          reason: options.reason ?? 'bulk-refresh',
        });
        if (!navmesh) {
          continue;
        }
        summary.chunkCount += 1;
        summary.walkableCells += navmesh.walkableCellCount;
      }
      if (!this.navigationMeshSummary) {
        this.navigationMeshSummary = {
          chunkCount: summary.chunkCount,
          walkableCells: summary.walkableCells,
          reason: summary.reason,
          updatedAt: summary.updatedAt,
        };
      } else {
        this.navigationMeshSummary.chunkCount = summary.chunkCount;
        this.navigationMeshSummary.walkableCells = summary.walkableCells;
        this.navigationMeshSummary.reason = summary.reason;
        this.navigationMeshSummary.updatedAt = summary.updatedAt;
      }
      if (options.log && typeof console !== 'undefined') {
        console.error(
          `Navigation mesh refresh summary — ${summary.chunkCount} chunk meshes rebuilt, ${summary.walkableCells} walkable surfaces tracked (${summary.reason}).`,
        );
      }
      return summary;
    }

    buildRails() {
      const THREE = this.THREE;
      this.railsGroup.clear();
      this.railSegments = [];
      const segments = 22;
      const radius = WORLD_SIZE * 0.18;
      for (let i = 0; i < segments; i += 1) {
        const t = i / (segments - 1);
        const angle = (t - 0.5) * Math.PI * 0.45;
        const x = Math.sin(angle) * radius;
        const z = -t * WORLD_SIZE * 0.65;
        const ground = this.sampleGroundHeight(x, z);
        const mesh = new THREE.Mesh(this.railGeometry, this.materials.rails);
        mesh.castShadow = false;
        mesh.receiveShadow = true;
        mesh.position.set(x, ground + 0.1, z);
        mesh.rotation.y = angle * 0.6;
        mesh.matrixAutoUpdate = false;
        mesh.updateMatrix();
        mesh.visible = true;
        mesh.scale.set(1, 1, 1);
        mesh.userData = {
          type: 'rail-segment',
          baseY: mesh.position.y,
          collapseState: 'intact',
          collapseTimer: 0,
          collapseDuration: 2.6,
          baseMatrixAutoUpdate: false,
        };
        this.railsGroup.add(mesh);
        this.railSegments.push(mesh);
      }
    }

    evaluateBossChallenge() {
      if (this.victoryAchieved) {
        this.resetNetheriteChallenge();
        return;
      }
      if (this.netheriteChallengePlanned && this.railSegments.length) {
        if (!this.netheriteChallengeActive) {
          this.startNetheriteChallenge();
        }
      } else if (!this.netheriteChallengePlanned) {
        this.resetNetheriteChallenge();
      }
    }

    resetNetheriteChallenge() {
      this.netheriteChallengeActive = false;
      this.netheriteChallengeTimer = 0;
      this.netheriteNextCollapse = 0;
      this.netheriteCollapseIndex = 0;
      this.netheriteCountdownDisplay = Infinity;
      this.netheriteFailureAnnounced = false;
      this.crumblingRails = [];
      if (Array.isArray(this.railSegments)) {
        this.railSegments.forEach((segment) => {
          if (!segment) return;
          if (segment.userData) {
            segment.userData.collapseState = 'intact';
            segment.userData.collapseTimer = 0;
          }
          if (segment.scale?.set) {
            segment.scale.set(1, 1, 1);
          }
          if (segment.position && segment.userData && Number.isFinite(segment.userData.baseY)) {
            segment.position.y = segment.userData.baseY;
          }
          if (segment.updateMatrix) {
            segment.updateMatrix();
          }
          segment.visible = true;
          segment.matrixAutoUpdate = false;
        });
      }
      if (this.eternalIngot?.mesh) {
        this.challengeGroup?.remove(this.eternalIngot.mesh);
        disposeObject3D(this.eternalIngot.mesh);
      }
      if (this.eternalIngot?.light) {
        this.challengeGroup?.remove(this.eternalIngot.light);
      }
      this.eternalIngot = null;
      this.eternalIngotSpin = 0;
      if (this.started) {
        this.updatePortalProgress();
        this.updateDimensionInfoPanel();
      }
    }

    startNetheriteChallenge() {
      if (!this.netheriteChallengePlanned || this.victoryAchieved) {
        return;
      }
      if (!Array.isArray(this.railSegments) || !this.railSegments.length) {
        this.netheriteChallengeActive = false;
        return;
      }
      this.resetNetheriteChallenge();
      this.netheriteChallengeActive = true;
      this.netheriteChallengeTimer = 0;
      this.netheriteCollapseIndex = 0;
      this.netheriteNextCollapse = 6;
      this.netheriteCountdownSeconds = 45;
      this.netheriteCountdownDisplay = Infinity;
      this.netheriteFailureAnnounced = false;
      if (!this.victoryAchieved) {
        this.eternalIngotCollected = false;
      }
      this.spawnEternalIngot();
      this.showHint('Rails destabilising — reach the Eternal Ingot!');
      this.scheduleScoreSync('netherite-challenge');
      if (this.started) {
        this.updatePortalProgress();
        this.updateDimensionInfoPanel();
      }
    }

    spawnEternalIngot() {
      const THREE = this.THREE;
      if (!THREE || !this.challengeGroup) return;
      if (this.eternalIngot?.mesh) {
        this.challengeGroup.remove(this.eternalIngot.mesh);
        disposeObject3D(this.eternalIngot.mesh);
      }
      if (this.eternalIngot?.light) {
        this.challengeGroup.remove(this.eternalIngot.light);
      }
      const anchor = this.railSegments?.[this.railSegments.length - 1] || null;
      const base = anchor?.position?.clone?.() || new THREE.Vector3(0, 0, -WORLD_SIZE * 0.55);
      if (!anchor) {
        base.y = this.sampleGroundHeight(base.x, base.z) + 0.1;
      }
      const mesh = new THREE.Mesh(
        CRYSTAL_GEOMETRY,
        new THREE.MeshStandardMaterial({
          color: '#ffbf5f',
          emissive: '#ff8a3d',
          emissiveIntensity: 0.9,
          metalness: 0.35,
          roughness: 0.3,
        }),
      );
      mesh.name = 'EternalIngot';
      mesh.castShadow = true;
      mesh.receiveShadow = false;
      mesh.position.copy(base);
      mesh.position.y = (anchor?.userData?.baseY ?? base.y) + 1.6;
      this.eternalIngotBaseY = mesh.position.y;
      this.challengeGroup.add(mesh);
      let light = null;
      if (typeof THREE.PointLight === 'function') {
        light = new THREE.PointLight(0xffa94d, 1.1, 12, 1.6);
        light.position.copy(mesh.position);
        this.challengeGroup.add(light);
      }
      this.eternalIngot = { mesh, light };
      this.eternalIngotSpin = 0;
    }

    triggerRailCollapse(segment) {
      if (!segment || !segment.userData) return;
      if (segment.userData.collapseState === 'crumbling' || segment.userData.collapseState === 'collapsed') {
        return;
      }
      segment.userData.collapseState = 'crumbling';
      segment.userData.collapseTimer = 0;
      segment.userData.collapseDuration = 2.4;
      segment.userData.baseMatrixAutoUpdate = segment.matrixAutoUpdate;
      segment.matrixAutoUpdate = true;
      if (!this.crumblingRails.includes(segment)) {
        this.crumblingRails.push(segment);
      }
    }

    updateRailCollapseAnimations(delta) {
      if (!this.crumblingRails.length) return;
      const THREE = this.THREE;
      const remaining = [];
      for (const segment of this.crumblingRails) {
        const data = segment.userData || {};
        data.collapseTimer = (data.collapseTimer || 0) + delta;
        const duration = Math.max(0.1, data.collapseDuration || 2.4);
        const rawProgress = Math.min(1, data.collapseTimer / duration);
        const eased = THREE.MathUtils.smootherstep
          ? THREE.MathUtils.smootherstep(0, 1, rawProgress)
          : rawProgress * rawProgress * (3 - 2 * rawProgress);
        const scale = Math.max(0.05, 1 - eased);
        if (segment.scale?.setScalar) {
          segment.scale.setScalar(scale);
        }
        if (Number.isFinite(data.baseY)) {
          segment.position.y = data.baseY - eased * 1.8;
        }
        if (segment.updateMatrix) {
          segment.updateMatrix();
        }
        if (rawProgress >= 1) {
          segment.visible = false;
          segment.matrixAutoUpdate = data.baseMatrixAutoUpdate ?? false;
          if (segment.scale?.set) {
            segment.scale.set(1, 1, 1);
          }
          data.collapseState = 'collapsed';
        } else {
          remaining.push(segment);
        }
      }
      this.crumblingRails = remaining;
    }

    updateEternalIngot(delta) {
      if (!this.eternalIngot?.mesh) return;
      const mesh = this.eternalIngot.mesh;
      this.eternalIngotSpin += delta;
      mesh.rotation.y += delta * 2.4;
      const bob = Math.sin(this.eternalIngotSpin * 3) * 0.18;
      mesh.position.y = this.eternalIngotBaseY + bob;
      if (this.eternalIngot.light) {
        this.eternalIngot.light.position.copy(mesh.position);
        this.eternalIngot.light.intensity = 1 + Math.sin(this.eternalIngotSpin * 5) * 0.25;
      }
      const playerPosition = this.getPlayerWorldPosition(this.tmpVector3);
      if (playerPosition.distanceTo(mesh.position) < 1.4) {
        this.collectEternalIngot();
      }
    }

    updateNetheriteChallenge(delta) {
      if (!this.netheriteChallengeActive) return;
      this.netheriteChallengeTimer += delta;
      this.updateRailCollapseAnimations(delta);
      this.updateEternalIngot(delta);
      if (!this.eternalIngotCollected && this.netheriteChallengeTimer >= this.netheriteNextCollapse) {
        const candidates = this.railSegments.filter((segment) => segment?.userData?.collapseState === 'intact');
        if (candidates.length) {
          const targetIndex = Math.max(0, candidates.length - 1 - this.netheriteCollapseIndex);
          const target = candidates[targetIndex] || candidates[candidates.length - 1];
          this.triggerRailCollapse(target);
          this.netheriteCollapseIndex += 1;
        }
        this.netheriteNextCollapse += this.netheriteCollapseInterval;
      }
      const remaining = Math.max(0, this.netheriteCountdownSeconds - this.netheriteChallengeTimer);
      const seconds = Math.ceil(remaining);
      if (seconds !== this.netheriteCountdownDisplay) {
        this.netheriteCountdownDisplay = seconds;
        this.updatePortalProgress();
        this.updateDimensionInfoPanel();
      }
      if (remaining <= 0 && !this.netheriteFailureAnnounced && !this.eternalIngotCollected) {
        this.netheriteFailureAnnounced = true;
        this.handleNetheriteFailure();
      }
    }

    collectEternalIngot() {
      if (this.eternalIngotCollected) return;
      this.eternalIngotCollected = true;
      if (this.eternalIngot?.mesh) {
        this.challengeGroup?.remove(this.eternalIngot.mesh);
        disposeObject3D(this.eternalIngot.mesh);
      }
      if (this.eternalIngot?.light) {
        this.challengeGroup?.remove(this.eternalIngot.light);
      }
      this.eternalIngot = null;
      this.netheriteChallengeActive = false;
      this.showHint('Eternal Ingot secured! Portal stabilising…');
      this.collectDrops([{ item: 'eternal-ingot', quantity: 1 }]);
      this.score += 12;
      this.addScoreBreakdown('dimensions', 12);
      this.updateHud();
      this.scheduleScoreSync('eternal-ingot');
      this.triggerVictory();
    }

    handleNetheriteFailure() {
      this.showHint('The Netherite rails collapsed! Respawning…');
      this.scheduleScoreSync('netherite-collapse');
      this.resetNetheriteChallenge();
      this.handleDefeat();
      this.buildRails();
      this.spawnDimensionChests();
      this.refreshPortalState();
      this.evaluateBossChallenge();
    }

    ensureDimensionLootTablesLoaded() {
      if (!(this.dimensionLootCache instanceof Map)) {
        this.dimensionLootCache = new Map();
      }
      if (!(this.dimensionLootOrders instanceof Map)) {
        this.dimensionLootOrders = new Map();
      }
      if (!(this.dimensionLootOrderOffsets instanceof Map)) {
        this.dimensionLootOrderOffsets = new Map();
      }
      const dimensionIds = new Set([
        ...Object.keys(DIMENSION_LOOT_TABLES),
        ...DIMENSION_THEME.map((theme) => (typeof theme?.id === 'string' ? theme.id : null)).filter(Boolean),
      ]);
      const fallback = DIMENSION_LOOT_TABLES.origin || [];
      dimensionIds.forEach((dimensionId) => {
        const table = DIMENSION_LOOT_TABLES[dimensionId] || fallback;
        this.dimensionLootCache.set(dimensionId, table);
        if (!this.dimensionLootOrders.has(dimensionId)) {
          const order = createShuffledIndexOrder(table.length, `${dimensionId}:${table.length}`);
          this.dimensionLootOrders.set(dimensionId, order);
        }
        if (!this.dimensionLootOrderOffsets.has(dimensionId)) {
          this.dimensionLootOrderOffsets.set(dimensionId, 0);
        }
      });
    }

    getChestLootForDimension(dimensionId, index) {
      const normalizedId = typeof dimensionId === 'string' ? dimensionId : 'origin';
      this.ensureDimensionLootTablesLoaded();
      let tables = this.dimensionLootCache.get(normalizedId);
      if (!Array.isArray(tables) || !tables.length) {
        tables = this.dimensionLootCache.get('origin') || DIMENSION_LOOT_TABLES.origin || [];
      }
      if (!tables.length) {
        return { items: [], score: 0, message: '' };
      }
      let order = this.dimensionLootOrders.get(normalizedId);
      if (!order || !order.length) {
        order = createShuffledIndexOrder(tables.length, `${normalizedId}:${tables.length}`);
        this.dimensionLootOrders.set(normalizedId, order);
      }
      const safeIndex = Number.isFinite(index) ? Number(index) : 0;
      const wrappedIndex = ((safeIndex % order.length) + order.length) % order.length;
      const selectedIndex = order[wrappedIndex] ?? 0;
      const entry = tables[selectedIndex] || tables[0];
      return {
        items: Array.isArray(entry.items)
          ? entry.items.map((item) => ({ item: item.item, quantity: item.quantity }))
          : [],
        score: Number.isFinite(entry.score) ? entry.score : 0,
        message: entry.message || '',
      };
    }

    createChestMesh(theme) {
      const THREE = this.THREE;
      const palette = theme?.palette ?? {};
      const baseColor = palette.dirt || '#a66a33';
      const accentColor = palette.rails || '#f5b041';
      const overlayColor = '#3f2f1d';
      const group = new THREE.Group();

      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: baseColor,
        roughness: 0.72,
        metalness: 0.18,
      });
      const lidMaterial = bodyMaterial.clone();
      lidMaterial.color.set(baseColor);
      lidMaterial.color.offsetHSL(0, -0.08, 0.05);

      const strapMaterial = new THREE.MeshStandardMaterial({
        color: accentColor,
        roughness: 0.28,
        metalness: 0.82,
        emissive: new THREE.Color(accentColor),
        emissiveIntensity: 0.28,
        side: THREE.DoubleSide,
      });

      const overlayMaterial = new THREE.MeshStandardMaterial({
        color: overlayColor,
        roughness: 0.58,
        metalness: 0.22,
        emissive: new THREE.Color('#2a1a0c'),
        emissiveIntensity: 0.18,
        side: THREE.DoubleSide,
      });

      const lockMaterial = new THREE.MeshStandardMaterial({
        color: '#fde68a',
        roughness: 0.24,
        metalness: 0.9,
        emissive: new THREE.Color('#fbbf24'),
        emissiveIntensity: 0.45,
      });

      const body = new THREE.Mesh(new THREE.BoxGeometry(0.94, 0.5, 0.94), bodyMaterial);
      body.castShadow = true;
      body.receiveShadow = true;
      body.position.y = 0.25;
      group.add(body);

      const lidPivot = new THREE.Group();
      lidPivot.position.set(0, 0.5, -0.47);
      group.add(lidPivot);

      const lid = new THREE.Mesh(new THREE.BoxGeometry(0.94, 0.38, 0.94), lidMaterial);
      lid.position.set(0, 0, 0.47);
      lid.castShadow = true;
      lid.receiveShadow = true;
      lidPivot.add(lid);

      const bodyOverlay = new THREE.Mesh(new THREE.BoxGeometry(0.96, 0.08, 0.96), overlayMaterial);
      bodyOverlay.position.y = 0.24;
      body.add(bodyOverlay);

      const lidOverlay = new THREE.Mesh(new THREE.BoxGeometry(0.96, 0.08, 0.96), overlayMaterial.clone());
      lidOverlay.position.set(0, 0.22, 0);
      lid.add(lidOverlay);

      const strapFrontLower = new THREE.Mesh(new THREE.PlaneGeometry(0.22, 0.46), strapMaterial);
      strapFrontLower.position.set(0, 0.2, 0.49);
      body.add(strapFrontLower);

      const strapFrontUpper = strapFrontLower.clone();
      strapFrontUpper.position.set(0, 0.16, 0.49);
      lid.add(strapFrontUpper);

      const strapBackLower = strapFrontLower.clone();
      strapBackLower.position.z = -0.49;
      strapBackLower.rotation.y = Math.PI;
      body.add(strapBackLower);

      const strapBackUpper = strapFrontUpper.clone();
      strapBackUpper.position.z = -0.49;
      strapBackUpper.rotation.y = Math.PI;
      lid.add(strapBackUpper);

      const strapTop = new THREE.Mesh(new THREE.PlaneGeometry(0.22, 0.94), strapMaterial.clone());
      strapTop.rotation.x = -Math.PI / 2;
      strapTop.position.set(0, 0.19, 0);
      lid.add(strapTop);

      const lock = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.08), lockMaterial);
      lock.position.set(0, 0.22, 0.49);
      lock.castShadow = true;
      lock.receiveShadow = true;
      group.add(lock);

      const lockInset = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.04), overlayMaterial.clone());
      lockInset.position.set(0, -0.02, 0.05);
      lock.add(lockInset);

      group.userData = {
        lid,
        lidPivot,
        highlightMaterials: [strapMaterial, strapTop.material, lockMaterial],
        placeholder: true,
        placeholderKey: 'chest',
      };

      return group;
    }

    createPortalPlaceholderMesh(theme) {
      const THREE = this.THREE;
      if (!THREE) {
        return null;
      }
      const palette = theme?.palette ?? {};
      const frameColor = palette.stone || '#312e81';
      const swirlColor = palette.rails || '#7f5af0';
      const accentColor = palette.grass || '#2cb67d';

      const frameMaterial = new THREE.MeshStandardMaterial({
        color: frameColor,
        roughness: 0.74,
        metalness: 0.26,
      });

      const swirlMaterial = new THREE.MeshStandardMaterial({
        color: swirlColor,
        transparent: true,
        opacity: 0.85,
        emissive: new THREE.Color(swirlColor),
        emissiveIntensity: 0.45,
        roughness: 0.32,
        metalness: 0.55,
        side: THREE.DoubleSide,
      });

      const accentMaterial = new THREE.MeshStandardMaterial({
        color: accentColor,
        transparent: true,
        opacity: 0.9,
        emissive: new THREE.Color(accentColor),
        emissiveIntensity: 0.32,
        roughness: 0.35,
        metalness: 0.48,
        side: THREE.DoubleSide,
      });

      const core = new THREE.Mesh(new THREE.BoxGeometry(2.3, 3.1, 0.3), frameMaterial);
      core.castShadow = false;
      core.receiveShadow = false;

      const swirl = new THREE.Mesh(new THREE.PlaneGeometry(2.05, 2.6), swirlMaterial);
      swirl.position.z = 0.16;
      core.add(swirl);

      const swirlBack = swirl.clone();
      swirlBack.material = swirlMaterial;
      swirlBack.position.z = -0.16;
      swirlBack.rotation.y = Math.PI;
      core.add(swirlBack);

      const accentTop = new THREE.Mesh(new THREE.PlaneGeometry(1.7, 0.32), accentMaterial);
      accentTop.position.set(0, 0.75, 0.165);
      core.add(accentTop);

      const accentBottom = accentTop.clone();
      accentBottom.material = accentMaterial;
      accentBottom.position.y = -0.75;
      core.add(accentBottom);

      core.userData = {
        ...(core.userData || {}),
        highlightMaterials: [swirlMaterial, accentMaterial],
        placeholder: true,
        placeholderKey: 'portal-core',
        portalPlaceholderAnimation: {
          swirlMaterial,
          accentMaterial,
          swirlMeshes: [swirl, swirlBack],
          accentMeshes: [accentTop, accentBottom],
          accentBasePositions: [accentTop.position.y, accentBottom.position.y],
          baseSwirlEmissive: swirlMaterial.emissiveIntensity ?? 0.45,
          baseAccentEmissive: accentMaterial.emissiveIntensity ?? 0.32,
          baseSwirlOpacity: swirlMaterial.opacity ?? 0.85,
          baseAccentOpacity: accentMaterial.opacity ?? 0.9,
        },
      };

      return core;
    }

    spawnDimensionChests() {
      const chestGroup = this.ensureEntityGroup('chest');
      if (!chestGroup) return;
      this.clearChests();
      const theme = this.dimensionSettings || DIMENSION_THEME[0];
      const chestCount = CHEST_COUNT_PER_DIMENSION;
      const seedBase = (this.currentDimensionIndex + 1) * 97;
      this.chestPulseTime = 0;
      const dimensionId = typeof theme?.id === 'string' ? theme.id : 'origin';
      const lootCursorStart = this.dimensionLootOrderOffsets.get(dimensionId) || 0;
      for (let i = 0; i < chestCount; i += 1) {
        const randAngle = pseudoRandom(seedBase + i * 11.37, seedBase - i * 5.29);
        const randRadius = pseudoRandom(seedBase * 0.41 + i * 3.17, seedBase * 0.77 - i * 2.61);
        const angle = randAngle * Math.PI * 2;
        const radius = Math.max(4, WORLD_SIZE * 0.18 * (0.65 + randRadius * 0.35));
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const ground = this.sampleGroundHeight(x, z);
        const mesh = this.createChestMesh(theme);
        mesh.position.set(x, ground + 0.35, z);
        mesh.name = `LootChest-${theme?.id || 'dimension'}-${i}`;
        chestGroup.add(mesh);
        const loot = this.getChestLootForDimension(dimensionId, lootCursorStart + i);
        const chest = {
          id: `${theme?.id || 'dimension'}-${i}-${Date.now()}`,
          mesh,
          lidPivot: mesh.userData?.lidPivot ?? null,
          lid: mesh.userData?.lid ?? null,
          highlightMaterials: mesh.userData?.highlightMaterials ?? [],
          baseY: mesh.position.y,
          baseScale: {
            x: mesh.scale?.x ?? 1,
            y: mesh.scale?.y ?? 1,
            z: mesh.scale?.z ?? 1,
          },
          opened: false,
          openProgress: 0,
          loot,
          pulseOffset: randAngle * Math.PI * 2,
          glowLevel: 0.25,
          hintShown: false,
        };
        this.chests.push(chest);
      }
      this.lastChestHintAt = this.elapsed;
      this.dimensionLootOrderOffsets.set(dimensionId, lootCursorStart + chestCount);
    }

    clearChests() {
      if (this.chestGroup) {
        const children = Array.from(this.chestGroup.children);
        children.forEach((child) => {
          this.chestGroup.remove(child);
          disposeObject3D(child);
        });
      }
      this.chests = [];
      this.activeChestId = null;
    }

    findInteractableChest(range = CHEST_INTERACT_RANGE) {
      if (!this.chests.length) return null;
      const playerPosition = this.getPlayerWorldPosition(this.tmpVector3);
      let best = null;
      let bestDistance = range;
      for (const chest of this.chests) {
        if (!chest || chest.opened || !chest.mesh) continue;
        const distance = chest.mesh.position.distanceTo(playerPosition);
        if (!Number.isFinite(distance)) continue;
        if (distance <= bestDistance) {
          bestDistance = distance;
          best = chest;
        }
      }
      return best;
    }

    tryOpenNearbyChest() {
      const chest = this.findInteractableChest();
      if (!chest) {
        return false;
      }
      this.openChest(chest);
      return true;
    }

    openChest(chest) {
      if (!chest || chest.opened) return;
      chest.opened = true;
      chest.openProgress = Math.max(chest.openProgress ?? 0, 0.01);
      const loot = chest.loot || { items: [], score: 0, message: '' };
      if (Array.isArray(loot.items) && loot.items.length) {
        this.collectDrops(loot.items);
      }
      if (Number.isFinite(loot.score) && loot.score !== 0) {
        this.addScoreBreakdown('loot', loot.score);
        this.score += loot.score;
      }
      this.updateHud();
      this.scheduleScoreSync('loot-chest');
      const lootItemsForEvent = Array.isArray(loot.items)
        ? loot.items.map((entry) => {
            const itemId = entry?.item ?? null;
            const quantity = Number.isFinite(entry?.quantity) ? entry.quantity : 1;
            const definition = getItemDefinition(itemId);
            return {
              id: itemId,
              label: definition?.label ?? (itemId || 'Unknown loot'),
              quantity,
            };
          })
        : [];
      this.emitGameEvent('loot-collected', {
        chestId: chest.id ?? null,
        dimension: this.dimensionSettings?.id ?? null,
        items: lootItemsForEvent,
        score: Number.isFinite(loot.score) ? loot.score : 0,
        message: typeof loot.message === 'string' && loot.message.trim().length ? loot.message.trim() : null,
      });
      if (loot.message) {
        this.showHint(loot.message);
      }
      this.audio.play('lootChestOpen', {
        volume: 0.62,
        rate: 1.18 + Math.random() * 0.08,
      });
      this.lastChestHintAt = this.elapsed;
      console.error(
        `Loot chest interaction flagged — ${chest.id}. If rewards are missing, review the chest configuration and loot tables for this encounter.`,
      );
    }

    updateLootChests(delta) {
      if (!this.chests.length) return;
      const THREE = this.THREE;
      this.chestPulseTime += delta;
      const playerPosition = this.getPlayerWorldPosition(this.tmpVector3);
      let nearest = null;
      let nearestDistance = Infinity;
      for (const chest of this.chests) {
        if (!chest?.mesh) continue;
        const mesh = chest.mesh;
        if (!Number.isFinite(chest.baseY)) {
          chest.baseY = mesh.position.y;
        }
        if (!chest.baseScale) {
          chest.baseScale = {
            x: mesh.scale?.x ?? 1,
            y: mesh.scale?.y ?? 1,
            z: mesh.scale?.z ?? 1,
          };
        }
        const distance = mesh.position.distanceTo(playerPosition);
        if (!Number.isFinite(distance)) {
          continue;
        }
        const proximityRange = CHEST_INTERACT_RANGE + 2.5;
        const proximity = 1 - Math.min(distance, proximityRange) / proximityRange;
        const pulseSpeed = 2.4 + proximity * 3.6;
        const floatAmplitude = 0.05 + proximity * 0.08;
        const floatOffset = Math.sin(this.chestPulseTime * pulseSpeed + (chest.pulseOffset || 0)) * floatAmplitude;
        mesh.position.y = chest.baseY + Math.max(0, floatOffset);
        const scalePulse =
          Math.sin(this.chestPulseTime * (3 + proximity * 5.5) + (chest.pulseOffset || 0)) * (0.02 + proximity * 0.12);
        const targetScale = {
          x: chest.baseScale.x * (1 + scalePulse),
          y: chest.baseScale.y * (1 + scalePulse * 0.6),
          z: chest.baseScale.z * (1 + scalePulse),
        };
        mesh.scale.x = THREE.MathUtils.lerp(mesh.scale.x, targetScale.x, delta * 5.2);
        mesh.scale.y = THREE.MathUtils.lerp(mesh.scale.y, targetScale.y, delta * 5.2);
        mesh.scale.z = THREE.MathUtils.lerp(mesh.scale.z, targetScale.z, delta * 5.2);
        if (chest.lidPivot) {
          const target = chest.opened ? 1 : 0;
          const speed = chest.opened ? 3.2 : 4.5;
          chest.openProgress = THREE.MathUtils.lerp(chest.openProgress ?? 0, target, delta * speed);
          const eased = chest.openProgress * chest.openProgress;
          chest.lidPivot.rotation.x = -Math.PI * 0.6 * eased;
        }
        if (!chest.opened && distance < nearestDistance) {
          nearest = chest;
          nearestDistance = distance;
        }
        let targetGlow = chest.opened ? 0.15 : 0.35 + proximity * 0.45;
        if (!chest.opened && distance <= CHEST_INTERACT_RANGE + 0.6) {
          targetGlow = Math.max(targetGlow, 1.05);
          if (
            distance <= CHEST_INTERACT_RANGE &&
            !chest.hintShown &&
            this.elapsed - this.lastChestHintAt > CHEST_HINT_COOLDOWN
          ) {
            const interactSentence = formatKeyListForSentence(this.getActionKeyLabels('interact', { limit: 3 }));
            const chestHint = interactSentence
              ? `Press ${interactSentence} to open the loot chest.`
              : 'Use your interact control to open the loot chest.';
            this.showHint(chestHint);
            chest.hintShown = true;
            this.lastChestHintAt = this.elapsed;
          }
        }
        chest.glowLevel = THREE.MathUtils.lerp(chest.glowLevel ?? 0.25, targetGlow, delta * 4.5);
        if (Array.isArray(chest.highlightMaterials)) {
          chest.highlightMaterials.forEach((material) => {
            if (material?.emissiveIntensity !== undefined) {
              material.emissiveIntensity = chest.glowLevel * 0.45;
            }
          });
        }
      }
      this.activeChestId = nearest?.id ?? null;
    }

    computePortalAnchorGrid() {
      const half = WORLD_SIZE / 2;
      const clampIndex = (value) => Math.max(0, Math.min(WORLD_SIZE - 1, value));
      const xIndex = clampIndex(Math.round((this.portalAnchor?.x ?? 0) / BLOCK_SIZE + half));
      const zIndex = clampIndex(Math.round((this.portalAnchor?.z ?? 0) / BLOCK_SIZE + half));
      return { x: xIndex, z: zIndex };
    }

    createPortalFrameLayout() {
      const layout = [];
      for (let x = -1; x <= 1; x += 1) {
        for (let y = 0; y < 4; y += 1) {
          const required = Math.abs(x) === 1 || y === 0 || y === 3;
          layout.push({ xOffset: x, y, required });
        }
      }
      return layout;
    }

    getPortalSlotKey(gridX, gridZ, relY) {
      return `${gridX}|${gridZ}|${relY}`;
    }

    getPortalFrameSlotForPlacement(gridX, gridZ, level) {
      if (!this.portalFrameSlots?.size) {
        return null;
      }
      let baseHeight = this.initialHeightMap?.[gridX]?.[gridZ];
      if (!Number.isFinite(baseHeight)) {
        baseHeight = null;
      }
      if (Number.isFinite(baseHeight)) {
        const relY = level - baseHeight;
        if (Number.isInteger(relY) && relY >= 0) {
          const slot = this.portalFrameSlots.get(this.getPortalSlotKey(gridX, gridZ, relY));
          if (slot) {
            return slot;
          }
        }
      }
      let fallback = null;
      this.portalFrameSlots.forEach((slot) => {
        if (fallback) return;
        if (slot.gridX !== gridX || slot.gridZ !== gridZ) {
          return;
        }
        const slotBase = Number.isFinite(slot.baseHeight)
          ? slot.baseHeight
          : baseHeight ?? 0;
        if (slotBase + slot.relY === level) {
          fallback = slot;
        }
      });
      return fallback;
    }

    resetPortalFrameState() {
      this.portalFrameSlots.clear();
      this.restorePortalInteriorBlocks();
      this.portalHiddenInterior = [];
      this.portalReady = false;
      this.portalFrameFootprintValid = false;
      this.portalFrameValidationMessage = '';
      this.highlightPortalFrameIssues([]);
      const anchor = this.portalAnchorGrid || this.computePortalAnchorGrid();
      const layout = this.portalFrameLayout || this.createPortalFrameLayout();
      const initial = this.initialHeightMap;
      let requiredCount = 0;
      layout.forEach(({ xOffset, y, required }) => {
        if (!required) return;
        const gridX = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.x + xOffset));
        const gridZ = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.z));
        const slotKey = this.getPortalSlotKey(gridX, gridZ, y);
        const baseHeight = initial?.[gridX]?.[gridZ] ?? 0;
        this.portalFrameSlots.set(slotKey, {
          gridX,
          gridZ,
          relY: y,
          baseHeight,
          filled: false,
        });
        requiredCount += 1;
      });
      this.portalFrameRequiredCount = requiredCount || PORTAL_BLOCK_REQUIREMENT;
      this.portalBlocksPlaced = 0;
      this.portalFrameInteriorValid = this.checkPortalInterior();
      this.updatePortalProgress();
    }

    buildPortalFramePreview() {
      const THREE = this.THREE;
      if (!THREE) {
        return null;
      }
      if (!(this.portalFrameSlots instanceof Map) || this.portalFrameSlots.size === 0) {
        this.resetPortalFrameState();
      }
      if (!(this.portalGhostMeshes instanceof Map)) {
        this.portalGhostMeshes = new Map();
      }
      const container = this.portalGroup || this.worldRoot || this.scene;
      if (!container || typeof container.add !== 'function') {
        return null;
      }
      this.portalGhostMeshes.forEach((mesh) => {
        if (mesh?.parent && typeof mesh.parent.remove === 'function') {
          mesh.parent.remove(mesh);
        }
        disposeObject3D(mesh);
      });
      this.portalGhostMeshes.clear();
      const baseGeometry = this.blockGeometry || new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      let missingSlots = 0;
      this.portalFrameSlots.forEach((slot, key) => {
        if (!slot) {
          return;
        }
        const material = new THREE.MeshBasicMaterial({
          color: new THREE.Color('#60a5fa'),
          transparent: true,
          opacity: 0.38,
        });
        material.depthWrite = false;
        const ghost = new THREE.Mesh(baseGeometry.clone(), material);
        const worldX = (slot.gridX - WORLD_SIZE / 2) * BLOCK_SIZE;
        const worldZ = (slot.gridZ - WORLD_SIZE / 2) * BLOCK_SIZE;
        const baseHeight = Number.isFinite(slot.baseHeight) ? slot.baseHeight : 0;
        const worldY = (baseHeight + slot.relY + 0.5) * BLOCK_SIZE;
        ghost.position.set(worldX, worldY, worldZ);
        ghost.visible = true;
        ghost.renderOrder = 1;
        ghost.userData = {
          ...(ghost.userData || {}),
          portalGhost: true,
          slotKey: key,
          filled: slot.filled === true,
        };
        container.add(ghost);
        this.portalGhostMeshes.set(key, ghost);
        if (slot.filled !== true) {
          missingSlots += 1;
        }
      });
      this.portalPreviewSummary = {
        totalSlots: this.portalFrameSlots.size,
        missingFrameSlots: missingSlots,
      };
      return this.portalPreviewSummary;
    }

    updatePortalInteriorValidity() {
      const previous = this.portalFrameInteriorValid;
      this.portalFrameInteriorValid = this.checkPortalInterior();
      return previous !== this.portalFrameInteriorValid;
    }

    checkPortalInterior() {
      const anchor = this.portalAnchorGrid || this.computePortalAnchorGrid();
      if (!anchor) {
        return false;
      }
      const gridX = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.x));
      const gridZ = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.z));
      const baseHeight = this.initialHeightMap?.[gridX]?.[gridZ];
      if (baseHeight === undefined) {
        return true;
      }
      const columnKey = `${gridX}|${gridZ}`;
      const column = this.columns.get(columnKey) ?? [];
      for (let relY = 1; relY <= 2; relY += 1) {
        const index = baseHeight + relY;
        const mesh = column[index];
        if (mesh) {
          const blockType = mesh.userData?.blockType;
          if (blockType === 'stone' || mesh.userData?.hiddenForPortal) {
            continue;
          }
          return false;
        }
      }
      return true;
    }

    hidePortalInteriorBlocks() {
      this.restorePortalInteriorBlocks();
      this.portalHiddenInterior = [];
      const anchor = this.portalAnchorGrid || this.computePortalAnchorGrid();
      const gridX = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.x));
      const gridZ = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.z));
      const baseHeight = this.initialHeightMap?.[gridX]?.[gridZ] ?? 0;
      const columnKey = `${gridX}|${gridZ}`;
      const column = this.columns.get(columnKey) ?? [];
      for (let relY = 1; relY <= 2; relY += 1) {
        const index = baseHeight + relY;
        const mesh = column[index];
        if (mesh && mesh.visible !== false) {
          mesh.visible = false;
          if (mesh.userData) {
            mesh.userData.hiddenForPortal = true;
          }
          this.portalHiddenInterior.push(mesh);
        }
      }
    }

    restorePortalInteriorBlocks() {
      if (!Array.isArray(this.portalHiddenInterior) || !this.portalHiddenInterior.length) {
        this.portalHiddenInterior = [];
        return;
      }
      this.portalHiddenInterior.forEach((mesh) => {
        if (!mesh) return;
        mesh.visible = true;
        if (mesh.userData) {
          delete mesh.userData.hiddenForPortal;
        }
      });
      this.portalHiddenInterior = [];
    }

    getPortalAnchorWorldPosition(target = this.tmpVector3) {
      const THREE = this.THREE;
      const anchor = this.portalAnchorGrid || this.computePortalAnchorGrid();
      if (!anchor) {
        if (target?.set) {
          target.set(0, 0, 0);
        } else {
          target.x = 0;
          target.y = 0;
          target.z = 0;
        }
        return target;
      }
      const gridX = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.x));
      const gridZ = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.z));
      const baseHeight = this.initialHeightMap?.[gridX]?.[gridZ] ?? 0;
      const worldX = (gridX - WORLD_SIZE / 2) * BLOCK_SIZE;
      const worldZ = (gridZ - WORLD_SIZE / 2) * BLOCK_SIZE;
      const worldY = (baseHeight + 1.5) * BLOCK_SIZE;
      if (target?.set && THREE?.Vector3 && target instanceof THREE.Vector3) {
        target.set(worldX, worldY, worldZ);
      } else if (target) {
        target.x = worldX;
        target.y = worldY;
        target.z = worldZ;
      }
      return target;
    }

    isPlayerNearPortalFrame() {
      const anchorWorld = this.getPortalAnchorWorldPosition(this.tmpVector3);
      const playerPosition = this.getPlayerWorldPosition(this.tmpVector2);
      const distance = anchorWorld.distanceTo ? anchorWorld.distanceTo(playerPosition) : null;
      if (distance === null || Number.isNaN(distance)) {
        return false;
      }
      return distance <= PORTAL_INTERACTION_RANGE;
    }

    getPortalFootprint() {
      const anchor = this.portalAnchorGrid || this.computePortalAnchorGrid();
      if (!anchor) {
        return null;
      }
      const gridX = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.x));
      const gridZ = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.z));
      const baseHeight = this.initialHeightMap?.[gridX]?.[gridZ] ?? 0;
      const frame = [];
      const interior = [];
      for (let xOffset = -1; xOffset <= 1; xOffset += 1) {
        for (let relY = 0; relY <= 3; relY += 1) {
          const entry = {
            x: gridX + xOffset,
            y: baseHeight + relY,
            z: gridZ,
          };
          if (Math.abs(xOffset) === 1 || relY === 0 || relY === 3) {
            frame.push(entry);
          } else if (relY > 0 && relY < 3) {
            interior.push(entry);
          }
        }
      }
      return {
        frame,
        interior,
        orientation: 'horizontal',
        bounds: { width: 3, height: 4 },
      };
    }

    getPortalInteriorBounds(padding = 0.2) {
      const anchor = this.portalAnchorGrid || this.computePortalAnchorGrid();
      if (!anchor) {
        return null;
      }
      const gridX = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.x));
      const gridZ = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.z));
      const baseHeight = this.initialHeightMap?.[gridX]?.[gridZ] ?? 0;
      const centerX = (gridX - WORLD_SIZE / 2) * BLOCK_SIZE;
      const centerZ = (gridZ - WORLD_SIZE / 2) * BLOCK_SIZE;
      const centerY = (baseHeight + 1.5) * BLOCK_SIZE;
      const halfWidth = 0.5 + padding;
      const halfDepth = 0.45 + padding;
      const minY = baseHeight * BLOCK_SIZE - padding;
      const maxY = (baseHeight + 3) * BLOCK_SIZE + padding;
      return {
        centerX,
        centerY,
        centerZ,
        halfWidth,
        halfDepth,
        minY,
        maxY,
      };
    }

    getPortalFrameSlotBounds(slot, padding = 0.05) {
      if (!slot) {
        return null;
      }
      const gridX = Number.isFinite(slot.gridX) ? slot.gridX : null;
      const gridZ = Number.isFinite(slot.gridZ) ? slot.gridZ : null;
      if (gridX === null || gridZ === null) {
        return null;
      }
      const baseHeight = Number.isFinite(slot.baseHeight)
        ? slot.baseHeight
        : this.initialHeightMap?.[gridX]?.[gridZ] ?? 0;
      const targetLevel = baseHeight + slot.relY;
      const worldX = (gridX - WORLD_SIZE / 2) * BLOCK_SIZE;
      const worldZ = (gridZ - WORLD_SIZE / 2) * BLOCK_SIZE;
      const centerY = (targetLevel + 0.5) * BLOCK_SIZE;
      return {
        centerX: worldX,
        centerY,
        centerZ: worldZ,
        halfWidth: BLOCK_SIZE * 0.5 + padding,
        halfDepth: BLOCK_SIZE * 0.5 + padding,
        minY: targetLevel * BLOCK_SIZE - padding,
        maxY: (targetLevel + 1) * BLOCK_SIZE + padding,
      };
    }

    collectPortalFrameSlotObstructions(slot, padding = 0.05) {
      const bounds = this.getPortalFrameSlotBounds(slot, padding);
      return this.collectEntitiesWithinBounds(bounds);
    }

    getPortalSlotMesh(slot) {
      if (!slot) {
        return null;
      }
      const gridX = Number.isFinite(slot.gridX) ? slot.gridX : null;
      const gridZ = Number.isFinite(slot.gridZ) ? slot.gridZ : null;
      if (gridX === null || gridZ === null) {
        return null;
      }
      const baseHeight = Number.isFinite(slot.baseHeight)
        ? slot.baseHeight
        : this.initialHeightMap?.[gridX]?.[gridZ] ?? 0;
      const targetIndex = baseHeight + slot.relY;
      if (!Number.isInteger(targetIndex) || targetIndex < 0) {
        return null;
      }
      const columnKey = `${gridX}|${gridZ}`;
      const column = this.columns.get(columnKey) ?? [];
      return column[targetIndex] ?? null;
    }

    clearPortalFrameHighlights() {
      if (!(this.portalFrameHighlightMeshes instanceof Set)) {
        this.portalFrameHighlightMeshes = new Set();
        return;
      }
      this.portalFrameHighlightMeshes.forEach((mesh) => {
        if (!mesh) return;
        const original = mesh.userData?.portalHighlightOriginalMaterial;
        if (original) {
          mesh.material = original;
          delete mesh.userData.portalHighlightOriginalMaterial;
        } else if (mesh.userData?.blockType) {
          mesh.material = this.getMaterialForBlock(mesh.userData.blockType);
        }
      });
      this.portalFrameHighlightMeshes.clear();
    }

    highlightPortalFrameIssues(slots = []) {
      this.clearPortalFrameHighlights();
      if (!Array.isArray(slots) || !slots.length) {
        return;
      }
      const highlightMeshes = new Set();
      slots.forEach((slot) => {
        const mesh = this.getPortalSlotMesh(slot);
        if (!mesh) {
          return;
        }
        if (!mesh.userData) {
          mesh.userData = {};
        }
        if (!mesh.userData.portalHighlightOriginalMaterial) {
          mesh.userData.portalHighlightOriginalMaterial = mesh.material;
        }
        mesh.material = this.materials.portalInvalid || this.getMaterialForBlock('stone');
        highlightMeshes.add(mesh);
      });
      this.portalFrameHighlightMeshes = highlightMeshes;
    }

    validatePortalFrameFootprint(filledCount = this.portalBlocksPlaced) {
      if (!this.portalFrameSlots.size) {
        return { valid: false, message: '', highlightSlots: [] };
      }
      const highlightSet = new Set();
      let missingRequired = 0;
      let wrongMaterial = 0;
      const columnStats = new Map();

      const addColumnStat = (slot) => {
        const key = `${slot.gridX}|${slot.gridZ}`;
        let stat = columnStats.get(key);
        if (!stat) {
          stat = { slots: [], bottomY: null, topY: null };
          columnStats.set(key, stat);
        }
        stat.slots.push(slot);
        return stat;
      };

      this.portalFrameSlots.forEach((slot) => {
        const stat = addColumnStat(slot);
        const mesh = this.getPortalSlotMesh(slot);
        if (!mesh) {
          missingRequired += 1;
          return;
        }
        const blockType = mesh.userData?.blockType ?? null;
        if (blockType !== 'stone') {
          wrongMaterial += 1;
          highlightSet.add(slot);
        }
        const positionY = mesh.position?.y;
        if (Number.isFinite(positionY)) {
          if (slot.relY === 0 && stat.bottomY === null) {
            stat.bottomY = positionY;
          }
          if (slot.relY === 3) {
            stat.topY = positionY;
          }
        }
      });

      const bottomValues = [];
      columnStats.forEach((stat) => {
        if (Number.isFinite(stat.bottomY)) {
          bottomValues.push(stat.bottomY);
        }
      });
      let unevenFoundation = false;
      if (bottomValues.length > 1) {
        const minBottom = Math.min(...bottomValues);
        const maxBottom = Math.max(...bottomValues);
        if (Math.abs(maxBottom - minBottom) > 0.01) {
          unevenFoundation = true;
          columnStats.forEach((stat) => {
            if (!Number.isFinite(stat.bottomY)) {
              return;
            }
            if (Math.abs(stat.bottomY - minBottom) > 0.01) {
              stat.slots.forEach((slot) => highlightSet.add(slot));
            }
          });
        }
      }

      const topValues = [];
      columnStats.forEach((stat) => {
        if (Number.isFinite(stat.topY)) {
          topValues.push(stat.topY);
        }
      });
      let unevenTop = false;
      if (topValues.length > 1) {
        const minTop = Math.min(...topValues);
        const maxTop = Math.max(...topValues);
        if (Math.abs(maxTop - minTop) > 0.01) {
          unevenTop = true;
          columnStats.forEach((stat) => {
            if (!Number.isFinite(stat.topY)) {
              return;
            }
            if (Math.abs(stat.topY - minTop) > 0.01) {
              stat.slots.forEach((slot) => highlightSet.add(slot));
            }
          });
        }
      }

      let message = '';
      const hasPortalBlocks = filledCount > 0 || wrongMaterial > 0;
      if (wrongMaterial > 0) {
        message = 'Portal frame must be built from stone blocks in a 4×3 ring.';
      } else if (hasPortalBlocks && (unevenFoundation || unevenTop)) {
        message = 'Portal frame must form a level 4×3 ring — realign the blocks.';
      }

      const required = this.portalFrameRequiredCount || PORTAL_BLOCK_REQUIREMENT;
      const valid =
        filledCount >= required &&
        missingRequired === 0 &&
        wrongMaterial === 0 &&
        !unevenFoundation &&
        !unevenTop;

      return {
        valid,
        message,
        highlightSlots: Array.from(highlightSet),
      };
    }

    isEntityWithinPortalBounds(entry, bounds) {
      if (!entry?.position || !bounds) {
        return false;
      }
      const position = entry.position;
      const x = Number(position.x);
      const y = Number(position.y);
      const z = Number(position.z);
      if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) {
        return false;
      }
      const radius = Number.isFinite(entry.radius) ? entry.radius : 0.5;
      const bottom = Number.isFinite(entry.bottom) ? entry.bottom : y - radius;
      const top = Number.isFinite(entry.top) ? entry.top : y + radius;
      if (top < bounds.minY || bottom > bounds.maxY) {
        return false;
      }
      const dx = Math.abs(x - bounds.centerX);
      const dz = Math.abs(z - bounds.centerZ);
      if (dx > bounds.halfWidth + radius) {
        return false;
      }
      if (dz > bounds.halfDepth + radius) {
        return false;
      }
      return true;
    }

    collectEntitiesWithinBounds(bounds) {
      if (!bounds) {
        return [];
      }
      const obstructions = [];
      const addIfBlocking = (entry) => {
        if (!entry) return;
        if (this.isEntityWithinPortalBounds(entry, bounds)) {
          obstructions.push(entry);
        }
      };
      const playerBounds = this.getPlayerPhysicsBounds();
      if (playerBounds?.position) {
        const playerPosition = playerBounds.position;
        const radius = Number.isFinite(playerBounds.radius) ? playerBounds.radius : 0.6;
        const bottom = Number.isFinite(playerBounds.bottom)
          ? playerBounds.bottom
          : playerPosition.y - PLAYER_EYE_HEIGHT;
        const top = Number.isFinite(playerBounds.top)
          ? playerBounds.top
          : playerPosition.y + 0.2;
        addIfBlocking({
          kind: 'player',
          description: 'player',
          position: playerPosition,
          radius,
          bottom,
          top,
        });
      }
      if (Array.isArray(this.zombies)) {
        this.zombies.forEach((zombie) => {
          const mesh = zombie?.mesh;
          if (!mesh?.position) return;
          addIfBlocking({
            kind: 'zombie',
            description: 'zombie',
            position: mesh.position,
            radius: 0.6,
            bottom: mesh.position.y - 0.9,
            top: mesh.position.y + 0.9,
          });
        });
      }
      if (Array.isArray(this.golems)) {
        this.golems.forEach((golem) => {
          const mesh = golem?.mesh;
          if (!mesh?.position) return;
          addIfBlocking({
            kind: 'golem',
            description: 'iron golem',
            position: mesh.position,
            radius: 0.9,
            bottom: mesh.position.y - 1.1,
            top: mesh.position.y + 1.6,
          });
        });
      }
      if (Array.isArray(this.chests)) {
        this.chests.forEach((chest) => {
          const mesh = chest?.mesh;
          if (!mesh?.position) return;
          addIfBlocking({
            kind: 'chest',
            description: 'loot chest',
            position: mesh.position,
            radius: 0.6,
            bottom: mesh.position.y - 0.5,
            top: mesh.position.y + 0.5,
          });
        });
      }
      return obstructions;
    }

    collectPortalFootprintObstructions() {
      const bounds = this.getPortalInteriorBounds(0.25);
      return this.collectEntitiesWithinBounds(bounds);
    }

    formatPortalObstructionLabel(obstructions = [], fallback = '') {
      if (!Array.isArray(obstructions) || !obstructions.length) {
        return fallback;
      }
      const descriptors = [];
      obstructions.forEach((entry) => {
        if (entry?.description) {
          descriptors.push(entry.description);
        } else if (entry?.kind) {
          descriptors.push(entry.kind);
        }
      });
      if (!descriptors.length) {
        return fallback;
      }
      const unique = Array.from(new Set(descriptors));
      if (unique.length === 1) {
        return unique[0];
      }
      if (unique.length === 2) {
        return `${unique[0]} and ${unique[1]}`;
      }
      return `${unique.slice(0, -1).join(', ')}, and ${unique[unique.length - 1]}`;
    }

    formatPortalObstructionMessage(obstructions = []) {
      const label = this.formatPortalObstructionLabel(
        obstructions,
        'obstruction occupying the gateway',
      );
      if (!label) {
        return 'Portal activation blocked — clear the obstruction occupying the gateway.';
      }
      return `Portal activation blocked — clear the ${label} occupying the gateway.`;
    }

    formatPortalPlacementRejectionMessage(obstructions = []) {
      const label = this.formatPortalObstructionLabel(obstructions, 'gateway obstruction');
      if (!label) {
        return 'Portal frame placement blocked — clear the obstruction occupying the frame.';
      }
      return `Portal frame placement blocked — clear the ${label} occupying the frame.`;
    }

    logPortalFramePlacementRejection(slot, obstructions, context = {}) {
      if (typeof console === 'undefined') {
        return;
      }
      const reason = this.formatPortalObstructionLabel(obstructions, 'unknown obstruction');
      const detail = {
        slot,
        obstructions,
        context,
      };
      const message =
        `Portal frame placement rejected at (${slot?.gridX ?? '?'}, ${slot?.gridZ ?? '?'}, relY ${
          slot?.relY ?? '?'
        }) — clear the ${reason}.`;
      if (typeof console.warn === 'function') {
        console.warn(message, detail);
      } else if (typeof console.log === 'function') {
        console.log(message, detail);
      }
    }

    refreshPortalObstructionState() {
      const obstructions = this.collectPortalFootprintObstructions();
      const effectiveObstructions = this.portalDebugBypassObstructions
        ? obstructions.filter((entry) => {
            if (!entry || typeof entry !== 'object') {
              return false;
            }
            const kind = entry.kind ? String(entry.kind).toLowerCase() : '';
            if (kind === 'zombie' || kind === 'golem') {
              return false;
            }
            return true;
          })
        : obstructions;
      const blocked = effectiveObstructions.length > 0;
      const summary = blocked ? this.formatPortalObstructionMessage(effectiveObstructions) : '';
      const changed =
        this.portalFootprintObstructed !== blocked ||
        this.portalFootprintObstructionSummary !== summary;
      this.portalFootprintObstructed = blocked;
      this.portalFootprintObstructionSummary = summary;
      return { blocked, summary, obstructions: effectiveObstructions, changed };
    }

    ignitePortal(tool = 'torch') {
      if (!this.portalReady || this.portalActivated) {
        return;
      }
      const footprint = this.getPortalFootprint();
      let events = [];
      if (this.portalMechanics?.ignitePortalFrame && footprint) {
        try {
          const result = this.portalMechanics.ignitePortalFrame(footprint, { tool });
          if (Array.isArray(result?.events)) {
            events = result.events.slice();
            this.portalIgnitionLog = events.slice(0, 6);
          }
          if (result?.portal) {
            this.portalState = result.portal;
          }
        } catch (error) {
          console.warn('Portal ignition mechanics failed', error);
        }
      }
      const activated = this.activatePortal();
      if (!activated) {
        return;
      }
      this.portalReady = false;
      this.score += 5;
      this.addScoreBreakdown('portal', 5);
      const message = events.length ? events.join(' ') : 'Portal ignited — step through to travel.';
      this.showHint(message);
      this.markGuidanceProgress('portal');
      this.updateHud();
      this.scheduleScoreSync('portal-primed');
    }

    updatePortalFrameStateForColumn(gx, gz) {
      if (!this.portalFrameSlots.size) {
        return;
      }
      let changed = false;
      const columnKey = `${gx}|${gz}`;
      const column = this.columns.get(columnKey) ?? [];
      this.portalFrameSlots.forEach((slot) => {
        if (slot.gridX !== gx || slot.gridZ !== gz) {
          return;
        }
        const baseHeight = slot.baseHeight ?? this.initialHeightMap?.[slot.gridX]?.[slot.gridZ] ?? 0;
        const targetIndex = baseHeight + slot.relY;
        const mesh = column[targetIndex];
        const valid = Boolean(mesh?.userData?.blockType) && mesh.userData.blockType === 'stone';
        if (slot.filled !== valid) {
          slot.filled = valid;
          changed = true;
        }
      });
      const interiorChanged = this.updatePortalInteriorValidity();
      if (changed || interiorChanged) {
        this.recalculatePortalFrameProgress();
      }
    }

    recalculatePortalFrameProgress() {
      let filled = 0;
      this.portalFrameSlots.forEach((slot) => {
        if (slot.filled) {
          filled += 1;
        }
      });
      this.portalBlocksPlaced = filled;
      const previousMessage = this.portalFrameValidationMessage;
      const validation = this.validatePortalFrameFootprint(filled);
      this.portalFrameFootprintValid = validation.valid;
      this.portalFrameValidationMessage = validation.message || '';
      this.highlightPortalFrameIssues(validation.highlightSlots);
      if (
        validation.message &&
        validation.message !== previousMessage &&
        typeof this.showHint === 'function'
      ) {
        this.showHint(validation.message);
      }
      this.checkPortalActivation();
    }

    deactivatePortal() {
      if (this.portalMesh) {
        this.portalGroup.remove(this.portalMesh);
        disposeObject3D(this.portalMesh);
        this.portalMesh = null;
      }
      this.portalFallbackPulse = 0;
      this.portalActivated = false;
      this.portalReady = false;
      this.portalState = null;
      this.portalIgnitionLog = [];
      this.portalFootprintObstructed = false;
      this.portalFootprintObstructionSummary = '';
      this.portalDebugBypassObstructions = false;
      this.restorePortalInteriorBlocks();
      this.updatePortalInteriorValidity();
      this.updatePortalProgress();
    }

    refreshPortalState() {
      this.deactivatePortal();
      this.portalGroup.clear();
      this.portalHintShown = false;
      this.resetPortalFrameState();
    }

    activatePortal() {
      const worldUninitialised = !this.columns || this.columns.size === 0;
      if (!this.portalReady && !this.portalFrameSlots?.size && worldUninitialised) {
        this.resetPortalFrameState();
      }
      this.updatePortalInteriorValidity();
      let validation = { valid: true, message: '', highlightSlots: [] };
      if (!this.portalReady) {
        validation = this.validatePortalFrameFootprint(this.portalBlocksPlaced);
        if (!validation.valid && worldUninitialised) {
          validation = { valid: true, message: '', highlightSlots: [] };
        }
      }
      this.portalFrameFootprintValid = validation.valid;
      this.portalFrameValidationMessage = validation.message || '';
      this.highlightPortalFrameIssues(validation.highlightSlots);
      if (!validation.valid) {
        const message =
          validation.message ||
          'Portal activation aborted — portal frame must form a level 4×3 stone ring.';
        if (typeof this.showHint === 'function') {
          this.showHint(message);
        }
        this.portalIgnitionLog = [message];
        this.portalReady = false;
        if (typeof console !== 'undefined' && typeof console.error === 'function') {
          console.error(
            'Portal activation aborted — invalid frame detected. Realign the highlighted blocks before attempting ignition again.',
            {
              message,
              highlightCount: Array.isArray(validation.highlightSlots)
                ? validation.highlightSlots.length
                : 0,
            },
          );
        }
        this.updatePortalProgress();
        return false;
      }
      const { blocked, summary } = this.refreshPortalObstructionState();
      if (blocked) {
        const message = summary ||
          'Portal activation blocked — clear the obstruction occupying the gateway.';
        if (typeof this.showHint === 'function') {
          this.showHint(message);
        }
        this.portalIgnitionLog = [message];
        this.updatePortalProgress();
        return false;
      }
      const THREE = this.THREE;
      const anchor = this.portalAnchorGrid || this.computePortalAnchorGrid();
      const gridX = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.x));
      const gridZ = Math.max(0, Math.min(WORLD_SIZE - 1, anchor.z));
      const baseHeight = this.initialHeightMap?.[gridX]?.[gridZ] ?? 0;
      const anchorWorld = this.getPortalAnchorWorldPosition(this.tmpVector3);
      const worldX = anchorWorld.x;
      const worldY = anchorWorld.y;
      const worldZ = anchorWorld.z;
      this.portalGroup.clear();
      this.portalActivated = true;
      const usePlaceholder =
        this.portalShaderFallbackActive || !(this.materials.portal instanceof THREE.ShaderMaterial);
      const attachPlaceholderMesh = () => {
        const factory = this.portalShaderFallbackActive
          ? this.createPortalFallbackFlashMesh
          : this.createPortalPlaceholderMesh;
        const placeholder = factory.call(this, this.dimensionSettings || null);
        if (placeholder) {
          placeholder.position.set(worldX, worldY, worldZ);
          placeholder.rotation.y = Math.PI;
          placeholder.renderOrder = 2;
          placeholder.castShadow = false;
          placeholder.receiveShadow = false;
          placeholder.userData = {
            ...(placeholder.userData || {}),
            placeholder: true,
            placeholderKey: placeholder.userData?.placeholderKey || 'portal-core',
            placeholderReason: this.portalShaderFallbackActive ? 'shader-fallback' : 'model-missing',
            placeholderSource: this.portalShaderFallbackActive ? 'portal-fallback' : 'portal-placeholder',
          };
          this.portalGroup.add(placeholder);
        }
        return placeholder;
      };
      let portalMesh = null;
      if (usePlaceholder) {
        portalMesh = attachPlaceholderMesh();
      } else {
        try {
          if (!this.portalPlaneGeometry) {
            this.portalPlaneGeometry = new THREE.PlaneGeometry(2.4, 3.2);
          }
          const portalMaterial = this.materials.portal.clone();
          const sourceUniforms = this.materials.portal.uniforms || {};
          const cloneColor = (uniformValue, fallbackColor) => {
            if (uniformValue && typeof uniformValue.clone === 'function') {
              return uniformValue.clone();
            }
            return new THREE.Color(fallbackColor);
          };
          portalMaterial.uniforms = {
            uTime: { value: 0 },
            uColorA: { value: cloneColor(sourceUniforms.uColorA?.value, '#7f5af0') },
            uColorB: { value: cloneColor(sourceUniforms.uColorB?.value, '#2cb67d') },
          };
          portalMesh = new THREE.Mesh(this.portalPlaneGeometry, portalMaterial);
          portalMesh.position.set(worldX, worldY, worldZ + 0.02);
          portalMesh.rotation.y = Math.PI;
          portalMesh.renderOrder = 2;
          portalMesh.castShadow = false;
          portalMesh.receiveShadow = false;
          this.portalGroup.add(portalMesh);
        } catch (error) {
          this.handlePortalShaderInitialisationFailure(error);
        }
        if (!portalMesh) {
          portalMesh = attachPlaceholderMesh();
        }
      }

      if (portalMesh?.userData?.portalPlaceholderAnimation) {
        this.portalFallbackPulse = 0;
      }

      this.portalMesh = portalMesh;
      this.hidePortalInteriorBlocks();
      this.updatePortalInteriorValidity();
      this.portalHintShown = true;
      this.portalDebugBypassObstructions = false;
      this.updatePortalProgress();
      this.updateHud();
      this.scheduleScoreSync('portal-activated');
      console.info(
        'Portal activation triggered — ensure portal shaders and collision volumes initialise. Rebuild the portal pipeline if travellers become stuck.',
      );
      const activeDimension = this.dimensionSettings?.name || 'Unknown Dimension';
      console.info(
        `Portal dimension status — active dimension: ${activeDimension}. If transitions fail, verify the dimension registry and connection graph.`,
      );
      this.emitGameEvent('portal-activated', {
        dimension: this.dimensionSettings?.id ?? null,
        summary: this.createRunSummary('portal-activated'),
      });
      return true;
    }

    isPlayerNearPortal() {
      if (!this.portalMesh || !this.camera) return false;
      const playerPosition = this.getPlayerWorldPosition(this.tmpVector3);
      const distance = this.portalMesh.position.distanceTo(playerPosition);
      return distance <= PORTAL_INTERACTION_RANGE;
    }

    checkPortalActivation() {
      const required = this.portalFrameRequiredCount || PORTAL_BLOCK_REQUIREMENT;
      const ready =
        required > 0 &&
        this.portalFrameInteriorValid &&
        this.portalFrameFootprintValid &&
        this.portalBlocksPlaced >= required;
      if (this.portalActivated) {
        if (!ready) {
          this.deactivatePortal();
        } else {
          this.updatePortalProgress();
        }
        return;
      }
      if (!ready) {
        const progress = required > 0 ? this.portalBlocksPlaced / required : 0;
        if (!this.portalHintShown && progress >= 0.5) {
          this.portalHintShown = true;
          this.addScoreBreakdown('portal', 1);
          this.score += 1;
          this.updateHud();
        }
        this.portalReady = false;
        this.updatePortalProgress();
        return;
      }
      if (!this.portalReady) {
        this.portalReady = true;
        this.portalHintShown = true;
        this.portalIgnitionLog = [];
        this.addScoreBreakdown('portal', 1);
        this.score += 1;
        this.updateHud();
        this.showHint('Portal frame complete — press F to ignite your torch.');
        this.emitGameEvent('portal-ready', {
          dimension: this.dimensionSettings?.id ?? null,
          required,
          placed: this.portalBlocksPlaced,
        });
      }
      this.updatePortalProgress();
    }

    registerDimensionLifecycleHook(phase, handler) {
      if (typeof handler !== 'function') {
        return () => {};
      }
      const key = phase === 'enter' ? 'enter' : phase === 'ready' ? 'ready' : 'exit';
      const registry = this.dimensionLifecycleHooks?.[key];
      if (!registry || typeof registry.add !== 'function') {
        return () => {};
      }
      registry.add(handler);
      return () => {
        registry.delete(handler);
      };
    }

    onDimensionExit(handler) {
      return this.registerDimensionLifecycleHook('exit', handler);
    }

    onDimensionEnter(handler) {
      return this.registerDimensionLifecycleHook('enter', handler);
    }

    onDimensionReady(handler) {
      return this.registerDimensionLifecycleHook('ready', handler);
    }

    async runDimensionExitHooks(context = {}) {
      const payload = this.createDimensionTransitionPayload(context);
      this.clearZombies();
      this.clearGolems();
      this.clearChests();
      await this.invokeDimensionLifecycleHooks('exit', payload);
    }

    async runDimensionEnterHooks(context = {}) {
      const payload = this.createDimensionTransitionPayload(context);
      this.positionPlayer();
      this.evaluateBossChallenge();
      this.lastGolemSpawn = this.elapsed;
      await this.invokeDimensionLifecycleHooks('enter', payload);
    }

    async runDimensionReadyHooks(context = {}) {
      const payload = this.createDimensionTransitionPayload(context);
      await this.invokeDimensionLifecycleHooks('ready', payload);
    }

    createDimensionTransitionPayload(context = {}) {
      const hasPrevious = Object.prototype.hasOwnProperty.call(context, 'previousDimension');
      const hasNext = Object.prototype.hasOwnProperty.call(context, 'nextDimension');
      const hasTransition =
        Object.prototype.hasOwnProperty.call(context, 'transition') ||
        Object.prototype.hasOwnProperty.call(context, 'transitionResult');
      const previousDimension = hasPrevious ? context.previousDimension : context.from ?? null;
      const nextDimension = hasNext
        ? context.nextDimension
        : Object.prototype.hasOwnProperty.call(context, 'to')
        ? context.to
        : this.dimensionSettings ?? null;
      const transition = hasTransition
        ? Object.prototype.hasOwnProperty.call(context, 'transition')
          ? context.transition
          : context.transitionResult
        : null;
      return {
        experience: this,
        previousDimension,
        nextDimension,
        transition,
      };
    }

    async invokeDimensionLifecycleHooks(phase, payload) {
      const registry = this.dimensionLifecycleHooks?.[phase];
      if (!registry || typeof registry.forEach !== 'function') {
        return;
      }
      const hooks = Array.from(registry);
      for (const hook of hooks) {
        try {
          const result = hook(payload);
          if (result && typeof result.then === 'function') {
            await result;
          }
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.warn === 'function') {
            console.warn(`Dimension ${phase} hook failed`, error);
          }
        }
      }
    }

    async handleDimensionPostInit(context = {}) {
      const payload = this.createDimensionTransitionPayload(context);
      const enrichedContext = {
        ...context,
        previousDimension: payload.previousDimension,
        nextDimension: payload.nextDimension,
        transition: payload.transition,
      };
      this.triggerDimensionPostInitAnimations(enrichedContext);
      this.rebindDimensionContext();
      await this.runDimensionEnterHooks(enrichedContext);
      await this.runDimensionReadyHooks(enrichedContext);
    }

    triggerDimensionPostInitAnimations(context = {}) {
      const theme = context?.nextDimension ?? this.dimensionSettings ?? null;
      const rulesOverride =
        typeof context?.arrivalRules === 'string' && context.arrivalRules.trim()
          ? context.arrivalRules.trim()
          : typeof context?.rulesOverride === 'string' && context.rulesOverride.trim()
            ? context.rulesOverride.trim()
            : this.buildDimensionRuleSummary(theme);
      try {
        this.revealDimensionIntro(theme, { intent: 'arrival', rulesOverride });
      } catch (error) {
        console.warn('Failed to trigger dimension intro animation after transition.', error);
        if (typeof notifyLiveDiagnostics === 'function') {
          notifyLiveDiagnostics(
            'ui',
            'Failed to trigger dimension intro animation after transition.',
            { error: normaliseLiveDiagnosticError(error), reason: 'dimension-transition' },
            { level: 'warning' },
          );
        }
      }
      const optionalAnimations = [
        { method: 'playDimensionArrivalCinematics', diagnostic: 'dimension arrival cinematics' },
        { method: 'triggerAmbientArrivalEffects', diagnostic: 'dimension ambient arrival effects' },
      ];
      optionalAnimations.forEach(({ method, diagnostic }) => {
        const handler = method && typeof this[method] === 'function' ? this[method] : null;
        if (!handler) {
          return;
        }
        try {
          handler.call(this, context);
        } catch (error) {
          console.warn(`Failed to trigger ${diagnostic} after transition.`, error);
          if (typeof notifyLiveDiagnostics === 'function') {
            notifyLiveDiagnostics(
              'ui',
              `Failed to trigger ${diagnostic} after transition.`,
              { error: normaliseLiveDiagnosticError(error), reason: 'dimension-transition' },
              { level: 'warning' },
            );
          }
        }
      });
    }

    verifyDimensionAssetsAfterTransition(context = {}) {
      const reasonRaw = typeof context.reason === 'string' ? context.reason.trim() : '';
      const reason = reasonRaw.length ? reasonRaw : 'dimension-transition';
      let summary = this.lastScenePopulationSummary || null;
      if (!summary && typeof this.summariseRequiredSceneNodes === 'function') {
        try {
          summary = this.summariseRequiredSceneNodes();
          this.lastScenePopulationSummary = summary || null;
        } catch (error) {
          console.warn('Failed to summarise scene nodes during asset verification.', error);
          if (typeof notifyLiveDiagnostics === 'function') {
            notifyLiveDiagnostics(
              'scene',
              'Failed to summarise scene nodes during asset verification.',
              { error: normaliseLiveDiagnosticError(error), reason },
              { level: 'warning' },
            );
          }
        }
      }
      const contextRecord =
        this.lastScenePopulationSummaryContext || {
          reason,
          errors: [],
          reportedMissing: false,
        };
      const errors = Array.isArray(context.errors) ? context.errors : contextRecord.errors || [];
      const alreadyReported =
        contextRecord.reason === reason && contextRecord.reportedMissing === true;
      if (summary && !summary.allPresent && !alreadyReported && typeof this.reportMissingSceneObjects === 'function') {
        try {
          this.reportMissingSceneObjects(summary, { reason, errors });
          contextRecord.reportedMissing = true;
        } catch (error) {
          console.warn('Failed to report missing scene objects during asset verification.', error);
          if (typeof notifyLiveDiagnostics === 'function') {
            notifyLiveDiagnostics(
              'scene',
              'Failed to report missing scene objects during asset verification.',
              { error: normaliseLiveDiagnosticError(error), reason },
              { level: 'warning' },
            );
          }
        }
      }
      contextRecord.reason = reason;
      if (Array.isArray(errors)) {
        contextRecord.errors = errors;
      } else if (!Array.isArray(contextRecord.errors)) {
        contextRecord.errors = [];
      }
      if (!this.lastScenePopulationSummaryContext) {
        this.lastScenePopulationSummaryContext = contextRecord;
      } else {
        this.lastScenePopulationSummaryContext.reason = reason;
        this.lastScenePopulationSummaryContext.reportedMissing = contextRecord.reportedMissing;
        if (Array.isArray(contextRecord.errors)) {
          this.lastScenePopulationSummaryContext.errors = contextRecord.errors;
        }
      }
      return summary;
    }

    async advanceDimension() {
      if (!this.portalActivated || this.victoryAchieved) return;
      const performAdvance = async () => {
        this.portalActivations += 1;
        if (this.currentDimensionIndex >= DIMENSION_THEME.length - 1) {
          this.triggerVictory();
          return null;
        }
        const nextIndex = this.currentDimensionIndex + 1;
        const nextSettings = DIMENSION_THEME[nextIndex] || null;
        let pointsAwarded = 5;
        let portalLog = '';
        let transitionResult = null;
        let dimensionTravelSucceeded = true;
        const previousSettings = this.dimensionSettings;
        const rulesSummary = this.buildDimensionRuleSummary(nextSettings);
        if (this.portalMechanics?.enterPortal) {
          try {
            const result = this.portalMechanics.enterPortal(this.portalState || { active: true }, {
              name: nextSettings?.name || `Dimension ${nextIndex + 1}`,
              id: nextSettings?.id || `dimension-${nextIndex + 1}`,
              physics: {
                gravity: nextSettings?.gravity ?? this.gravityScale,
                shaderProfile: nextSettings?.id ?? 'default',
              },
              unlockPoints: 5,
              description: nextSettings?.description ?? '',
              rules: rulesSummary,
            });
            const resolvedResult = await Promise.resolve(result);
            transitionResult = resolvedResult ?? null;
            if (transitionResult?.pointsAwarded !== undefined) {
              pointsAwarded = transitionResult.pointsAwarded;
            }
            if (transitionResult?.log) {
              portalLog = transitionResult.log;
            }
            const teleportOutsideTrigger =
              transitionResult?.teleportOutsideTriggers === true ||
              transitionResult?.teleportOutsideTrigger === true ||
              transitionResult?.teleportedOutsideTrigger === true;
            dimensionTravelSucceeded =
              !teleportOutsideTrigger && transitionResult?.dimensionChanged !== false;
          } catch (error) {
            console.warn('Portal transition mechanics failed', error);
          }
        }
        const assetSummary = await this.executeDimensionTravelSequence({
          nextIndex,
          previousDimension: previousSettings,
          nextDimension: nextSettings,
          transition: transitionResult,
          rulesSummary,
        });
        if (dimensionTravelSucceeded && Number.isFinite(pointsAwarded)) {
          this.score += pointsAwarded;
          this.addScoreBreakdown('dimensions', pointsAwarded);
        }
        this.updateHud();
        this.scheduleScoreSync('dimension-advanced');
        this.audio.play('bubble', { volume: 0.5 });
        if (portalLog) {
          this.showHint(portalLog);
        }
        this.portalState = null;
        const assetsVerified = assetSummary ? assetSummary.allPresent === true : null;
        this.emitGameEvent('dimension-advanced', {
          dimension: this.dimensionSettings?.id ?? null,
          index: this.currentDimensionIndex,
          summary: this.createRunSummary('dimension-advanced'),
          assetsVerified,
        });
        this.publishStateSnapshot('dimension-advanced');
        this.markGuidanceProgress('dimension');
        return assetSummary;
      };
      try {
        await this.withGameplayAtomicSnapshot(
          { dimension: true, score: true, inventory: true },
          performAdvance,
          { scope: 'dimension-transition' },
        );
      } catch (error) {
        if (isAtomicAbortError(error)) {
          if (typeof console !== 'undefined' && typeof console.warn === 'function') {
            console.warn('Dimension travel aborted due to asset instability.', error);
          }
          notifyLiveDiagnostics(
            'dimension',
            'Dimension travel aborted due to asset instability.',
            { error: normaliseLiveDiagnosticError(error), scope: 'dimension-transition' },
            { level: 'warning' },
          );
          return;
        }
        throw error;
      }
    }

    async executeDimensionTravelSequence(context = {}) {
      const nextIndex = Number.isFinite(context.nextIndex) ? context.nextIndex : this.currentDimensionIndex + 1;
      const plannedNext =
        context.nextDimension ?? (Number.isFinite(nextIndex) ? DIMENSION_THEME[nextIndex] || null : null);
      const previousDimension = context.previousDimension ?? this.dimensionSettings ?? null;
      const transition = context.transition ?? null;
      const fallbackRules =
        typeof context.rulesSummary === 'string' && context.rulesSummary.trim().length
          ? context.rulesSummary
          : this.buildDimensionRuleSummary(plannedNext);

      await this.runDimensionExitHooks({
        previousDimension,
        nextDimension: plannedNext,
        transition,
      });

      if (Number.isFinite(nextIndex)) {
        this.applyDimensionSettings(nextIndex);
      } else {
        this.applyDimensionSettings(this.currentDimensionIndex);
      }

      if (transition?.physics?.gravity !== undefined) {
        this.gravityScale = transition.physics.gravity;
      }

      if (this.dimensionSettings) {
        console.info(
          `Dimension unlock flow fired — ${this.dimensionSettings.name}. If the unlock fails to present rewards, audit quest requirements and persistence flags.`,
        );
      }

      this.buildTerrain({ reason: 'dimension-transition', navmeshReason: 'dimension-transition' });
      this.populateSceneAfterTerrain({ reason: 'dimension-transition' });
      this.buildRails();
      this.refreshPortalState();

      const effectiveNext = this.dimensionSettings ?? plannedNext ?? null;
      const arrivalRules = this.buildDimensionRuleSummary(
        effectiveNext,
        transition?.dimensionRules ?? fallbackRules,
      );

      await this.handleDimensionPostInit({
        previousDimension,
        nextDimension: effectiveNext,
        transition,
        arrivalRules,
      });

      return this.verifyDimensionAssetsAfterTransition({
        previousDimension,
        nextDimension: effectiveNext,
        transition,
        reason: 'dimension-transition',
        errors: this.lastScenePopulationSummaryContext?.errors ?? [],
      });
    }

    rebindDimensionContext() {
      try {
        this.ensurePlayerPhysicsBody();
      } catch (error) {
        console.warn('Failed to ensure player physics body after dimension transition.', error);
        notifyLiveDiagnostics(
          'ui',
          'Failed to ensure player physics body after dimension transition.',
          { error: normaliseLiveDiagnosticError(error) },
          { level: 'warning' },
        );
      }
      try {
        if (this.cameraPerspective) {
          this.applyCameraPerspective(this.cameraPerspective);
        } else if (this.camera) {
          this.refreshCameraBaseOffset();
        }
      } catch (error) {
        console.warn('Failed to reapply camera bindings after dimension transition.', error);
        notifyLiveDiagnostics(
          'ui',
          'Failed to reapply camera bindings after dimension transition.',
          { error: normaliseLiveDiagnosticError(error) },
          { level: 'warning' },
        );
      }
      try {
        this.ensurePlayerArmsVisible();
      } catch (error) {
        console.warn('Failed to refresh player arm visibility after dimension transition.', error);
        notifyLiveDiagnostics(
          'ui',
          'Failed to refresh player arm visibility after dimension transition.',
          { error: normaliseLiveDiagnosticError(error) },
          { level: 'warning' },
        );
      }
      try {
        this.initializeMobileControls();
      } catch (error) {
        console.warn('Failed to reinitialise mobile controls after dimension transition.', error);
        notifyLiveDiagnostics(
          'ui',
          'Failed to reinitialise mobile controls after dimension transition.',
          { error: normaliseLiveDiagnosticError(error) },
          { level: 'warning' },
        );
      }
      try {
        this.bindEvents();
      } catch (error) {
        console.warn('Failed to ensure UI events remain bound after dimension transition.', error);
        notifyLiveDiagnostics(
          'ui',
          'Failed to ensure UI events remain bound after dimension transition.',
          { error: normaliseLiveDiagnosticError(error) },
          { level: 'warning' },
        );
      }
      try {
        this.updatePointerHintForInputMode();
      } catch (error) {
        console.warn('Failed to refresh pointer hint after dimension transition.', error);
        notifyLiveDiagnostics(
          'ui',
          'Failed to refresh pointer hint after dimension transition.',
          { error: normaliseLiveDiagnosticError(error) },
          { level: 'warning' },
        );
      }
      try {
        if (typeof this.refreshFirstRunTutorialContent === 'function') {
          this.refreshFirstRunTutorialContent();
        }
      } catch (error) {
        console.warn('Failed to refresh tutorial content after dimension transition.', error);
        notifyLiveDiagnostics(
          'ui',
          'Failed to refresh tutorial content after dimension transition.',
          { error: normaliseLiveDiagnosticError(error) },
          { level: 'warning' },
        );
      }
    }

    triggerVictory() {
      this.victoryAchieved = true;
      this.resetNetheriteChallenge();
      this.portalActivated = false;
      this.portalGroup.clear();
      this.portalMesh = null;
      this.score += 25;
      this.addScoreBreakdown('dimensions', 25);
      this.clearZombies();
      this.clearGolems();
      this.clearChests();
      this.updatePortalProgress();
      this.updateHud();
      this.scheduleScoreSync('victory');
      this.audio.play('victoryCheer', { volume: 0.75 });
      this.emitGameEvent('victory', { summary: this.createRunSummary('victory') });
      this.showVictoryCelebration();
      this.showVictoryBanner('Eternal Ingot secured — celebrate and share your run.');
    }

    positionPlayer() {
      this.ensurePlayerPhysicsBody();
      const spawnColumn = `${Math.floor(WORLD_SIZE / 2)}|${Math.floor(WORLD_SIZE / 2)}`;
      const column = this.columns.get(spawnColumn);
      if (column && column.length) {
        const top = column[column.length - 1];
        const spawnY = top.position.y + PLAYER_EYE_HEIGHT;
        const spawnZ = top.position.z;
        if (this.playerRig) {
          this.playerRig.position.set(top.position.x, spawnY, spawnZ);
        } else if (this.camera) {
          this.camera.position.set(top.position.x, spawnY, spawnZ);
        }
        this.clearSafeSpawnBox({ reason: 'spawn-column-ready' });
        this.totalWorldFailureActive = false;
      } else {
        if (this.playerRig) {
          this.playerRig.position.set(0, PLAYER_EYE_HEIGHT + 1, 0);
        } else if (this.camera) {
          this.camera.position.set(0, PLAYER_EYE_HEIGHT + 1, 0);
        }
        const fallback = this.ensureSafeSpawnBox('spawn-column-missing');
        const floorHeight = fallback?.userData?.floorHeight ?? 0;
        const target = this.playerRig || this.camera || null;
        if (target) {
          target.position.y = floorHeight - this.playerPhysicsCenterOffset * 2;
        }
        this.totalWorldFailureActive = true;
      }
    }

    ensureSafeSpawnBox(reason = 'unknown') {
      if (this.safeSpawnBoxGroup) {
        if (this.safeSpawnBoxGroup.userData) {
          this.safeSpawnBoxGroup.userData.reason = reason;
        }
        return this.safeSpawnBoxGroup;
      }
      const THREE = this.THREE;
      const root = this.worldRoot || this.scene;
      if (!THREE || !root || typeof root.add !== 'function') {
        return null;
      }
      const group = new THREE.Group();
      group.name = 'SafeSpawnBox';
      const floorHeight = 0;
      group.userData = {
        reason,
        floorHeight,
        safeSpawn: true,
      };
      const material = new THREE.MeshBasicMaterial({
        color: new THREE.Color('#60a5fa'),
        transparent: true,
        opacity: 0.55,
      });
      const halfWorld = WORLD_SIZE / 2;
      const baseGeometry = this.blockGeometry || new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      for (let gx = -2; gx <= 2; gx += 1) {
        for (let gz = -2; gz <= 2; gz += 1) {
          const mesh = new THREE.Mesh(baseGeometry.clone(), material.clone());
          mesh.position.set(gx * BLOCK_SIZE, floorHeight - BLOCK_SIZE / 2, gz * BLOCK_SIZE);
          mesh.castShadow = false;
          mesh.receiveShadow = false;
          mesh.userData = {
            safeSpawn: true,
            reason,
            gx: Math.floor(halfWorld + gx),
            gz: Math.floor(halfWorld + gz),
          };
          group.add(mesh);
        }
      }
      root.add(group);
      this.safeSpawnBoxGroup = group;
      this.totalWorldFailureActive = true;
      return group;
    }

    createPortalFallbackFlashMesh(theme) {
      const THREE = this.THREE;
      if (!THREE) {
        return null;
      }
      const accent = theme?.palette?.rails || '#7f5af0';
      const flashMaterial = new THREE.MeshBasicMaterial({
        color: new THREE.Color(accent),
        transparent: true,
        opacity: 0.75,
        side: THREE.DoubleSide,
      });
      const geometry = new THREE.PlaneGeometry(2.3, 3.1);
      const mesh = new THREE.Mesh(geometry, flashMaterial);
      mesh.renderOrder = 2;
      mesh.userData = {
        portalFallbackFlash: true,
        placeholder: true,
        placeholderKey: 'portal-fallback',
        placeholderReason: 'shader-fallback',
      };
      return mesh;
    }

    clearSafeSpawnBox(options = {}) {
      const group = this.safeSpawnBoxGroup;
      if (!group) {
        return false;
      }
      if (group.parent && typeof group.parent.remove === 'function') {
        group.parent.remove(group);
      }
      if (group.children?.length) {
        group.children.slice().forEach((child) => {
          try {
            disposeObject3D(child);
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Failed to dispose safe spawn box child.', error);
            }
          }
        });
      }
      try {
        disposeObject3D(group);
      } catch (error) {
        if (typeof console !== 'undefined' && typeof console.debug === 'function') {
          console.debug('Failed to dispose safe spawn box group.', error);
        }
      }
      this.safeSpawnBoxGroup = null;
      if (!options?.preserveFailureFlag) {
        this.totalWorldFailureActive = false;
      }
      return true;
    }

    spawnSafetyBlockAtPlayerFeetIfNeeded(x, z) {
      if (!Number.isFinite(x) || !Number.isFinite(z)) {
        return false;
      }
      const THREE = this.THREE;
      if (!THREE || !this.terrainGroup || !this.columns) {
        return false;
      }
      const halfWorld = WORLD_SIZE / 2;
      const gridX = Math.floor(x / BLOCK_SIZE + halfWorld);
      const gridZ = Math.floor(z / BLOCK_SIZE + halfWorld);
      if (gridX < 0 || gridX >= WORLD_SIZE || gridZ < 0 || gridZ >= WORLD_SIZE) {
        return false;
      }
      const columnKey = `${gridX}|${gridZ}`;
      const existingColumn = this.columns.get(columnKey) || [];
      if (existingColumn.length > 0) {
        return false;
      }
      const chunkKey = this.getTerrainChunkKey(gridX, gridZ);
      const chunk = this.ensureTerrainChunk(chunkKey);
      if (!chunk) {
        return false;
      }
      const material = this.materials?.stone?.clone
        ? this.materials.stone.clone()
        : new THREE.MeshBasicMaterial({ color: new THREE.Color('#64748b') });
      const block = new THREE.Mesh(this.blockGeometry.clone(), material);
      const worldX = (gridX - halfWorld) * BLOCK_SIZE;
      const worldZ = (gridZ - halfWorld) * BLOCK_SIZE;
      const level = existingColumn.length;
      block.position.set(worldX, (level + 0.5) * BLOCK_SIZE, worldZ);
      block.castShadow = true;
      block.receiveShadow = true;
      block.userData = {
        columnKey,
        level,
        gx: gridX,
        gz: gridZ,
        blockType: 'stone',
        chunkKey,
        safetyBlock: true,
      };
      chunk.add(block);
      existingColumn.push(block);
      this.columns.set(columnKey, existingColumn);
      if (Array.isArray(this.heightMap?.[gridX])) {
        this.heightMap[gridX][gridZ] = existingColumn.length;
      }
      this.markTerrainChunkDirty(chunkKey);
      if (typeof this.scheduleNavigationMeshMaintenance === 'function') {
        this.scheduleNavigationMeshMaintenance('safety-block');
      }
      return true;
    }

    ensureMovementBindingsConfigured() {
      if (!this.keyBindings || typeof this.keyBindings !== 'object') {
        this.keyBindings = {};
      }
      const missing = [];
      MOVEMENT_ACTIONS.forEach((action) => {
        const keys = this.keyBindings?.[action];
        if (Array.isArray(keys) && keys.length) {
          return;
        }
        const baseFallback = Array.isArray(this.baseKeyBindings?.[action])
          ? this.baseKeyBindings[action]
          : null;
        const defaultFallback = Array.isArray(this.defaultKeyBindings?.[action])
          ? this.defaultKeyBindings[action]
          : null;
        const fallback = baseFallback && baseFallback.length ? baseFallback : defaultFallback;
        if (Array.isArray(fallback) && fallback.length) {
          this.keyBindings[action] = [...fallback];
          missing.push({ action, restored: true, keys: [...fallback] });
        } else {
          this.keyBindings[action] = [];
          missing.push({ action, restored: false, keys: [] });
        }
      });
      if (!missing.length) {
        return false;
      }
      const restoredCount = missing.filter((entry) => entry.restored).length;
      const unresolvedCount = missing.length - restoredCount;
      let message = 'Movement key bindings were missing; restored defaults where available.';
      if (restoredCount && unresolvedCount) {
        message =
          'Movement key bindings were missing; restored defaults where available and flagged unresolved actions for review.';
      } else if (!restoredCount) {
        message = 'Movement key bindings were missing but no defaults were available to restore.';
      }
      const detail = {
        restoredCount,
        unresolvedCount,
        actions: missing.map((entry) => ({
          action: entry.action,
          restored: entry.restored,
          keys: entry.keys,
        })),
      };
      notifyLiveDiagnostics('movement', message, detail, { level: 'warning' });
      if (typeof console !== 'undefined' && typeof console.warn === 'function') {
        console.warn(message, detail);
      }
      return restoredCount > 0;
    }

    buildKeyBindings({ includeStored = true } = {}) {
      const base = this.baseKeyBindings
        ? cloneKeyBindingMap(this.baseKeyBindings)
        : cloneKeyBindingMap(this.defaultKeyBindings);
      if (!includeStored) {
        return base;
      }
      const stored = this.loadStoredKeyBindingOverrides();
      return mergeKeyBindingMaps(base, stored);
    }

    loadStoredKeyBindingOverrides() {
      if (typeof window === 'undefined' || !window.localStorage) {
        return null;
      }
      try {
        const raw = window.localStorage.getItem(KEY_BINDINGS_STORAGE_KEY);
        if (!raw) {
          return null;
        }
        const parsed = JSON.parse(raw);
        return normaliseKeyBindingMap(parsed);
      } catch (error) {
        console.debug('Failed to load key bindings from storage.', error);
        notifyLiveDiagnostics(
          'hotkey',
          'Failed to load key bindings from storage.',
          { error: normaliseLiveDiagnosticError(error) },
          { level: 'warning' },
        );
        return null;
      }
    }

    persistKeyBindings() {
      if (typeof window === 'undefined' || !window.localStorage) {
        return;
      }
      try {
        const base = this.baseKeyBindings || this.defaultKeyBindings || {};
        const overrides = {};
        Object.entries(this.keyBindings || {}).forEach(([action, keys]) => {
          if (!Array.isArray(keys)) {
            return;
          }
          const baseline = base[action] || [];
          if (!this.areKeyListsEqual(keys, baseline)) {
            overrides[action] = [...keys];
          }
        });
        if (Object.keys(overrides).length) {
          window.localStorage.setItem(KEY_BINDINGS_STORAGE_KEY, JSON.stringify(overrides));
        } else {
          window.localStorage.removeItem(KEY_BINDINGS_STORAGE_KEY);
        }
      } catch (error) {
        console.debug('Failed to persist key bindings.', error);
        notifyLiveDiagnostics(
          'hotkey',
          'Failed to persist key bindings.',
          { error: normaliseLiveDiagnosticError(error) },
          { level: 'warning' },
        );
      }
    }

    setKeyBinding(action, keys, options = {}) {
      const { persist = true } = options;
      if (typeof action !== 'string' || !action.trim()) {
        return false;
      }
      const normalised = normaliseKeyBindingValue(keys);
      let nextKeys = normalised;
      if (!nextKeys.length) {
        const fallback = this.baseKeyBindings?.[action.trim()];
        nextKeys = fallback ? [...fallback] : [];
      }
      const changed = this.applyKeyBinding(action.trim(), nextKeys);
      if (changed) {
        this.ensureMovementBindingsConfigured();
        if (persist) {
          this.persistKeyBindings();
        }
        this.refreshFirstRunTutorialContent();
      }
      return changed;
    }

    setKeyBindings(overrides, options = {}) {
      const { persist = true } = options;
      const normalised = normaliseKeyBindingMap(overrides);
      if (!normalised) {
        return false;
      }
      let changed = false;
      Object.entries(normalised).forEach(([action, keys]) => {
        const updated = this.applyKeyBinding(action, [...keys]);
        if (updated) {
          changed = true;
        }
      });
      if (changed) {
        this.ensureMovementBindingsConfigured();
        if (persist) {
          this.persistKeyBindings();
        }
        this.refreshFirstRunTutorialContent();
      }
      return changed;
    }

    resetKeyBindings(options = {}) {
      const { persist = true } = options;
      this.keyBindings = this.buildKeyBindings({ includeStored: false });
      this.ensureMovementBindingsConfigured();
      if (persist) {
        this.persistKeyBindings();
      }
      this.refreshFirstRunTutorialContent();
      return cloneKeyBindingMap(this.keyBindings);
    }

    getKeyBindings() {
      return cloneKeyBindingMap(this.keyBindings);
    }

    runControlUiSyncCheck(context = {}) {
      const reason = typeof context.reason === 'string' && context.reason.trim().length
        ? context.reason.trim()
        : 'control-ui-sync';
      const controlsSnapshot = this.getKeyBindings();
      const hudSnapshot = cloneKeyBindingMap(this.controlMapBase || this.defaultKeyBindings);
      let settingsSnapshot = null;
      const scope = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : null;
      const controlApi = scope?.InfiniteRailsControls || null;
      if (controlApi && typeof controlApi.get === 'function') {
        try {
          const raw = controlApi.get();
          const normalised = normaliseKeyBindingMap(raw);
          if (normalised) {
            settingsSnapshot = cloneKeyBindingMap(normalised);
          }
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Failed to capture settings control bindings for sync check.', error);
          }
        }
      }
      if (!settingsSnapshot) {
        settingsSnapshot = cloneKeyBindingMap(hudSnapshot);
      }
      const normaliseKeys = (map, action) => {
        const values = Array.isArray(map?.[action]) ? map[action] : [];
        return values
          .map((value) => (typeof value === 'string' ? value.trim() : ''))
          .filter((value) => value.length > 0)
          .sort((a, b) => a.localeCompare(b));
      };
      const arraysEqual = (a, b) => {
        if (a.length !== b.length) {
          return false;
        }
        for (let index = 0; index < a.length; index += 1) {
          if (a[index] !== b[index]) {
            return false;
          }
        }
        return true;
      };
      const actions = new Set([
        ...Object.keys(controlsSnapshot),
        ...Object.keys(hudSnapshot),
        ...Object.keys(settingsSnapshot),
      ]);
      const mismatches = [];
      actions.forEach((action) => {
        const controlKeys = normaliseKeys(controlsSnapshot, action);
        const hudKeys = normaliseKeys(hudSnapshot, action);
        const settingsKeys = normaliseKeys(settingsSnapshot, action);
        if (!arraysEqual(controlKeys, hudKeys)) {
          mismatches.push({ action, source: 'controls', target: 'hud', sourceKeys: controlKeys, targetKeys: hudKeys });
        }
        if (!arraysEqual(controlKeys, settingsKeys)) {
          mismatches.push({ action, source: 'controls', target: 'settings', sourceKeys: controlKeys, targetKeys: settingsKeys });
        }
        if (!arraysEqual(hudKeys, settingsKeys)) {
          mismatches.push({ action, source: 'hud', target: 'settings', sourceKeys: hudKeys, targetKeys: settingsKeys });
        }
      });
      const freezeBindingMap = (map) => {
        const clone = cloneKeyBindingMap(map);
        Object.keys(clone).forEach((key) => {
          if (Array.isArray(clone[key])) {
            clone[key] = Object.freeze([...clone[key]]);
          }
        });
        return Object.freeze(clone);
      };
      const metaContext = {
        ...context,
        reason,
        touchPreferred: Boolean(this.isTouchPreferred),
        mobileControlsActive: Boolean(this.mobileControlsActive),
      };
      this.lastControlUiSyncContext = Object.freeze({ ...metaContext });
      this.lastControlUiSyncSnapshots = Object.freeze({
        controls: freezeBindingMap(controlsSnapshot),
        hud: freezeBindingMap(hudSnapshot),
        settings: freezeBindingMap(settingsSnapshot),
      });
      const inSync = mismatches.length === 0;
      if (!inSync) {
        const { reason: reasonMeta, ...contextDetail } = metaContext;
        this.recordMajorIssue('Input bindings desynchronised — HUD or settings showing stale controls.', {
          scope: 'input-binding-sync',
          code: 'control-ui-sync',
          reason: reasonMeta,
          context: contextDetail,
          mismatches,
        });
      } else {
        this.clearMajorIssues('input-binding-sync');
      }
      return inSync;
    }

    getDefaultKeyBindings() {
      return cloneKeyBindingMap(this.defaultKeyBindings);
    }

    getActionKeyLabels(action, options = {}) {
      const { limit = null } = options ?? {};
      if (typeof action !== 'string' || !action.trim()) {
        return [];
      }
      const binding = this.keyBindings?.[action.trim()] ?? [];
      const seen = new Set();
      const labels = [];
      binding.forEach((code) => {
        const label = formatKeyLabel(code);
        if (!label || seen.has(label)) {
          return;
        }
        seen.add(label);
        labels.push(label);
      });
      if (typeof limit === 'number' && Number.isFinite(limit) && limit >= 0) {
        return labels.slice(0, Math.floor(limit));
      }
      return labels;
    }

    getActionKeySummary(action, options = {}) {
      const { limit = null, fallback = '' } = options ?? {};
      const labels = this.getActionKeyLabels(action, { limit });
      return joinKeyLabels(labels, { fallback });
    }

    getCombinedActionLabels(actions = [], options = {}) {
      const { limitPerAction = null } = options ?? {};
      const labels = [];
      const seen = new Set();
      actions.forEach((action) => {
        const actionLabels = this.getActionKeyLabels(action, { limit: limitPerAction });
        actionLabels.forEach((label) => {
          if (!label || seen.has(label)) {
            return;
          }
          seen.add(label);
          labels.push(label);
        });
      });
      return labels;
    }

    getMovementKeySets() {
      const actions = ['moveForward', 'moveLeft', 'moveBackward', 'moveRight'];
      const primary = [];
      const secondary = [];
      let hasSecondary = true;
      actions.forEach((action) => {
        const labels = this.getActionKeyLabels(action);
        if (labels.length) {
          primary.push(labels[0]);
        }
        if (labels.length > 1) {
          secondary.push(labels[1]);
        } else {
          hasSecondary = false;
        }
      });
      return {
        primary,
        secondary: hasSecondary && secondary.length === actions.length ? secondary : [],
      };
    }

    getMovementKeySummary(options = {}) {
      const { joiner = ' / ', fallback = '' } = options ?? {};
      const { primary } = this.getMovementKeySets();
      const filtered = primary.filter((label) => typeof label === 'string' && label.trim());
      if (!filtered.length) {
        return fallback;
      }
      return filtered.join(joiner);
    }

    getPointerTutorialMessage() {
      const movementSummary = this.getMovementKeySummary({ fallback: '' });
      if (movementSummary) {
        return `Click the viewport to capture your mouse, then use ${movementSummary} to move and left-click to mine.`;
      }
      return POINTER_TUTORIAL_MESSAGE;
    }

    getPointerLockFallbackMessage() {
      return POINTER_LOCK_FALLBACK_MESSAGE;
    }

    showPointerLockFallbackNotice(message) {
      const text = typeof message === 'string' && message.trim() ? message.trim() : this.getPointerLockFallbackMessage();
      if (this.playerHintEl) {
        this.playerHintEl.textContent = text;
        this.playerHintEl.setAttribute('data-variant', 'warning');
        this.playerHintEl.classList.add('visible');
      }
      this.pointerLockFallbackNoticeShown = true;
      this.pointerLockFallbackMessageActive = true;
      this.lastHintMessage = text;
      this.updatePointerHintForInputMode(text);
      this.schedulePointerHintAutoHide(8);
    }

    applyKeyBinding(action, keys) {
      if (typeof action !== 'string' || !Array.isArray(keys)) {
        return false;
      }
      const trimmedAction = action.trim();
      if (!trimmedAction) {
        return false;
      }
      const filteredKeys = [];
      const seen = new Set();
      keys.forEach((key) => {
        if (typeof key !== 'string') {
          return;
        }
        const trimmed = key.trim();
        if (!trimmed || seen.has(trimmed)) {
          return;
        }
        seen.add(trimmed);
        filteredKeys.push(trimmed);
      });
      const nextKeys = filteredKeys.length
        ? filteredKeys
        : [...(this.baseKeyBindings?.[trimmedAction] ?? [])];
      const current = this.keyBindings?.[trimmedAction] ?? [];
      if (this.areKeyListsEqual(current, nextKeys)) {
        return false;
      }
      if (!this.keyBindings) {
        this.keyBindings = {};
      }
      this.keyBindings[trimmedAction] = [...nextKeys];
      return true;
    }

    areKeyListsEqual(a = [], b = []) {
      if (a.length !== b.length) {
        return false;
      }
      for (let index = 0; index < a.length; index += 1) {
        if (a[index] !== b[index]) {
          return false;
        }
      }
      return true;
    }

    isKeyForAction(code, action) {
      if (!code || !action) {
        return false;
      }
      const binding = this.keyBindings?.[action];
      if (!binding || !binding.length) {
        return false;
      }
      return binding.includes(code);
    }

    isActionActive(action) {
      const binding = this.keyBindings?.[action];
      if (!binding || !binding.length) {
        return false;
      }
      return binding.some((code) => this.keys?.has(code));
    }

    isMovementKey(code) {
      if (!code) {
        return false;
      }
      return MOVEMENT_ACTIONS.some((action) => this.isKeyForAction(code, action));
    }

    getHotbarSlotFromKey(code) {
      if (!code) {
        return null;
      }
      for (let slot = 1; slot <= HOTBAR_SLOTS; slot += 1) {
        if (this.isKeyForAction(code, `hotbar${slot}`)) {
          return slot - 1;
        }
      }
      return null;
    }

    bindEvents() {
      if (this.eventsBound) {
        return;
      }
      this.boundEventDisposers = [];
      this.boundEventRecords = [];
      if (this.eventBindingFailureNotices instanceof Set) {
        this.eventBindingFailureNotices.clear();
      } else {
        this.eventBindingFailureNotices = new Set();
      }
      this.eventBindingFailures = [];
      const add = (target, eventName, handler, context, eventOptions) => {
        this.addSafeEventListener(target, eventName, handler, { context, eventOptions });
      };
      POINTER_LOCK_CHANGE_EVENTS.forEach((eventName) => {
        add(document, eventName, this.onPointerLockChange, 'tracking pointer lock state');
      });
      POINTER_LOCK_ERROR_EVENTS.forEach((eventName) => {
        add(document, eventName, this.onPointerLockError, 'handling pointer lock errors');
      });
      add(document, 'visibilitychange', this.onVisibilityChange, 'monitoring tab visibility');
      add(document, 'keydown', this.onKeyDown, 'processing keyboard input');
      add(document, 'keyup', this.onKeyUp, 'releasing keyboard input');
      const view = typeof window !== 'undefined' ? window : null;
      if (view) {
        add(view, 'keydown', this.onKeyDown, 'processing keyboard input (window fallback)');
        add(view, 'keyup', this.onKeyUp, 'releasing keyboard input (window fallback)');
      }
      if (this.canvas) {
        if (typeof this.canvas.setAttribute === 'function') {
          const existingTabIndex = this.canvas.getAttribute ? this.canvas.getAttribute('tabindex') : null;
          if (existingTabIndex === null) {
            this.canvas.setAttribute('tabindex', '0');
          }
        }
        add(this.canvas, 'keydown', this.onKeyDown, 'processing keyboard input (canvas focus fallback)');
        add(this.canvas, 'keyup', this.onKeyUp, 'releasing keyboard input (canvas focus fallback)');
      }
      add(document, 'mousemove', this.onMouseMove, 'tracking pointer movement');
      add(document, 'mousedown', this.onMouseDown, 'handling pointer presses');
      add(document, 'mouseup', this.onMouseUp, 'handling pointer releases');
      add(window, 'resize', this.onResize, 'resizing the renderer');
      add(window, 'beforeunload', this.onBeforeUnload, 'saving session state before unload');
      add(window, 'online', this.onNetworkOnline, 'retrying texture streams after network recovery');
      add(this.canvas, 'wheel', this.onCanvasWheel, 'scrolling the viewport', { passive: false });
      const pointerTargets = this.getPointerInputTargets();
      pointerTargets.forEach((target) => {
        add(target, 'pointerdown', this.onTouchLookPointerDown, 'starting touch look drag', {
          passive: false,
        });
      });
      add(window, 'pointermove', this.onTouchLookPointerMove, 'tracking touch look drag', {
        passive: false,
      });
      add(window, 'pointerup', this.onTouchLookPointerUp, 'ending touch look drag');
      add(window, 'pointercancel', this.onTouchLookPointerUp, 'cancelling touch look drag');
      add(window, 'pointerdown', this.onGlobalPointerDown, 'tracking global pointer activity', {
        passive: true,
      });
      add(window, 'touchstart', this.onGlobalTouchStart, 'tracking touch activity', { passive: true });
      pointerTargets.forEach((target) => {
        add(target, 'click', this.onCanvasPointerLock, 'engaging pointer lock');
        add(target, 'contextmenu', this.preventContextMenu, 'preventing context menu');
      });
      add(this.hotbarEl, 'click', this.onHotbarClick, 'selecting hotbar slots');
      add(this.craftLauncherButton, 'click', this.onOpenCrafting, 'opening crafting');
      add(this.closeCraftingButton, 'click', this.onCloseCrafting, 'closing crafting');
      add(this.craftingModal, 'click', this.onCraftingModalBackdrop, 'handling crafting modal backdrop');
      add(this.craftButton, 'click', this.onCraftButton, 'crafting items');
      add(this.clearCraftButton, 'click', this.onClearCraft, 'clearing craft sequence');
      add(this.craftSequenceEl, 'click', this.onCraftSequenceClick, 'managing craft sequence');
      add(this.craftSuggestionsEl, 'click', this.onCraftSuggestionClick, 'choosing craft suggestion');
      add(this.craftingSearchResultsEl, 'click', this.onCraftSuggestionClick, 'choosing search suggestion');
      add(this.craftingInventoryEl, 'click', this.onCraftingInventoryClick, 'selecting crafting resources');
      add(this.craftingInventoryEl, 'pointerover', this.onCraftingInventoryFocus, 'highlighting crafting inventory');
      add(this.craftingInventoryEl, 'focusin', this.onCraftingInventoryFocus, 'focusing crafting inventory');
      add(this.craftingInventoryEl, 'pointerout', this.onCraftingInventoryBlur, 'clearing crafting hover');
      add(this.craftingInventoryEl, 'focusout', this.onCraftingInventoryBlur, 'blurring crafting inventory');
      add(this.extendedInventoryEl, 'pointerover', this.onCraftingInventoryFocus, 'highlighting extended inventory');
      add(this.extendedInventoryEl, 'focusin', this.onCraftingInventoryFocus, 'focusing extended inventory');
      add(this.extendedInventoryEl, 'pointerout', this.onCraftingInventoryBlur, 'clearing extended inventory hover');
      add(this.extendedInventoryEl, 'focusout', this.onCraftingInventoryBlur, 'blurring extended inventory');
      add(this.craftSuggestionsEl, 'pointerover', this.onCraftSuggestionFocus, 'highlighting craft suggestion');
      add(this.craftSuggestionsEl, 'focusin', this.onCraftSuggestionFocus, 'focusing craft suggestion');
      add(this.craftSuggestionsEl, 'pointerout', this.onCraftSuggestionBlur, 'clearing craft suggestion hover');
      add(this.craftSuggestionsEl, 'focusout', this.onCraftSuggestionBlur, 'blurring craft suggestion');
      add(this.craftingSearchResultsEl, 'pointerover', this.onCraftSuggestionFocus, 'highlighting search suggestion');
      add(this.craftingSearchResultsEl, 'focusin', this.onCraftSuggestionFocus, 'focusing search suggestion');
      add(this.craftingSearchResultsEl, 'pointerout', this.onCraftSuggestionBlur, 'clearing search suggestion hover');
      add(this.craftingSearchResultsEl, 'focusout', this.onCraftSuggestionBlur, 'blurring search suggestion');
      add(this.craftSequenceEl, 'pointerover', this.onCraftSequenceFocus, 'highlighting craft sequence');
      add(this.craftSequenceEl, 'focusin', this.onCraftSequenceFocus, 'focusing craft sequence');
      add(this.craftSequenceEl, 'pointerout', this.onCraftSequenceBlur, 'clearing craft sequence hover');
      add(this.craftSequenceEl, 'focusout', this.onCraftSequenceBlur, 'blurring craft sequence');
      add(this.extendedInventoryEl, 'click', this.onExtendedInventoryClick, 'managing extended inventory');
      add(this.openCraftingSearchButton, 'click', this.onOpenCraftingSearchClick, 'opening crafting search');
      add(this.closeCraftingSearchButton, 'click', this.onCloseCraftingSearchClick, 'closing crafting search');
      add(this.craftingSearchInput, 'input', this.onCraftSearchInput, 'filtering crafting search');
      add(this.inventorySortButton, 'click', this.onInventorySort, 'sorting inventory');
      add(this.closeInventoryButton, 'click', this.onInventoryToggle, 'closing inventory');
      this.openInventoryButtons.forEach((el) => {
        add(el, 'click', this.onInventoryToggle, 'toggling inventory');
      });
      add(this.ui?.dimensionInfoEl || null, 'click', this.onVictoryReplay, 'triggering victory replay');
      add(this.victoryCloseButton, 'click', this.onVictoryClose, 'closing victory overlay');
      add(this.victoryShareButton, 'click', this.onVictoryShare, 'sharing victory summary');
      this.attachPointerPreferenceObserver();
      this.eventsBound = true;
    }

    unbindEvents() {
      if (!this.eventsBound) {
        return;
      }
      this.boundEventDisposers.forEach((dispose) => {
        try {
          dispose();
        } catch (error) {
          if (typeof console !== 'undefined') {
            console.debug('Failed to dispose event listener cleanly.', error);
          }
        }
      });
      this.boundEventDisposers = [];
      this.boundEventRecords = [];
      if (this.detachPointerPreferenceObserver) {
        try {
          this.detachPointerPreferenceObserver();
        } catch (error) {
          console.debug('Failed to detach pointer preference observer', error);
        }
      }
      this.pointerPreferenceObserver = null;
      this.detachPointerPreferenceObserver = null;
      this.teardownMobileControls();
      this.cancelPointerLockRetry();
      this.pointerLockRetryAttempts = 0;
      this.eventsBound = false;
    }

    getPointerLockElement() {
      if (typeof document === 'undefined') {
        return null;
      }
      return (
        document.pointerLockElement ||
        document.mozPointerLockElement ||
        document.webkitPointerLockElement ||
        null
      );
    }

    cancelPointerLockRetry() {
      if (!this.pointerLockRetryTimer) {
        return;
      }
      const scope = typeof window !== 'undefined' ? window : globalThis;
      scope.clearTimeout(this.pointerLockRetryTimer);
      this.pointerLockRetryTimer = null;
    }

    schedulePointerLockRetry(delayMs = POINTER_LOCK_RETRY_DELAY_MS) {
      if (!this.canvas) {
        return;
      }
      const scope = typeof window !== 'undefined' ? window : globalThis;
      this.cancelPointerLockRetry();
      const timeout = Number.isFinite(delayMs) && delayMs > 0 ? delayMs : POINTER_LOCK_RETRY_DELAY_MS;
      this.pointerLockRetryTimer = scope.setTimeout(() => {
        this.pointerLockRetryTimer = null;
        if (!this.canvas || this.pointerLocked || this.getPointerLockElement() === this.canvas) {
          return;
        }
        this.attemptPointerLock();
      }, timeout);
    }

    attemptPointerLockRecovery(reason = 'unknown') {
      if (!this.canvas || typeof this.attemptPointerLock !== 'function') {
        return false;
      }
      const currentElement = this.getPointerLockElement ? this.getPointerLockElement() : null;
      if (currentElement === this.canvas || this.pointerLocked === true) {
        return true;
      }
      if (this.pointerLockFallbackActive) {
        if (typeof this.enablePointerLockFallback === 'function') {
          this.enablePointerLockFallback('recovery-blocked', null, {
            message: this.getPointerLockFallbackMessage?.(),
          });
        }
        return false;
      }
      try {
        this.attemptPointerLock();
        this.schedulePointerLockRetry(POINTER_LOCK_RETRY_DELAY_MS);
        this.emitGameEvent('pointer-lock-recovery', { reason, success: true });
        return true;
      } catch (error) {
        if (typeof this.enablePointerLockFallback === 'function') {
          this.enablePointerLockFallback('recovery-error', error);
        }
        this.emitGameEvent('pointer-lock-recovery', { reason, success: false, error });
        return false;
      }
    }

    handlePointerLockChange() {
      this.pointerLocked = this.getPointerLockElement() === this.canvas;
      if (this.pointerLocked) {
        this.cancelPointerLockRetry();
        this.pointerLockRetryAttempts = 0;
        this.pointerLockBlockWarningIssued = false;
        this.pointerLockFallbackActive = false;
        this.pointerLockWarningShown = false;
        this.pointerLockFallbackNoticeShown = false;
        if (this.pointerLockFallbackMessageActive && this.playerHintEl) {
          this.playerHintEl.classList.remove('visible');
          this.playerHintEl.removeAttribute('data-variant');
        }
        this.pointerLockFallbackMessageActive = false;
        this.endPointerFallbackDrag();
        this.markInteraction();
        this.cancelPointerHintAutoHide();
        this.hidePointerHint(true);
        this.setHudInteractionState(true, { timeoutMs: 0 });
        return;
      }
      this.markInteraction();
      if (this.pointerLockFallbackActive) {
        this.updatePointerHintForInputMode(this.getPointerLockFallbackMessage());
        this.schedulePointerHintAutoHide(8);
      } else {
        this.showDesktopPointerTutorialHint();
      }
      this.refreshHudInteractionState();
    }

    handlePointerLockError(event) {
      this.pointerLocked = false;
      this.cancelPointerHintAutoHide();
      const error = event?.error || event || null;
      const attempts = this.pointerLockRetryAttempts ?? 0;
      if (!this.pointerLockFallbackActive && attempts < POINTER_LOCK_MAX_RETRIES) {
        this.pointerLockRetryAttempts = attempts + 1;
        const backoff = POINTER_LOCK_RETRY_DELAY_MS * Math.pow(2, this.pointerLockRetryAttempts - 1);
        this.schedulePointerLockRetry(backoff);
        if (typeof console !== 'undefined' && !this.pointerLockBlockWarningIssued) {
          if (error) {
            console.warn(
              'Pointer lock request was blocked by the browser or an extension. Retrying shortly.',
              error,
            );
          } else {
            console.warn('Pointer lock request was blocked by the browser or an extension. Retrying shortly.');
          }
          this.pointerLockBlockWarningIssued = true;
        }
        this.updatePointerHintForInputMode(POINTER_LOCK_RETRY_HINT_MESSAGE);
        this.schedulePointerHintAutoHide(4);
        return;
      }
      if (typeof console !== 'undefined' && attempts >= POINTER_LOCK_MAX_RETRIES) {
        if (error) {
          console.warn(
            'Pointer lock could not be acquired after multiple attempts. The browser or an extension may be blocking mouse capture. Falling back to drag-to-look controls.',
            error,
          );
        } else {
          console.warn(
            'Pointer lock could not be acquired after multiple attempts. The browser or an extension may be blocking mouse capture. Falling back to drag-to-look controls.',
          );
        }
      }
      this.enablePointerLockFallback('error', error, { message: POINTER_LOCK_FALLBACK_MESSAGE });
    }

    attemptPointerLock() {
      if (!this.canvas) {
        return;
      }
      const requestPointerLock =
        this.canvas.requestPointerLock ||
        this.canvas.mozRequestPointerLock ||
        this.canvas.webkitRequestPointerLock;
      if (typeof requestPointerLock !== 'function') {
        this.enablePointerLockFallback('unsupported');
        return;
      }
      const requestWithoutOptions = (initialError = null) => {
        try {
          const fallbackResult = requestPointerLock.call(this.canvas);
          if (fallbackResult && typeof fallbackResult.catch === 'function') {
            fallbackResult.catch((fallbackError) => {
              this.enablePointerLockFallback('request-rejected', fallbackError || initialError);
            });
          }
        } catch (fallbackError) {
          this.enablePointerLockFallback('request-error', fallbackError || initialError);
        }
      };
      try {
        const result = requestPointerLock.call(this.canvas, { unadjustedMovement: true });
        if (result && typeof result.catch === 'function') {
          result.catch((error) => {
            requestWithoutOptions(error);
          });
        }
      } catch (error) {
        requestWithoutOptions(error);
      }
    }

    handleCanvasPointerLockRequest() {
      if (!this.canvas) {
        return;
      }
      this.markInteraction();
      this.cancelPointerLockRetry();
      this.pointerLockRetryAttempts = 0;
      this.pointerLockBlockWarningIssued = false;
      if (this.pointerLocked || this.getPointerLockElement() === this.canvas) {
        return;
      }
      if (typeof this.canvas.focus === 'function') {
        try {
          this.canvas.focus({ preventScroll: true });
        } catch (error) {
          try {
            this.canvas.focus();
          } catch (nestedError) {
            console.debug('Canvas focus unavailable in this browser.', nestedError);
          }
        }
      }
      this.attemptPointerLock();
      this.updatePointerHintForInputMode();
    }

    handleMouseMove(event) {
      if (this.pointerLocked) {
        this.markInteraction();
        this.yaw -= event.movementX * POINTER_SENSITIVITY;
        this.pitch -= event.movementY * POINTER_SENSITIVITY;
        const maxPitch = Math.PI / 2 - 0.01;
        this.pitch = Math.max(-maxPitch, Math.min(maxPitch, this.pitch));
        return;
      }
      if (!this.pointerLockFallbackActive) {
        return;
      }
      if (!this.pointerFallbackDragging) {
        if (event.buttons === 0) {
          return;
        }
        this.pointerFallbackDragging = true;
        if (typeof event.buttons === 'number') {
          if (event.buttons & 1) {
            this.pointerFallbackButton = 0;
          } else if (event.buttons & 2) {
            this.pointerFallbackButton = 2;
          } else if (event.buttons & 4) {
            this.pointerFallbackButton = 1;
          } else {
            this.pointerFallbackButton = null;
          }
        } else {
          this.pointerFallbackButton = this.pointerFallbackButton ?? 0;
        }
        this.pointerFallbackLast = { x: event.clientX ?? 0, y: event.clientY ?? 0 };
      }
      if (event.buttons === 0) {
        this.endPointerFallbackDrag();
        return;
      }
      this.markInteraction();
      if (!this.pointerFallbackLast) {
        this.pointerFallbackLast = { x: event.clientX ?? 0, y: event.clientY ?? 0 };
      }
      const movementX = Number.isFinite(event.movementX)
        ? event.movementX
        : (event.clientX ?? 0) - this.pointerFallbackLast.x;
      const movementY = Number.isFinite(event.movementY)
        ? event.movementY
        : (event.clientY ?? 0) - this.pointerFallbackLast.y;
      this.pointerFallbackLast = { x: event.clientX ?? 0, y: event.clientY ?? 0 };
      this.yaw -= movementX * POINTER_SENSITIVITY;
      this.pitch -= movementY * POINTER_SENSITIVITY;
      const maxPitch = Math.PI / 2 - 0.01;
      this.pitch = Math.max(-maxPitch, Math.min(maxPitch, this.pitch));
      if (event.preventDefault) {
        event.preventDefault();
      }
    }

    handleMouseUp(event) {
      this.markInteraction();
      if (!this.pointerLockFallbackActive || !this.pointerFallbackDragging) {
        return;
      }
      if (
        typeof event?.button === 'number' &&
        this.pointerFallbackButton !== null &&
        event.button !== this.pointerFallbackButton
      ) {
        return;
      }
      this.endPointerFallbackDrag();
      this.refreshHudInteractionState();
    }

    handleKeyDown(event) {
      if (event && event.__infiniteRailsHandled) {
        return;
      }
      if (event) {
        event.__infiniteRailsHandled = true;
      }
      this.markInteraction();
      const code = normalizeKeyboardEventCode(event);
      if (code) {
        this.keys.add(code);
      }
      if (this.isMovementKey(code) || this.isKeyForAction(code, 'jump')) {
        event.preventDefault();
      }
      if (this.isKeyForAction(code, 'moveForward') && !event.repeat) {
        this.handleMovementInputDetected('moveForward', { source: 'keyboard' });
      }
      if (this.isKeyForAction(code, 'moveBackward') && !event.repeat) {
        this.handleMovementInputDetected('moveBackward', { source: 'keyboard' });
      }
      if (this.isKeyForAction(code, 'moveLeft') && !event.repeat) {
        this.handleMovementInputDetected('moveLeft', { source: 'keyboard' });
      }
      if (this.isKeyForAction(code, 'moveRight') && !event.repeat) {
        this.handleMovementInputDetected('moveRight', { source: 'keyboard' });
      }
      if (this.isKeyForAction(code, 'resetPosition')) {
        this.resetPosition();
        event.preventDefault();
      }
      if (this.isKeyForAction(code, 'interact')) {
        const openedChest = this.tryOpenNearbyChest();
        if (openedChest) {
          event.preventDefault();
          return;
        }
        if (this.portalActivated && this.isPlayerNearPortal()) {
          this.advanceDimension();
        } else if (this.portalReady && this.isPlayerNearPortalFrame()) {
          this.ignitePortal('torch');
        }
        event.preventDefault();
      }
      if (this.isKeyForAction(code, 'placeBlock')) {
        this.placeBlock();
        event.preventDefault();
      }
      if (this.isKeyForAction(code, 'toggleCameraPerspective') && !event.repeat) {
        this.toggleCameraPerspective();
        event.preventDefault();
      }
      if (this.isKeyForAction(code, 'toggleCrafting')) {
        const open = this.craftingModal?.hidden !== false;
        this.toggleCraftingModal(open);
        event.preventDefault();
      }
      if (this.isKeyForAction(code, 'toggleInventory')) {
        const open = this.inventoryModal?.hidden !== false;
        this.toggleInventoryModal(open);
        event.preventDefault();
      }
      if (this.isKeyForAction(code, 'openGuide') && !event.repeat) {
        this.lastGuideTrigger = this.openGuideButton || this.lastGuideTrigger;
        const open = this.guideModalEl?.hidden !== false;
        this.toggleGuideModal(open, { focusTarget: this.guideCloseButtons?.[0] || null });
        event.preventDefault();
      }
      if (this.isKeyForAction(code, 'toggleTutorial') && !event.repeat) {
        const visible = this.firstRunTutorialEl ? this.firstRunTutorialEl.hidden === false : false;
        if (visible) {
          const markSeen = this.firstRunTutorialMarkOnDismiss;
          const showBriefingAfter = this.firstRunTutorialShowBriefingOnDismiss;
          this.hideFirstRunTutorial({ markSeen, showBriefingAfter });
        } else {
          this.showFirstRunTutorial({ autoFocus: true });
        }
        event.preventDefault();
      }
      if (this.isKeyForAction(code, 'toggleDeveloperOverlay') && !event.repeat) {
        this.toggleDeveloperLogOverlay('keyboard');
        event.preventDefault();
      }
      if (this.isKeyForAction(code, 'closeMenus')) {
        this.toggleCraftingModal(false);
        this.toggleInventoryModal(false);
        this.toggleGuideModal(false, { returnFocus: false });
      }
      const hotbarSlot = this.getHotbarSlotFromKey(code);
      if (hotbarSlot !== null) {
        this.selectHotbarSlot(hotbarSlot, true);
        event.preventDefault();
      }
    }

    handleKeyUp(event) {
      if (event && event.__infiniteRailsHandled) {
        return;
      }
      if (event) {
        event.__infiniteRailsHandled = true;
      }
      this.markInteraction();
      const code = normalizeKeyboardEventCode(event);
      if (code) {
        this.keys.delete(code);
      }
      this.refreshHudInteractionState();
    }

    handleMovementInputDetected(actionLabel, options = {}) {
      const diagnostics = this.movementBindingDiagnostics;
      const sourceValue =
        typeof options?.source === 'string' && options.source.trim().length
          ? options.source.trim()
          : '';
      if (diagnostics) {
        const now = this.getHighResTimestamp();
        const throttle = Number.isFinite(diagnostics.noticeThrottleMs)
          ? diagnostics.noticeThrottleMs
          : 1500;
        const lastNotice = Number.isFinite(diagnostics.lastNoticeAt) ? diagnostics.lastNoticeAt : 0;
        if (!lastNotice || now - lastNotice >= throttle) {
          diagnostics.lastNoticeAt = now;
          const consoleRef = typeof console !== 'undefined' ? console : null;
          if (consoleRef) {
            const actionSegment = actionLabel ? ` (${actionLabel})` : '';
            const sourceSegment = sourceValue ? ` via ${sourceValue}` : '';
            const message =
              `Movement input detected${actionSegment}${sourceSegment}. ` +
              'If the avatar fails to advance, confirm control bindings and resolve any locked physics/body constraints or failed transform updates blocking motion.';
            if (typeof consoleRef.error === 'function') {
              consoleRef.error(message);
            } else if (typeof consoleRef.warn === 'function') {
              consoleRef.warn(message);
            } else if (typeof consoleRef.log === 'function') {
              consoleRef.log(message);
            }
          }
        }
      }
      this.queueMovementBindingValidation(actionLabel, { source: sourceValue });
    }

    queueMovementBindingValidation(actionLabel, options = {}) {
      const diagnostics = this.movementBindingDiagnostics;
      if (!diagnostics) {
        return;
      }
      const THREE = this.THREE;
      const anchor = this.getMovementAnchorPosition();
      const avatarAnchor = this.getPlayerAvatarWorldPosition(diagnostics.avatarProbe || null);
      const sourceValue =
        typeof options?.source === 'string' && options.source.trim().length
          ? options.source.trim()
          : null;
      if (!anchor && !avatarAnchor) {
        diagnostics.pending = false;
        this.validateMovementBindings(null, null, null, null, actionLabel || null, sourceValue);
        diagnostics.key = null;
        diagnostics.source = null;
        return;
      }
      if (anchor) {
        if (!diagnostics.initialPosition || typeof diagnostics.initialPosition.copy !== 'function') {
          diagnostics.initialPosition =
            THREE && typeof THREE.Vector3 === 'function' ? new THREE.Vector3() : null;
        }
        if (!diagnostics.initialPosition) {
          diagnostics.pending = false;
          this.validateMovementBindings(anchor, null, avatarAnchor, null, actionLabel || null, sourceValue);
          diagnostics.key = null;
          diagnostics.source = null;
          return;
        }
        diagnostics.initialPosition.copy(anchor);
      } else {
        diagnostics.initialPosition = null;
      }
      if (avatarAnchor) {
        if (!diagnostics.initialAvatarPosition || typeof diagnostics.initialAvatarPosition.copy !== 'function') {
          diagnostics.initialAvatarPosition =
            THREE && typeof THREE.Vector3 === 'function' ? new THREE.Vector3() : null;
        }
        if (diagnostics.initialAvatarPosition) {
          diagnostics.initialAvatarPosition.copy(avatarAnchor);
        }
      } else {
        diagnostics.initialAvatarPosition = null;
      }
      diagnostics.pending = true;
      diagnostics.triggeredAt = this.getHighResTimestamp();
      diagnostics.key = typeof actionLabel === 'string' ? actionLabel : null;
      diagnostics.source = sourceValue;
    }

    getMovementAnchorPosition() {
      const THREE = this.THREE;
      const diagnostics = this.movementBindingDiagnostics || null;
      const ensureProbe = () => {
        if (diagnostics?.anchorProbe && typeof diagnostics.anchorProbe.set === 'function') {
          return diagnostics.anchorProbe;
        }
        if (THREE && typeof THREE.Vector3 === 'function') {
          const probe = new THREE.Vector3();
          if (diagnostics) {
            diagnostics.anchorProbe = probe;
          }
          return probe;
        }
        return null;
      };
      const physicsBody = this.playerPhysicsBody || this.ensurePlayerPhysicsBody();
      if (physicsBody && typeof physicsBody.getWorldPosition === 'function') {
        const probe = ensureProbe();
        if (probe) {
          try {
            physicsBody.getWorldPosition(probe);
            return probe;
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Unable to resolve player physics body world position for diagnostics.', error);
            }
          }
        }
      }
      if (this.playerRig && typeof this.playerRig.getWorldPosition === 'function') {
        const probe = ensureProbe();
        if (probe) {
          try {
            this.playerRig.getWorldPosition(probe);
            return probe;
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Unable to resolve player rig world position for diagnostics.', error);
            }
          }
        }
      }
      if (this.playerRig?.position) {
        return this.playerRig.position;
      }
      if (this.camera && typeof this.camera.getWorldPosition === 'function') {
        const probe = ensureProbe();
        if (probe) {
          try {
            this.camera.getWorldPosition(probe);
            return probe;
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Unable to resolve camera world position for diagnostics.', error);
            }
          }
        }
      }
      if (this.camera?.position) {
        return this.camera.position;
      }
      return null;
    }

    evaluateMovementBindingDiagnostics() {
      const diagnostics = this.movementBindingDiagnostics;
      if (!diagnostics || !diagnostics.pending) {
        return;
      }
      const actionLabel = diagnostics.key || null;
      const sourceLabel = diagnostics.source || null;
      const anchor = this.getMovementAnchorPosition();
      const avatarAnchor = this.getPlayerAvatarWorldPosition(diagnostics.avatarProbe || null);
      if (!anchor && !avatarAnchor) {
        diagnostics.pending = false;
        this.validateMovementBindings(null, null, null, null, actionLabel, sourceLabel);
        diagnostics.key = null;
        diagnostics.source = null;
        return;
      }
      if (anchor && (!diagnostics.initialPosition || typeof diagnostics.initialPosition.copy !== 'function')) {
        diagnostics.initialPosition =
          anchor && typeof anchor.clone === 'function'
            ? anchor.clone()
            : this.THREE && typeof this.THREE.Vector3 === 'function'
              ? new this.THREE.Vector3().copy(anchor)
              : null;
        diagnostics.pending = false;
        diagnostics.key = null;
        diagnostics.source = null;
        return;
      }
      if (avatarAnchor && (!diagnostics.initialAvatarPosition || typeof diagnostics.initialAvatarPosition.copy !== 'function')) {
        diagnostics.initialAvatarPosition =
          avatarAnchor && typeof avatarAnchor.clone === 'function'
            ? avatarAnchor.clone()
            : this.THREE && typeof this.THREE.Vector3 === 'function'
              ? new this.THREE.Vector3().copy(avatarAnchor)
              : null;
        diagnostics.pending = false;
        diagnostics.key = null;
        diagnostics.source = null;
        return;
      }
      const canMeasureDisplacement =
        anchor && diagnostics.initialPosition && typeof anchor.distanceToSquared === 'function';
      const displacementSq = canMeasureDisplacement
        ? anchor.distanceToSquared(diagnostics.initialPosition)
        : null;
      const canMeasureAvatarDisplacement =
        avatarAnchor && diagnostics.initialAvatarPosition && typeof avatarAnchor.distanceToSquared === 'function';
      const avatarDisplacementSq = canMeasureAvatarDisplacement
        ? avatarAnchor.distanceToSquared(diagnostics.initialAvatarPosition)
        : null;
      const movedByRig = Number.isFinite(displacementSq) && displacementSq > 0.0025;
      const movedByAvatar = Number.isFinite(avatarDisplacementSq) && avatarDisplacementSq > 0.0025;
      if (movedByRig || movedByAvatar) {
        diagnostics.pending = false;
        diagnostics.key = null;
        diagnostics.source = null;
        return;
      }
      const now = this.getHighResTimestamp();
      if (now - diagnostics.triggeredAt < diagnostics.timeoutMs) {
        return;
      }
      diagnostics.pending = false;
      this.validateMovementBindings(anchor, displacementSq, avatarAnchor, avatarDisplacementSq, actionLabel, sourceLabel);
      diagnostics.key = null;
      diagnostics.source = null;
    }

    validateMovementBindings(anchor, displacementSq, avatarAnchor, avatarDisplacementSq, actionLabel, sourceLabel) {
      const consoleRef = typeof console !== 'undefined' ? console : null;
      if (!consoleRef) {
        return;
      }
      const warn =
        typeof consoleRef.warn === 'function'
          ? consoleRef.warn.bind(consoleRef)
          : typeof consoleRef.error === 'function'
            ? consoleRef.error.bind(consoleRef)
            : typeof consoleRef.log === 'function'
              ? consoleRef.log.bind(consoleRef)
              : null;
      const groupCollapsed =
        typeof consoleRef.groupCollapsed === 'function' ? consoleRef.groupCollapsed.bind(consoleRef) : null;
      const groupEnd = typeof consoleRef.groupEnd === 'function' ? consoleRef.groupEnd.bind(consoleRef) : null;
      const records = Array.isArray(this.boundEventRecords) ? this.boundEventRecords : [];
      const hasDocumentKeydown = records.some(
        (record) => record && record.eventName === 'keydown' && record.targetLabel === 'document',
      );
      const hasDocumentKeyup = records.some(
        (record) => record && record.eventName === 'keyup' && record.targetLabel === 'document',
      );
      const hasWindowKeydown = records.some(
        (record) => record && record.eventName === 'keydown' && record.targetLabel === 'window',
      );
      const hasWindowKeyup = records.some(
        (record) => record && record.eventName === 'keyup' && record.targetLabel === 'window',
      );
      const hasCanvasKeydown = records.some(
        (record) => record && record.eventName === 'keydown' && record.targetLabel === 'canvas',
      );
      const hasCanvasKeyup = records.some(
        (record) => record && record.eventName === 'keyup' && record.targetLabel === 'canvas',
      );
      const summariseVector = (vector) => {
        if (!vector || typeof vector.x !== 'number' || typeof vector.y !== 'number' || typeof vector.z !== 'number') {
          return null;
        }
        return {
          x: Number.parseFloat(vector.x.toFixed(3)),
          y: Number.parseFloat(vector.y.toFixed(3)),
          z: Number.parseFloat(vector.z.toFixed(3)),
        };
      };
      const diagnostics = this.movementBindingDiagnostics || {};
      const rigPosition = this.playerRig?.position || null;
      const rigSummary = summariseVector(rigPosition);
      const initialRigSummary = summariseVector(diagnostics.initialPosition);
      const cameraPosition = this.camera?.position || null;
      const cameraSummary = summariseVector(cameraPosition);
      let avatarWorldSummary = summariseVector(avatarAnchor);
      if (!avatarWorldSummary && this.playerAvatar && typeof this.playerAvatar.getWorldPosition === 'function' && this.THREE?.Vector3) {
        const probe = new this.THREE.Vector3();
        try {
          this.playerAvatar.getWorldPosition(probe);
          avatarWorldSummary = {
            x: Number.parseFloat(probe.x.toFixed(3)),
            y: Number.parseFloat(probe.y.toFixed(3)),
            z: Number.parseFloat(probe.z.toFixed(3)),
          };
        } catch (error) {
          if (typeof consoleRef.debug === 'function') {
            consoleRef.debug('Unable to read player avatar world position for diagnostics.', error);
          }
        }
      }
      const initialAvatarSummary = summariseVector(diagnostics.initialAvatarPosition);
      const avatarAttached = Boolean(this.playerAvatar && this.playerAvatar.parent === this.playerRig);
      const physicsBody = this.ensurePlayerPhysicsBody();
      const physicsBounds = this.getPlayerPhysicsBounds();
      const physicsPositionSummary = physicsBounds?.position ? summariseVector(physicsBounds.position) : null;
      const physicsRadiusSummary = Number.isFinite(physicsBounds?.radius)
        ? Number.parseFloat(physicsBounds.radius.toFixed(3))
        : null;
      const physicsTopSummary = Number.isFinite(physicsBounds?.top)
        ? Number.parseFloat(physicsBounds.top.toFixed(3))
        : null;
      const physicsBottomSummary = Number.isFinite(physicsBounds?.bottom)
        ? Number.parseFloat(physicsBounds.bottom.toFixed(3))
        : null;
      const anchorSummary = summariseVector(anchor);
      const message =
        'Movement diagnostics: input registered but no player displacement detected. Verify keyboard listeners, avatar rig transforms, and mesh parenting.';
      const report = {
        input: {
          action: actionLabel || null,
          source: sourceLabel || null,
        },
        keyboardListeners: {
          document: { keydown: hasDocumentKeydown, keyup: hasDocumentKeyup },
          window: { keydown: hasWindowKeydown, keyup: hasWindowKeyup },
          canvas: { keydown: hasCanvasKeydown, keyup: hasCanvasKeyup },
        },
        displacementSq,
        rig: {
          present: Boolean(this.playerRig),
          position: rigSummary,
          initialPosition: initialRigSummary,
          avatarAttached,
        },
        camera: {
          present: Boolean(this.camera),
          position: cameraSummary,
        },
        physics: {
          present: Boolean(physicsBody),
          position: physicsPositionSummary,
          radius: physicsRadiusSummary,
          top: physicsTopSummary,
          bottom: physicsBottomSummary,
        },
        avatarWorldPosition: avatarWorldSummary,
        avatarInitialPosition: initialAvatarSummary,
        avatarDisplacementSq,
        avatar: {
          present: Boolean(this.playerAvatar),
          attachedToRig: avatarAttached,
          currentPosition: avatarWorldSummary,
          initialPosition: initialAvatarSummary,
          displacementSq: avatarDisplacementSq,
        },
        anchorPosition: anchorSummary,
      };
      notifyLiveDiagnostics('movement', message, report, { level: 'warning' });
      if (!warn) {
        return;
      }
      if (groupCollapsed && groupEnd) {
        groupCollapsed(message);
        warn('Input summary', report.input);
        warn('Keyboard listener coverage', report.keyboardListeners);
        warn('Rig status', report.rig);
        warn('Rig initial position', report.rig.initialPosition);
        warn('Camera status', report.camera);
        warn('Physics body status', report.physics);
        warn('Avatar mesh position', report.avatarWorldPosition);
        warn('Avatar initial position', report.avatarInitialPosition);
        warn('Avatar displacement squared', report.avatarDisplacementSq);
        warn('Anchor position', report.anchorPosition);
        warn('Displacement squared', report.displacementSq);
        groupEnd();
      } else {
        warn(message, report);
      }
    }

    handleResize() {
      if (!this.renderer || !this.camera) return;
      const width = this.canvas.clientWidth || window.innerWidth || 1;
      const height = this.canvas.clientHeight || window.innerHeight || 1;
      this.renderer.setSize(width, height, false);
      this.updateCameraFrustum(width, height);
      const touchPreference = this.detectTouchPreferred();
      if (touchPreference !== this.isTouchPreferred) {
        this.isTouchPreferred = touchPreference;
        this.initializeMobileControls();
      }
      this.updatePointerHintForInputMode();
      this.refreshFirstRunTutorialContent();
    }

    handleBeforeUnload() {
      this.cancelQueuedModelPreload();
      if (!this.started || this.unloadBeaconSent) {
        return;
      }
      this.unloadBeaconSent = true;
      try {
        this.savePersistentUnlocks();
      } catch (error) {
        console.debug('Failed to persist crafting unlocks before unload', error);
      }
      try {
        this.persistIdentitySnapshot();
      } catch (error) {
        console.debug('Failed to persist identity snapshot before unload', error);
      }
      const summary = this.updateLocalScoreEntry('unload');
      if (!summary || !this.apiBaseUrl) {
        return;
      }
      const baseUrl = typeof this.apiBaseUrl === 'string' ? this.apiBaseUrl.replace(/\/$/, '') : '';
      if (!baseUrl) {
        return;
      }
      const url = `${baseUrl}/scores`;
      const payload = JSON.stringify(summary);
      let delivered = false;
      const nav = typeof navigator !== 'undefined' ? navigator : null;
      if (nav?.sendBeacon) {
        try {
          delivered = nav.sendBeacon(url, payload);
        } catch (error) {
          console.debug('Score beacon sendBeacon failed', error);
          delivered = false;
        }
      }
      if (!delivered && typeof fetch === 'function') {
        try {
          fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              Accept: 'application/json',
            },
            body: payload,
            keepalive: true,
            credentials: 'omit',
          }).catch(() => {});
        } catch (error) {
          console.debug('Score beacon fetch failed', error);
        }
      }
    }

    handleMouseDown(event) {
      if (!this.canvas) return;
      this.markInteraction();
      const isPrimary = event.button === 0;
      const isSecondary = event.button === 2;
      if (!isPrimary && !isSecondary) {
        return;
      }

      const target = event.target;
      const interactedWithCanvas =
        this.pointerLocked ||
        target === this.canvas ||
        (this.canvas?.contains ? this.canvas.contains(target) : false);

      if (!interactedWithCanvas) {
        return;
      }

      event.preventDefault?.();

      const alreadyLocked = this.pointerLocked || this.getPointerLockElement() === this.canvas;
      if (!alreadyLocked) {
        this.attemptPointerLock();
        if (typeof this.canvas?.focus === 'function') {
          try {
            this.canvas.focus({ preventScroll: true });
          } catch (error) {
            this.canvas.focus();
          }
        }
      }

      if (!alreadyLocked && this.pointerLockFallbackActive) {
        this.beginPointerFallbackDrag(event);
      }

      if (isPrimary) {
        this.mineBlock();
      } else if (isSecondary) {
        this.placeBlock();
      }

      if (!alreadyLocked) {
        this.updatePointerHintForInputMode();
      }
    }

    resetPosition() {
      this.ensurePlayerPhysicsBody();
      this.velocity.set(0, 0, 0);
      this.verticalVelocity = 0;
      this.isGrounded = false;
      this.positionPlayer();
    }

    attachPlayerToSimulation() {
      this.ensurePlayerPhysicsBody();
      this.resetPosition();
      this.isGrounded = true;
      this.prevTime = null;
      this.renderAccumulator = 0;
      if (this.keys && typeof this.keys.clear === 'function') {
        this.keys.clear();
      }
      if (this.joystickVector?.set) {
        this.joystickVector.set(0, 0);
      }
      if (this.touchButtonStates) {
        this.touchButtonStates.up = false;
        this.touchButtonStates.down = false;
        this.touchButtonStates.left = false;
        this.touchButtonStates.right = false;
      }
      this.touchJumpRequested = false;
      this.refreshCameraBaseOffset();
    }

    scheduleNextFrame() {
      if (this.rendererUnavailable || !this.renderer) {
        return;
      }
      if (this.animationFrame !== null) {
        return;
      }
      this.animationFrame = requestAnimationFrame((nextTimestamp) => {
        this.animationFrame = null;
        this.renderFrame(nextTimestamp);
      });
    }

    stepSimulation(delta) {
      if (delta <= 0) {
        return;
      }
      this.elapsed += delta;
      this.updateDayNightCycle();
      this.updateMovement(delta);
      this.updateCameraShake(delta);
      this.updateTerrainCulling(delta);
      this.updateZombies(delta);
      this.updateGolems(delta);
      this.updatePortalAnimation(delta);
      this.updateLootChests(delta);
      this.updateNetheriteChallenge(delta);
      this.updateHands(delta);
      this.updatePlayerAnimation(delta);
      this.updateScoreSync(delta);
      this.updateScoreboardPolling(delta);
      this.updateLostGuidance(delta);
    }

    handleRenderLoopError(stage, error) {
      this.animationFrame = null;
      this.prevTime = null;
      this.resetFrameStats(0);
      if (this.rendererUnavailable) {
        if (typeof console !== 'undefined' && error) {
          const label = stage === 'simulation' ? 'updating the world' : 'rendering the scene';
          console.error(`Render loop error encountered after renderer shutdown while ${label}.`, error);
        }
        return;
      }
      const label = stage === 'simulation' ? 'updating the world' : 'drawing the scene';
      const message = `Rendering paused — a fatal error occurred while ${label}. Reload the page to continue your run.`;
      this.presentRendererFailure(message, { error, stage });
    }

    resetFrameStats(timestamp = 0) {
      if (!this.frameStats) {
        return;
      }
      const stats = this.frameStats;
      stats.framesSinceSample = 0;
      if (Number.isFinite(timestamp) && timestamp > 0) {
        stats.lastSampleTimestamp = timestamp;
      } else {
        stats.lastSampleTimestamp = 0;
        stats.fps = 0;
      }
    }

    recordFrameStats(timestamp) {
      if (!this.frameStats || !Number.isFinite(timestamp)) {
        return;
      }
      const stats = this.frameStats;
      if (!stats.lastSampleTimestamp) {
        stats.lastSampleTimestamp = timestamp;
        stats.framesSinceSample = 1;
        return;
      }
      stats.framesSinceSample += 1;
      const windowMs = Number.isFinite(stats.sampleWindowMs) ? stats.sampleWindowMs : 500;
      const elapsed = timestamp - stats.lastSampleTimestamp;
      if (elapsed >= windowMs) {
        const fps = elapsed > 0 ? (stats.framesSinceSample * 1000) / elapsed : 0;
        stats.fps = fps;
        stats.framesSinceSample = 0;
        stats.lastSampleTimestamp = timestamp;
      }
    }

    renderFrame(timestamp) {
      if (this.rendererUnavailable || !this.renderer) {
        this.animationFrame = null;
        this.resetFrameStats(0);
        return;
      }
      if (!this.isTabVisible) {
        this.prevTime = null;
        this.animationFrame = null;
        this.resetFrameStats(0);
        return;
      }
      if (!this.prevTime) {
        this.prevTime = timestamp;
        this.resetFrameStats(timestamp);
      }
      const rawDelta = (timestamp - this.prevTime) / 1000;
      this.prevTime = timestamp;
      if (!Number.isFinite(rawDelta)) {
        this.scheduleNextFrame();
        return;
      }
      const safeDelta = Math.min(0.05, Math.max(0, rawDelta));
      this.renderAccumulator = Math.min(this.renderAccumulator + safeDelta, 0.5);
      const targetInterval = this.isRenderIdle() ? this.renderIdleInterval : this.renderActiveInterval;
      if (this.renderAccumulator + 1e-6 < targetInterval) {
        this.scheduleNextFrame();
        return;
      }
      const maxSteps = Math.min(3, Math.max(1, Math.floor(this.renderAccumulator / targetInterval)));
      const stepDelta = Math.min(0.05, this.renderAccumulator / maxSteps || 0);
      try {
        for (let i = 0; i < maxSteps; i += 1) {
          this.stepSimulation(stepDelta);
        }
      } catch (error) {
        this.handleRenderLoopError('simulation', error);
        return;
      }
      this.renderAccumulator = Math.max(0, this.renderAccumulator - stepDelta * maxSteps);
      try {
        this.renderer.render(this.scene, this.camera);
      } catch (error) {
        this.handleRenderLoopError('render', error);
        return;
      }
      this.renderedFrameCount += 1;
      this.evaluateRendererVisibility();
      if (!Number.isFinite(this.lastStatePublish) || this.lastStatePublish === null) {
        this.lastStatePublish = 0;
      }
      if (timestamp - this.lastStatePublish >= 250) {
        this.publishStateSnapshot('frame');
        this.lastStatePublish = timestamp;
      }
      this.recordFrameStats(timestamp);
      this.scheduleNextFrame();
    }

    evaluateRendererVisibility() {
      if (!this.renderer || !this.blankFrameDetectionState || this.blankFrameDetectionState.triggered) {
        return;
      }
      const detection = this.blankFrameDetectionState;
      if (!detection.enabled) {
        return;
      }
      if (this.renderedFrameCount < 10) {
        return;
      }
      const canvas = this.renderer.domElement;
      if (!canvas) {
        detection.enabled = false;
        return;
      }
      const width = canvas.width || canvas.clientWidth;
      const height = canvas.height || canvas.clientHeight;
      if (!width || !height) {
        detection.enabled = false;
        return;
      }
      const gl = typeof this.renderer.getContext === 'function' ? this.renderer.getContext() : null;
      if (!gl || typeof gl.readPixels !== 'function') {
        detection.enabled = false;
        return;
      }
      const clearColor = this.renderer.getClearColor(new this.THREE.Color());
      const clearR = Math.round(clearColor.r * 255);
      const clearG = Math.round(clearColor.g * 255);
      const clearB = Math.round(clearColor.b * 255);
      const tolerance = typeof detection.colorTolerance === 'number' ? detection.colorTolerance : 2;
      const ratioSamples = [
        [0.5, 0.5],
        [0.25, 0.25],
        [0.75, 0.25],
        [0.25, 0.75],
        [0.75, 0.75],
      ];
      const samplePoints = [];
      for (const [rx, ry] of ratioSamples) {
        const x = Math.max(0, Math.min(width - 1, Math.round(width * rx)));
        const y = Math.max(0, Math.min(height - 1, Math.round(height * ry)));
        if (!samplePoints.some((point) => point[0] === x && point[1] === y)) {
          samplePoints.push([x, y]);
        }
      }
      if (samplePoints.length === 0) {
        detection.enabled = false;
        return;
      }
      const buffer = new Uint8Array(4);
      let clearMatches = 0;
      let samplesTaken = 0;
      for (const [x, y] of samplePoints) {
        try {
          gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, buffer);
          samplesTaken += 1;
          const matches =
            Math.abs(buffer[0] - clearR) <= tolerance &&
            Math.abs(buffer[1] - clearG) <= tolerance &&
            Math.abs(buffer[2] - clearB) <= tolerance;
          if (matches) {
            clearMatches += 1;
          }
        } catch (error) {
          detection.enabled = false;
          return;
        }
      }
      if (samplesTaken === 0) {
        detection.enabled = false;
        return;
      }
      detection.samples += 1;
      if (clearMatches >= samplePoints.length) {
        detection.clearFrameMatches = (detection.clearFrameMatches || 0) + 1;
      } else {
        detection.clearFrameMatches = 0;
      }
      if (detection.clearFrameMatches >= 3) {
        detection.triggered = true;
        detection.enabled = false;
        this.emitGameEvent('initialisation-error', {
          stage: 'blank-frame',
          message: 'Renderer produced blank frames. WebGL output may be blocked by the browser.',
        });
        this.presentRendererFailure(
          'WebGL output appears blocked. Enable hardware acceleration or disable extensions that prevent WebGL, then reload to explore the realms.',
          { stage: 'blank-frame' },
        );
      } else if (detection.samples >= 12) {
        detection.enabled = false;
      }
    }

    handleVisibilityChange() {
      if (typeof document === 'undefined') {
        return;
      }
      const hidden = document.visibilityState === 'hidden';
      this.isTabVisible = !hidden;
      if (hidden) {
        this.prevTime = null;
        this.resetFrameStats(0);
        if (this.animationFrame !== null) {
          cancelAnimationFrame(this.animationFrame);
          this.animationFrame = null;
        }
        this.cancelQueuedModelPreload();
        return;
      }
      if (!this.started || this.rendererUnavailable || !this.renderer) {
        return;
      }
      this.queueCharacterPreload();
      this.prevTime = null;
      this.resetFrameStats(0);
      if (this.animationFrame === null) {
        const now =
          typeof performance !== 'undefined' && typeof performance.now === 'function'
            ? performance.now()
            : Date.now();
        this.renderFrame(now);
      }
    }

    verifyWebglSupport() {
      if (typeof document === 'undefined') {
        return true;
      }
      try {
        const probe = document.createElement('canvas');
        const attributeCandidates = [
          { failIfMajorPerformanceCaveat: true, powerPreference: 'high-performance' },
          { powerPreference: 'high-performance' },
          {},
        ];
        let context = null;
        let attributesUsed = null;
        for (const attributes of attributeCandidates) {
          context =
            probe.getContext('webgl2', attributes) ||
            probe.getContext('webgl', attributes) ||
            probe.getContext('experimental-webgl', attributes);
          if (context) {
            attributesUsed = attributes;
            break;
          }
        }
        if (!context) {
          this.emitGameEvent('initialisation-error', {
            stage: 'webgl-probe',
            message:
              'WebGL is unavailable. Enable hardware acceleration or switch to a compatible browser to explore the realms.',
          });
          this.presentRendererFailure(
            'WebGL is unavailable. Enable hardware acceleration or switch to a compatible browser to explore the realms.',
          );
          return false;
        }
        const loseContext = typeof context.getExtension === 'function' ? context.getExtension('WEBGL_lose_context') : null;
        loseContext?.loseContext?.();
        if (typeof console !== 'undefined') {
          const attributeSummary = attributesUsed
            ? Object.entries(attributesUsed)
                .map(([key, value]) => `${key}=${value}`)
                .join(', ')
            : 'default attributes';
          console.info(`WebGL probe succeeded (${attributeSummary}).`);
        }
        return true;
      } catch (error) {
        const errorMessage =
          typeof error?.message === 'string' && error.message.trim().length
            ? error.message.trim()
            : 'Unable to initialise WebGL.';
        this.emitGameEvent('initialisation-error', {
          stage: 'webgl-probe',
          message: 'Unable to initialise WebGL.',
          errorMessage,
          errorName: typeof error?.name === 'string' && error.name.trim().length ? error.name.trim() : undefined,
          stack: typeof error?.stack === 'string' && error.stack.trim().length ? error.stack.trim() : undefined,
        });
        this.presentRendererFailure('Unable to initialise WebGL. See console output for troubleshooting steps.', {
          error,
        });
        return false;
      }
    }

    presentRendererFailure(message, details = {}) {
      if (details?.error && typeof console !== 'undefined') {
        console.error(message, details.error);
      } else if (typeof console !== 'undefined') {
        console.error(message);
      }
      this.cancelQueuedModelPreload();
      this.rendererUnavailable = true;
      this.rendererFailureMessage = message;
      this.recordMajorIssue(message, { scope: 'renderer', code: details?.stage || null });
      if (this.playerHintEl) {
        this.playerHintEl.textContent = message;
      }
      if (this.footerStatusEl) {
        this.footerStatusEl.textContent = message;
      }
      if (this.footerEl) {
        this.footerEl.dataset.state = 'alert';
      }
      if (this.scoreboardStatusEl) {
        this.setScoreboardStatus('Renderer offline — unable to sync runs.', { offline: true });
      }
      if (this.startButtonEl) {
        this.startButtonEl.disabled = true;
        this.startButtonEl.textContent = 'Renderer unavailable';
        this.startButtonEl.setAttribute('tabindex', '-1');
      }
      if (this.introModalEl) {
        this.introModalEl.hidden = false;
        this.introModalEl.style.display = 'grid';
        setInertState(this.introModalEl, false);
        activateOverlayIsolation(this.introModalEl);
      }
      if (this.hudRootEl) {
        this.hudRootEl.classList.add('renderer-unavailable');
      }
      if (this.pointerHintEl) {
        this.pointerHintEl.hidden = true;
        this.pointerHintEl.classList.remove('is-visible');
      }
      const failureDetail = { message: typeof message === 'string' ? message : 'Renderer unavailable' };
      if (details && typeof details === 'object') {
        if (details.stage && typeof details.stage === 'string') {
          failureDetail.stage = details.stage;
        }
        if (details.error) {
          const errorMessage =
            typeof details.error?.message === 'string'
              ? details.error.message
              : String(details.error);
          failureDetail.error = errorMessage;
          if (typeof details.error?.name === 'string' && details.error.name.trim().length) {
            failureDetail.errorName = details.error.name.trim();
          }
          if (typeof details.error?.stack === 'string' && details.error.stack.trim().length) {
            failureDetail.stack = details.error.stack.trim();
          }
        }
        if (!failureDetail.stack && typeof details.errorStack === 'string' && details.errorStack.trim().length) {
          failureDetail.stack = details.errorStack.trim();
        }
        if (!failureDetail.errorName && typeof details.errorName === 'string' && details.errorName.trim().length) {
          failureDetail.errorName = details.errorName.trim();
        }
      }
      this.emitGameEvent('renderer-failure', failureDetail);
      this.publishStateSnapshot('renderer-failure');
    }

    bindWebglContextEvents() {
      if (!this.canvas || this.webglEventsBound) {
        return;
      }
      this.canvas.addEventListener('webglcontextlost', this.onWebglContextLost, false);
      this.canvas.addEventListener('webglcontextrestored', this.onWebglContextRestored, false);
      this.webglEventsBound = true;
    }

    handleWebglContextLost(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      if (this.contextLost) {
        return;
      }
      this.contextLost = true;
      this.rendererUnavailable = true;
      this.prevTime = null;
      if (this.animationFrame !== null) {
        cancelAnimationFrame(this.animationFrame);
        this.animationFrame = null;
      }
      this.presentRendererFailure('Rendering paused — WebGL context lost. Reload the page to continue your run.');
    }

    handleWebglContextRestored() {
      if (typeof console !== 'undefined') {
        console.info('WebGL context restored — refreshing to recover renderer resources.');
      }
      if (typeof window !== 'undefined' && typeof window.location?.reload === 'function') {
        window.location.reload();
      }
    }

    updateMovement(delta) {
      this.ensurePlayerPhysicsBody();
      const THREE = this.THREE;
      const forward = this.tmpForward;
      const right = this.tmpRight;
      const yawOnly = new THREE.Euler(0, this.yaw, 0, 'YXZ');
      forward.set(0, 0, -1).applyEuler(yawOnly);
      if (forward.lengthSq() > 0) forward.normalize();
      const up = this.tmpVector2.set(0, 1, 0);
      right.copy(forward).cross(up);
      if (right.lengthSq() > 0) right.normalize();

      const speed = this.currentSpeed;
      if (this.isActionActive('moveForward')) {
        this.velocity.addScaledVector(forward, speed * delta);
      }
      if (this.isActionActive('moveBackward')) {
        this.velocity.addScaledVector(forward, -speed * delta);
      }
      if (this.isActionActive('moveLeft')) {
        this.velocity.addScaledVector(right, -speed * delta);
      }
      if (this.isActionActive('moveRight')) {
        this.velocity.addScaledVector(right, speed * delta);
      }

      const joystickForward = this.THREE.MathUtils.clamp(-this.joystickVector.y, -1, 1);
      const joystickRight = this.THREE.MathUtils.clamp(this.joystickVector.x, -1, 1);
      const digitalForward = (this.touchButtonStates.up ? 1 : 0) - (this.touchButtonStates.down ? 1 : 0);
      const digitalRight = (this.touchButtonStates.right ? 1 : 0) - (this.touchButtonStates.left ? 1 : 0);
      const combinedForward = this.THREE.MathUtils.clamp(joystickForward + digitalForward, -1, 1);
      const combinedRight = this.THREE.MathUtils.clamp(joystickRight + digitalRight, -1, 1);
      if (Math.abs(combinedForward) > 0.001) {
        this.velocity.addScaledVector(forward, speed * delta * combinedForward);
      }
      if (Math.abs(combinedRight) > 0.001) {
        this.velocity.addScaledVector(right, speed * delta * combinedRight);
      }

      this.velocity.multiplyScalar(PLAYER_INERTIA);

      const cameraPitch = this.pitch;
      const cameraQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(cameraPitch, 0, 0, 'YXZ'));
      if (this.playerRig) {
        this.playerRig.rotation.y = this.yaw;
      }
      if (this.camera) {
        this.camera.quaternion.copy(cameraQuaternion);
      }

      const position = this.playerRig ? this.playerRig.position : this.camera.position;
      position.add(this.velocity);

      const groundHeight = this.sampleGroundHeight(position.x, position.z);
      if (!this.isGrounded && this.verticalVelocity < -0.25) {
        this.spawnSafetyBlockAtPlayerFeetIfNeeded(position.x, position.z);
      }
      if ((this.isActionActive('jump') || this.touchJumpRequested) && this.isGrounded) {
        const jumpBoost = 4.6 + (1.5 - Math.min(1.5, this.gravityScale));
        this.verticalVelocity = jumpBoost;
        this.isGrounded = false;
      }
      this.touchJumpRequested = false;
      const gravityForce = 22 * this.gravityScale;
      this.verticalVelocity -= gravityForce * delta;
      position.y += this.verticalVelocity * delta;
      const desiredHeight = groundHeight + PLAYER_EYE_HEIGHT;
      if (position.y <= desiredHeight) {
        position.y = desiredHeight;
        this.verticalVelocity = 0;
        this.isGrounded = true;
      }

      const maxDistance = (WORLD_SIZE / 2 - 2) * BLOCK_SIZE;
      position.x = THREE.MathUtils.clamp(position.x, -maxDistance, maxDistance);
      position.z = THREE.MathUtils.clamp(position.z, -maxDistance, maxDistance);

      this.evaluateMovementBindingDiagnostics();
    }

    updateCameraShake(delta) {
      if (!this.camera || !this.cameraBaseOffset) {
        return;
      }
      if (this.cameraShakeIntensity <= 0 || this.cameraShakeDuration <= 0) {
        this.camera.position.copy(this.cameraBaseOffset);
        this.cameraShakeOffset.set(0, 0, 0);
        this.cameraShakeRotation.set(0, 0, 0);
        this.cameraShakeDuration = 0;
        this.cameraShakeTime = 0;
        return;
      }
      this.cameraShakeTime += delta;
      const progress = this.cameraShakeDuration > 0 ? this.cameraShakeTime / this.cameraShakeDuration : 1;
      if (progress >= 1) {
        this.cameraShakeIntensity = 0;
        this.cameraShakeOffset.set(0, 0, 0);
        this.cameraShakeRotation.set(0, 0, 0);
        this.camera.position.copy(this.cameraBaseOffset);
        this.cameraShakeDuration = 0;
        this.cameraShakeTime = 0;
        return;
      }
      const falloff = (1 - progress) * (1 - progress);
      const strength = this.cameraShakeIntensity * falloff;
      this.cameraShakeNoise.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
      this.cameraShakeOffset.copy(this.cameraShakeNoise).multiplyScalar(0.08 * strength);
      this.camera.position.copy(this.cameraBaseOffset).add(this.cameraShakeOffset);
      this.cameraShakeRotation.set(this.cameraShakeOffset.y * 0.6, -this.cameraShakeOffset.x * 1.1, 0);
      this.tmpQuaternion.setFromEuler(this.cameraShakeRotation);
      this.camera.quaternion.multiply(this.tmpQuaternion);
    }

    triggerCameraImpulse(strength = 0.35, duration = 0.25) {
      if (!this.camera || !this.cameraBaseOffset) {
        return;
      }
      this.cameraShakeIntensity = Math.min(1.6, Math.max(strength, this.cameraShakeIntensity * 0.6 + strength));
      this.cameraShakeDuration = Math.max(duration, 0.12);
      this.cameraShakeTime = 0;
    }

    updateHands(delta) {
      if (!this.handGroup || !this.handGroup.visible) return;
      const THREE = this.THREE;
      const speed = this.velocity.length();
      const target = Math.min(1, speed * 3.2 + (this.isGrounded ? 0 : 0.25));
      this.handSwingStrength = THREE.MathUtils.lerp(this.handSwingStrength, target, delta * 6.5);
      this.handSwingTimer += delta * (4 + speed * 3);
      const bob = Math.sin(this.handSwingTimer) * 0.05 * this.handSwingStrength;
      const sway = Math.cos(this.handSwingTimer * 0.5) * 0.08 * this.handSwingStrength;
      this.handGroup.position.set(0.42 + sway, -0.46 + bob, -0.8);
      this.handGroup.rotation.set(-0.55 + bob * 1.8, sway * 0.6, sway * 0.15);
    }

    updatePlayerAnimation(delta) {
      if (this.playerAnimationRig) {
        this.updateAnimationRig(this.playerAnimationRig, delta);
        return;
      }
      if (this.playerMixer) {
        this.playerMixer.update(delta);
      }
    }

    updateScoreSync(delta) {
      if (!this.apiBaseUrl) return;
      this.scoreSyncHeartbeat += delta;
      const now = performance.now();
      if (this.pendingScoreSyncReason && !this.scoreSyncInFlight) {
        if (now - this.lastScoreSyncAt > this.scoreSyncCooldownSeconds * 1000) {
          this.flushScoreSync();
        }
        return;
      }
      if (
        !this.scoreSyncInFlight &&
        this.scoreSyncHeartbeat >= this.scoreSyncCooldownSeconds * 2 &&
        now - this.lastScoreSyncAt > this.scoreSyncCooldownSeconds * 1000
      ) {
        this.flushScoreSync(true);
        this.scoreSyncHeartbeat = 0;
      }
    }

    updateTerrainCulling(delta) {
      if (!this.camera || !this.terrainChunkGroups.length) {
        return;
      }
      this.terrainCullingAccumulator += delta;
      if (this.terrainCullingAccumulator < this.terrainCullingInterval) {
        return;
      }
      this.camera.updateMatrixWorld();
      const cameraPosition = this.camera.getWorldPosition
        ? this.camera.getWorldPosition(this.tmpVector3)
        : this.getCameraWorldPosition(this.tmpVector3);
      let cameraQuaternion = null;
      if (typeof this.camera.getWorldQuaternion === 'function') {
        cameraQuaternion = this.camera.getWorldQuaternion(this.tmpQuaternion);
      } else if (this.camera.quaternion) {
        cameraQuaternion = this.tmpQuaternion.copy(this.camera.quaternion);
      }
      const hasDirtyChunks = this.dirtyTerrainChunks.size > 0;
      let cameraMoved = !this.lastCullingCameraValid;
      if (!cameraMoved) {
        const positionDelta = cameraPosition.distanceToSquared(this.lastCullingCameraPosition);
        if (positionDelta > TERRAIN_CULLING_POSITION_EPSILON_SQ) {
          cameraMoved = true;
        } else if (cameraQuaternion) {
          const dot = Math.abs(cameraQuaternion.dot(this.lastCullingCameraQuaternion));
          if (1 - dot > TERRAIN_CULLING_ROTATION_EPSILON) {
            cameraMoved = true;
          }
        }
      }
      if (!cameraMoved && !hasDirtyChunks) {
        this.terrainCullingAccumulator = 0;
        return;
      }
      this.terrainCullingAccumulator = 0;
      if (hasDirtyChunks) {
        this.refreshDirtyTerrainChunks();
      }
      this.chunkFrustumMatrix.multiplyMatrices(
        this.camera.projectionMatrix,
        this.camera.matrixWorldInverse,
      );
      this.chunkFrustum.setFromProjectionMatrix(this.chunkFrustumMatrix);
      for (const chunk of this.terrainChunkGroups) {
        const sphere = chunk.userData?.boundingSphere;
        if (!sphere) {
          chunk.visible = true;
          continue;
        }
        chunk.visible = this.chunkFrustum.intersectsSphere(sphere);
      }
      this.lastCullingCameraPosition.copy(cameraPosition);
      if (cameraQuaternion) {
        this.lastCullingCameraQuaternion.copy(cameraQuaternion);
      }
      this.lastCullingCameraValid = true;
      if (this.debugChunkCulling) {
        const visibleCount = this.terrainChunkGroups.reduce(
          (total, chunk) => total + (chunk.visible ? 1 : 0),
          0,
        );
        const now = performance.now();
        if (!this.lastCullingDebugLog || now - this.lastCullingDebugLog > 500) {
          console.debug(`[Chunks] visible ${visibleCount}/${this.terrainChunkGroups.length}`);
          this.lastCullingDebugLog = now;
        }
      }
    }

    sampleGroundHeight(x, z) {
      const gridX = Math.round(x / BLOCK_SIZE + WORLD_SIZE / 2);
      const gridZ = Math.round(z / BLOCK_SIZE + WORLD_SIZE / 2);
      const height = this.heightMap[gridX]?.[gridZ] ?? 0;
      return height * BLOCK_SIZE;
    }

    updateDayNightCycle() {
      const THREE = this.THREE;
      this.ensurePrimaryLights();
      this.applyPendingLightingFallback();
      if (!this.sunLight || !this.hemiLight || !THREE?.MathUtils) return;
      const cycle = (this.elapsed % DAY_LENGTH_SECONDS) / DAY_LENGTH_SECONDS;
      const sunAngle = cycle * Math.PI * 2;
      const sunElevation = Math.sin(sunAngle);
      const dayStrength = THREE.MathUtils.clamp((sunElevation + 1) / 2, 0, 1);
      this.daylightIntensity = dayStrength;

      const sunRadius = 70;
      const sunHeight = 12 + Math.max(0, sunElevation * 48);
      this.sunLight.position.set(
        Math.cos(sunAngle) * sunRadius,
        sunHeight,
        Math.sin(sunAngle) * sunRadius * 0.7,
      );
      this.sunLight.target.position.set(0, 0, 0);
      this.sunLight.target.updateMatrixWorld();
      this.sunLight.intensity = 0.35 + dayStrength * 1.1;
      const warmFactor = THREE.MathUtils.clamp(1 - Math.abs(sunElevation) * 1.1, 0, 1);
      this.tmpColorA.copy(this.daySunColor);
      this.tmpColorB.copy(this.duskSkyColor);
      this.tmpColorA.lerp(this.tmpColorB, warmFactor * 0.5);
      this.tmpColorA.offsetHSL(0, -0.05 * (1 - dayStrength), (dayStrength - 0.5) * 0.2);
      this.sunLight.color.copy(this.tmpColorA);

      const moonAngle = sunAngle + Math.PI;
      const moonElevation = Math.sin(moonAngle);
      const nightStrength = THREE.MathUtils.clamp((moonElevation + 1) / 2, 0, 1);
      if (this.moonLight) {
        const moonRadius = 70;
        const moonHeight = 10 + Math.max(0, moonElevation * 38);
        this.moonLight.position.set(
          Math.cos(moonAngle) * moonRadius,
          moonHeight,
          Math.sin(moonAngle) * moonRadius * 0.7,
        );
        this.moonLight.target.position.set(0, 0, 0);
        this.moonLight.target.updateMatrixWorld();
        this.moonLight.intensity = 0.12 + nightStrength * 0.45;
        this.tmpColorA.copy(this.nightMoonColor);
        this.tmpColorB.copy(this.duskSkyColor);
        this.tmpColorA.lerp(this.tmpColorB, Math.max(0, 0.6 - nightStrength) * 0.35);
        this.moonLight.color.copy(this.tmpColorA);
      }

      if (this.ambientLight) {
        const ambientStrength = 0.18 + dayStrength * 0.36;
        this.ambientLight.intensity = ambientStrength;
        this.tmpColorA
          .copy(this.nightSkyColor)
          .lerp(this.daySkyColor, Math.min(1, dayStrength * 0.85 + 0.15));
        this.ambientLight.color.copy(this.tmpColorA);
      }

      this.hemiLight.intensity = 0.42 + dayStrength * 0.58;
      this.hemiLight.color.lerpColors(this.nightSkyColor, this.daySkyColor, dayStrength);
      if (this.hemiLight.groundColor) {
        this.tmpColorB.copy(this.nightGroundColor).lerp(this.dayGroundColor, dayStrength);
        this.hemiLight.groundColor.copy(this.tmpColorB);
      }

      if (this.lightingFallbackActive) {
        if (this.sunLight) {
          this.sunLight.intensity = Math.max(this.sunLight.intensity, 0.85);
        }
        if (this.ambientLight) {
          this.ambientLight.intensity = Math.max(this.ambientLight.intensity, 0.35);
        }
        if (this.hemiLight) {
          this.hemiLight.intensity = Math.max(this.hemiLight.intensity, 0.65);
        }
      }

      const horizonGlow = THREE.MathUtils.clamp(1 - Math.abs(sunElevation) * 1.6, 0, 1);
      const fogBlend = Math.min(1, dayStrength * 0.85 + 0.15);
      this.tmpColorA.copy(this.nightSkyColor).lerp(this.daySkyColor, dayStrength);
      if (horizonGlow > 0) {
        this.tmpColorB.copy(this.duskSkyColor);
        this.tmpColorA.lerp(this.tmpColorB, horizonGlow * 0.6);
      }
      if (this.scene?.background) {
        this.scene.background.copy(this.tmpColorA);
      }

      if (this.scene?.fog) {
        this.tmpColorB.copy(this.nightFogColor).lerp(this.dayFogColor, fogBlend);
        if (horizonGlow > 0.2) {
          this.tmpColorB.lerp(this.duskSkyColor, horizonGlow * 0.25);
        }
        this.scene.fog.color.copy(this.tmpColorB);
      }

      if (this.ui?.timeEl) {
        const daylight = Math.round(dayStrength * 100);
        let label = 'Daylight';
        if (dayStrength < 0.32) {
          label = dayStrength < 0.16 ? 'Nightfall (Midnight)' : 'Nightfall';
        } else if (dayStrength < 0.52) {
          label = 'Dawn';
        } else if (dayStrength > 0.82) {
          label = 'High Sun';
        }
        this.ui.timeEl.textContent = `${label} ${daylight}%`;
      }
    }

    updatePortalAnimation(delta) {
      if (!this.portalMesh) return;
      const material = this.portalMesh.material;
      if (material?.uniforms?.uTime) {
        material.uniforms.uTime.value += delta * 1.2;
        this.portalFallbackPulse = 0;
        return;
      }
      const placeholderAnimation = this.portalMesh.userData?.portalPlaceholderAnimation;
      if (!placeholderAnimation) {
        this.portalFallbackPulse = 0;
        return;
      }
      this.portalFallbackPulse = (this.portalFallbackPulse || 0) + delta;
      const time = this.portalFallbackPulse;
      const swirlWave = 0.6 + Math.sin(time * 2.4) * 0.4;
      const accentWave = 0.5 + Math.sin(time * 3.1 + 0.8) * 0.45;
      if (placeholderAnimation.swirlMaterial) {
        const base = placeholderAnimation.baseSwirlEmissive ?? 0.45;
        const opacityBase = placeholderAnimation.baseSwirlOpacity ?? 0.85;
        placeholderAnimation.swirlMaterial.emissiveIntensity = Math.max(0, base + swirlWave * 0.25);
        placeholderAnimation.swirlMaterial.opacity = Math.max(0.35, Math.min(0.95, opacityBase * (0.75 + swirlWave * 0.2)));
      }
      if (placeholderAnimation.accentMaterial) {
        const base = placeholderAnimation.baseAccentEmissive ?? 0.32;
        const opacityBase = placeholderAnimation.baseAccentOpacity ?? 0.9;
        placeholderAnimation.accentMaterial.emissiveIntensity = Math.max(0, base + accentWave * 0.22);
        placeholderAnimation.accentMaterial.opacity = Math.max(0.45, Math.min(1, opacityBase * (0.7 + accentWave * 0.3)));
      }
      if (Array.isArray(placeholderAnimation.swirlMeshes)) {
        const rotationSpeed = 0.7 + Math.sin(time * 1.6) * 0.2;
        placeholderAnimation.swirlMeshes.forEach((mesh, index) => {
          if (!mesh) return;
          const direction = index % 2 === 0 ? 1 : -0.85;
          mesh.rotation.z += delta * rotationSpeed * direction;
        });
      }
      if (Array.isArray(placeholderAnimation.accentMeshes)) {
        const positions = Array.isArray(placeholderAnimation.accentBasePositions)
          ? placeholderAnimation.accentBasePositions
          : [];
        placeholderAnimation.accentMeshes.forEach((mesh, index) => {
          if (!mesh) return;
          const baseY = Number.isFinite(positions[index]) ? positions[index] : mesh.position.y;
          mesh.position.y = baseY + Math.sin(time * 2.8 + index) * 0.06;
        });
      }
    }

    populateInitialMobs(options = {}) {
      const mobOptions = typeof options === 'object' && options !== null ? options : {};
      const spawnInitialGolems = mobOptions.spawnInitialGolems !== false;
      const spawnInitialZombies =
        mobOptions.spawnInitialZombies !== undefined
          ? Boolean(mobOptions.spawnInitialZombies)
          : typeof this.isNight === 'function'
            ? this.isNight()
            : false;
      const golemTargetRaw = Number.isFinite(mobOptions.initialGolemCount)
        ? Math.floor(mobOptions.initialGolemCount)
        : 1;
      const zombieTargetRaw = Number.isFinite(mobOptions.initialZombieCount)
        ? Math.floor(mobOptions.initialZombieCount)
        : 1;
      const golemTarget = Math.max(0, Math.min(GOLEM_MAX_PER_DIMENSION, golemTargetRaw));
      const zombieTarget = Math.max(0, Math.min(ZOMBIE_MAX_PER_DIMENSION, zombieTargetRaw));

      const golemGroup = this.ensureEntityGroup('golem');
      if (!Array.isArray(this.golems)) {
        this.golems = [];
      }
      if (spawnInitialGolems && golemGroup) {
        const currentGolems = this.golems.length;
        const desiredGolems = Math.max(currentGolems, golemTarget);
        const limit = Math.min(desiredGolems, GOLEM_MAX_PER_DIMENSION);
        for (let index = currentGolems; index < limit; index += 1) {
          this.spawnGolem();
        }
      }

      const zombieGroup = this.ensureEntityGroup('zombie');
      if (!Array.isArray(this.zombies)) {
        this.zombies = [];
      }
      if (spawnInitialZombies && zombieGroup) {
        const currentZombies = this.zombies.length;
        const desiredZombies = Math.max(currentZombies, zombieTarget);
        const limit = Math.min(desiredZombies, ZOMBIE_MAX_PER_DIMENSION);
        for (let index = currentZombies; index < limit; index += 1) {
          this.spawnZombie();
        }
      }
    }

    updateZombies(delta) {
      const zombieGroup = this.ensureEntityGroup('zombie');
      if (!zombieGroup) return;
      const THREE = this.THREE;
      if (!this.isNight()) {
        if (this.zombies.length) {
          this.clearZombies();
        }
        return;
      }
      if (this.elapsed - this.lastZombieSpawn > ZOMBIE_SPAWN_INTERVAL && this.zombies.length < ZOMBIE_MAX_PER_DIMENSION) {
        this.spawnZombie();
        this.lastZombieSpawn = this.elapsed;
      }
      const playerPosition = this.getPlayerWorldPosition(this.tmpVector3);
      this.ensureNavigationMeshForActorPosition('zombie', playerPosition.x, playerPosition.z, {
        reason: 'zombie-target',
        stage: 'player-tracking',
      });
      const tmpDir = this.tmpVector;
      const tmpStep = this.tmpVector2;
      for (const zombie of this.zombies) {
        const { mesh } = zombie;
        if (!Number.isFinite(zombie.collisionRadius)) {
          zombie.collisionRadius = ZOMBIE_COLLISION_RADIUS;
        }
        const currentChunkKey = this.getChunkKeyForWorldPosition(mesh.position.x, mesh.position.z);
        if (currentChunkKey) {
          const navmesh = this.ensureNavigationMeshForActorChunk('zombie', currentChunkKey, {
            reason: 'zombie-chase',
            stage: 'chase',
            zombieId: zombie.id,
          });
          zombie.navChunkKey = navmesh ? currentChunkKey : null;
        } else {
          zombie.navChunkKey = null;
          this.warnAiMovementFailure('zombie', {
            stage: 'chase',
            reason: 'chunk-missing',
            zombieId: zombie.id,
            x: mesh.position.x,
            z: mesh.position.z,
          });
        }
        tmpDir.subVectors(playerPosition, mesh.position);
        const distance = tmpDir.length();
        if (!Number.isFinite(distance)) {
          this.warnAiMovementFailure('zombie', {
            stage: 'chase',
            reason: 'distance-invalid',
            zombieId: zombie.id,
            chunkKey: zombie.navChunkKey ?? currentChunkKey ?? null,
          });
          continue;
        }
        let baseState = 'idle';
        if (distance > 0.001) {
          tmpDir.normalize();
          tmpStep.copy(tmpDir).multiplyScalar(zombie.speed * delta);
          mesh.position.add(tmpStep);
          mesh.rotation.y = Math.atan2(tmpDir.x, tmpDir.z);
          if (tmpStep.lengthSq() > 1e-6) {
            baseState = 'walk';
          }
        }
        const groundHeight = this.sampleGroundHeight(mesh.position.x, mesh.position.z);
        mesh.position.y = THREE.MathUtils.lerp(mesh.position.y, groundHeight + 0.9, delta * 10);
        if (
          !Number.isFinite(mesh.position.x) ||
          !Number.isFinite(mesh.position.y) ||
          !Number.isFinite(mesh.position.z)
        ) {
          this.warnAiMovementFailure('zombie', {
            stage: 'integration',
            reason: 'position-invalid',
            zombieId: zombie.id,
            chunkKey: zombie.navChunkKey ?? currentChunkKey ?? null,
            x: mesh.position.x,
            y: mesh.position.y,
            z: mesh.position.z,
          });
        }
        if (distance < ZOMBIE_CONTACT_RANGE && this.elapsed - zombie.lastAttack > 1.2) {
          this.damagePlayer(1);
          zombie.lastAttack = this.elapsed;
          if (zombie.animation) {
            this.triggerAnimationRigPulse(zombie.animation, 'attack', {
              duration: 0.7,
              fadeIn: 0.08,
              fadeOut: 0.22,
              fallbackState: baseState,
            });
          }
        }
        if (zombie.animation) {
          this.setAnimationRigState(zombie.animation, baseState);
          this.updateAnimationRig(zombie.animation, delta);
        }
      }
      const playerBounds = this.getPlayerPhysicsBounds();
      this.resolveMobCollectionCollisions(this.zombies, {
        type: 'zombie',
        fallbackRadius: ZOMBIE_COLLISION_RADIUS,
        playerBounds,
        extraTargets: Array.isArray(this.golems) ? this.golems : [],
        extraCollection: this.golems,
        extraTargetRadius: GOLEM_COLLISION_RADIUS,
        extraTargetType: 'golem',
      });
    }

    isNight() {
      return this.daylightIntensity < 0.32;
    }

    spawnZombie() {
      const THREE = this.THREE;
      const zombieGroup = this.ensureEntityGroup('zombie');
      if (!THREE || !zombieGroup) return;
      if (!Array.isArray(this.zombies)) {
        this.zombies = [];
      }
      const id = (this.zombieIdCounter += 1);
      const angle = Math.random() * Math.PI * 2;
      const radius = WORLD_SIZE * 0.45;
      const spawnInfo = {
        x: Math.cos(angle) * radius,
        z: Math.sin(angle) * radius,
        surfaceY: null,
        chunkKey: null,
      };
      spawnInfo.surfaceY = this.sampleGroundHeight(spawnInfo.x, spawnInfo.z);
      spawnInfo.chunkKey = this.getChunkKeyForWorldPosition(spawnInfo.x, spawnInfo.z);
      if (!this.zombieGeometry) {
        this.zombieGeometry = new THREE.BoxGeometry(0.9, 1.8, 0.9);
      }
      const baseMaterial = this.materials?.zombie;
      const supportsStandardMaterial =
        THREE && typeof THREE.MeshStandardMaterial === 'function' && !baseMaterial;
      const MaterialClass = supportsStandardMaterial
        ? THREE.MeshStandardMaterial
        : THREE?.MeshBasicMaterial;
      const material = baseMaterial?.clone
        ? baseMaterial.clone()
        : MaterialClass
        ? new MaterialClass(
            supportsStandardMaterial
              ? { color: new THREE.Color('#2e7d32'), roughness: 0.8, metalness: 0.1 }
              : { color: new THREE.Color('#2e7d32') },
          )
        : new THREE.MeshBasicMaterial({ color: new THREE.Color('#2e7d32') });
      if (material?.color?.offsetHSL) {
        material.color.offsetHSL(0, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1);
      }
      const mesh = new THREE.Mesh(this.zombieGeometry, material);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      let spawnChunkKey = spawnInfo.chunkKey;
      let spawnNavmesh = null;
      if (spawnChunkKey) {
        spawnNavmesh = this.ensureNavigationMeshForChunk(spawnChunkKey, { reason: 'zombie-spawn' });
      } else {
        spawnNavmesh = this.ensureNavigationMeshForWorldPosition(spawnInfo.x, spawnInfo.z, {
          reason: 'zombie-spawn-fallback',
        });
      }
      if (!spawnNavmesh || !spawnNavmesh.walkableCellCount) {
        const playerPosition = this.getPlayerWorldPosition(this.tmpVector3);
        const fallbackChunkKey = this.getChunkKeyForWorldPosition(playerPosition.x, playerPosition.z);
        if (fallbackChunkKey) {
          const fallbackNavmesh = this.ensureNavigationMeshForChunk(fallbackChunkKey, {
            reason: 'zombie-spawn-fallback',
          });
          if (fallbackNavmesh?.walkableCellCount && Array.isArray(fallbackNavmesh.cells)) {
            const index = Math.min(
              fallbackNavmesh.walkableCellCount - 1,
              Math.floor(Math.random() * fallbackNavmesh.walkableCellCount),
            );
            const fallbackCell = fallbackNavmesh.cells[index] || null;
            if (fallbackCell) {
              spawnChunkKey = fallbackChunkKey;
              spawnNavmesh = fallbackNavmesh;
              spawnInfo.x = fallbackCell.worldX;
              spawnInfo.z = fallbackCell.worldZ;
              spawnInfo.chunkKey = fallbackChunkKey;
              spawnInfo.surfaceY = Number.isFinite(fallbackCell.surfaceY)
                ? fallbackCell.surfaceY
                : this.sampleGroundHeight(fallbackCell.worldX, fallbackCell.worldZ);
            }
          }
        } else {
          spawnNavmesh = this.ensureNavigationMeshForWorldPosition(playerPosition.x, playerPosition.z, {
            reason: 'zombie-spawn-fallback',
          });
        }
        if ((!spawnNavmesh || !spawnNavmesh.walkableCellCount) && typeof console !== 'undefined') {
          console.warn('Zombie spawn fallback engaged — navmesh coverage unavailable at candidate location.', {
            attemptedChunk: spawnInfo.chunkKey ?? null,
            fallbackChunk: spawnChunkKey ?? null,
            x: spawnInfo.x,
            z: spawnInfo.z,
          });
        }
      }
      const surfaceY = Number.isFinite(spawnInfo.surfaceY)
        ? spawnInfo.surfaceY
        : this.sampleGroundHeight(spawnInfo.x, spawnInfo.z);
      mesh.position.set(spawnInfo.x, surfaceY + 0.9, spawnInfo.z);
      zombieGroup.add(mesh);
      const zombie = {
        id,
        mesh,
        collisionRadius: ZOMBIE_COLLISION_RADIUS,
        speed: 2.4,
        lastAttack: this.elapsed,
        placeholder: true,
        animation: null,
        navChunkKey: spawnChunkKey ?? null,
        spawnedAt: this.elapsed,
      };
      this.zombies.push(zombie);
      this.upgradeZombie(zombie);
      this.runImmediateGolemDefense();
      console.info(
        'Zombie spawn and chase triggered. If AI stalls or pathfinding breaks, validate the navmesh and spawn configuration.',
      );
    }

    clearZombies() {
      if (!Array.isArray(this.zombies)) {
        this.zombies = [];
      }
      const group = this.zombieGroup;
      for (const zombie of this.zombies) {
        if (zombie.animation) {
          this.disposeAnimationRig(zombie.animation);
          zombie.animation = null;
        }
        if (group?.remove && zombie.mesh) {
          try {
            group.remove(zombie.mesh);
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Failed to detach zombie mesh during cleanup.', error);
            }
          }
        }
        if (zombie.mesh) {
          disposeObject3D(zombie.mesh);
        }
      }
      if (group?.clear) {
        try {
          group.clear();
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Failed to clear zombie group during cleanup.', error);
          }
        }
      }
      this.zombies = [];
    }

    removeZombie(target) {
      if (!target) return;
      const index = this.zombies.indexOf(target);
      if (index >= 0) {
        this.zombies.splice(index, 1);
      }
      if (target.animation) {
        this.disposeAnimationRig(target.animation);
        target.animation = null;
      }
      this.zombieGroup.remove(target.mesh);
      disposeObject3D(target.mesh);
    }

    findNearestZombie(position) {
      if (!position) return null;
      let best = null;
      let bestDistance = Infinity;
      for (const zombie of this.zombies) {
        const distance = position.distanceTo(zombie.mesh.position);
        if (distance < bestDistance) {
          best = zombie;
          bestDistance = distance;
        }
      }
      return best;
    }

    getMobCollisionRadius(mob, fallbackRadius = 0.5) {
      const safeFallback = Math.max(0.1, Number.isFinite(fallbackRadius) ? fallbackRadius : 0.5);
      if (!mob) {
        return safeFallback;
      }
      const directRadius = Number.isFinite(mob.collisionRadius) ? mob.collisionRadius : null;
      const meshRadius = Number.isFinite(mob?.mesh?.userData?.collisionRadius)
        ? mob.mesh.userData.collisionRadius
        : null;
      const radius = directRadius ?? meshRadius ?? safeFallback;
      if (!Number.isFinite(radius) || radius <= 0) {
        mob.collisionRadius = safeFallback;
        return safeFallback;
      }
      return radius;
    }

    resolveMobPlayerCollision(mob, playerBounds, options = {}) {
      if (!mob || !playerBounds || !playerBounds.position) {
        return false;
      }
      const type = options.type || 'mob';
      const failureHandler =
        typeof options.onFailure === 'function' ? options.onFailure : null;
      const fail = (reason, details = {}) => {
        const error = this.createMobCollisionError(reason, {
          ...details,
          type,
          mobId: mob?.id ?? null,
        });
        this.dispatchMobCollisionFailure(type, mob, error, failureHandler);
        return false;
      };
      const position = mob.mesh?.position || null;
      if (!position || typeof position.x !== 'number' || typeof position.z !== 'number') {
        return fail('mob-position-unavailable', {
          hasMesh: Boolean(mob?.mesh),
        });
      }
      if (typeof position.addScaledVector !== 'function') {
        return fail('mob-position-vector-missing', {
          hasAddScaledVector: typeof position.addScaledVector === 'function',
        });
      }
      const radius = this.getMobCollisionRadius(mob, options.fallbackRadius);
      const playerRadius = Number.isFinite(playerBounds.radius)
        ? playerBounds.radius
        : this.playerPhysicsRadius;
      if (!Number.isFinite(playerRadius) || playerRadius <= 0) {
        return fail('player-radius-invalid', { playerRadius });
      }
      const target = this.mobCollisionVector;
      const playerPosition = playerBounds.position;
      target.set(
        position.x - (playerPosition.x ?? 0),
        0,
        position.z - (playerPosition.z ?? 0),
      );
      let distance = target.length();
      if (!Number.isFinite(distance)) {
        return fail('mob-player-distance-invalid', { distance });
      }
      if (distance === 0) {
        target.set(Math.random() - 0.5 || 0.5, 0, Math.random() - 0.5 || -0.5);
        distance = target.length();
      }
      const minDistance = radius + playerRadius;
      if (minDistance <= 0) {
        return fail('minimum-collision-distance-invalid', {
          radius,
          playerRadius,
        });
      }
      if (distance >= minDistance || distance <= 0) {
        return false;
      }
      target.multiplyScalar(1 / distance);
      const push = Math.min(minDistance - distance + 1e-4, minDistance);
      position.addScaledVector(target, push);
      return true;
    }

    resolveMobPairCollision(primary, secondary, options = {}) {
      if (!primary || !secondary || primary === secondary) {
        return false;
      }
      const typeA = options.typeA || options.type || 'mob';
      const typeB = options.typeB || options.type || typeA;
      const failureA = typeof options.onFailureA === 'function' ? options.onFailureA : null;
      const failureB = typeof options.onFailureB === 'function' ? options.onFailureB : null;
      const failPrimary = (reason, details = {}) => {
        const error = this.createMobCollisionError(reason, {
          ...details,
          role: 'primary',
          type: typeA,
          mobId: primary?.id ?? null,
        });
        this.dispatchMobCollisionFailure(typeA, primary, error, failureA);
      };
      const failSecondary = (reason, details = {}) => {
        const error = this.createMobCollisionError(reason, {
          ...details,
          role: 'secondary',
          type: typeB,
          mobId: secondary?.id ?? null,
        });
        this.dispatchMobCollisionFailure(typeB, secondary, error, failureB);
      };
      const positionA = primary.mesh?.position || null;
      if (!positionA || typeof positionA.x !== 'number' || typeof positionA.z !== 'number') {
        failPrimary('mob-position-unavailable', { hasMesh: Boolean(primary?.mesh) });
        return false;
      }
      const positionB = secondary.mesh?.position || null;
      if (!positionB || typeof positionB.x !== 'number' || typeof positionB.z !== 'number') {
        failSecondary('mob-position-unavailable', { hasMesh: Boolean(secondary?.mesh) });
        return false;
      }
      if (typeof positionA.addScaledVector !== 'function') {
        failPrimary('mob-position-vector-missing', {
          hasAddScaledVector: typeof positionA.addScaledVector === 'function',
        });
        return false;
      }
      if (typeof positionB.addScaledVector !== 'function') {
        failSecondary('mob-position-vector-missing', {
          hasAddScaledVector: typeof positionB.addScaledVector === 'function',
        });
        return false;
      }
      const radiusA = this.getMobCollisionRadius(primary, options.fallbackRadiusA);
      const radiusB = this.getMobCollisionRadius(secondary, options.fallbackRadiusB);
      const direction = this.mobCollisionVector;
      direction.set(positionA.x - positionB.x, 0, positionA.z - positionB.z);
      let distance = direction.length();
      if (!Number.isFinite(distance)) {
        const details = { distance };
        failPrimary('mob-separation-distance-invalid', details);
        failSecondary('mob-separation-distance-invalid', details);
        return false;
      }
      if (distance === 0) {
        direction.set(Math.random() - 0.5 || 0.5, 0, Math.random() - 0.5 || -0.5);
        distance = direction.length();
      }
      const minDistance = radiusA + radiusB;
      if (minDistance <= 0) {
        const details = { radiusA, radiusB };
        failPrimary('mob-collision-radius-invalid', details);
        failSecondary('mob-collision-radius-invalid', details);
        return false;
      }
      if (distance >= minDistance || distance <= 0) {
        return false;
      }
      direction.multiplyScalar(1 / distance);
      const correction = minDistance - distance;
      const maxCorrection = minDistance;
      const applied = Math.min(correction + 1e-4, maxCorrection);
      const half = applied * 0.5;
      positionA.addScaledVector(direction, half);
      if (options.allowSecondaryAdjustment !== false) {
        positionB.addScaledVector(direction, -half);
      }
      return true;
    }

    resolveMobCollectionCollisions(mobs, options = {}) {
      if (!Array.isArray(mobs) || mobs.length === 0) {
        return;
      }
      const type = options.type || 'mob';
      const fallbackRadius = Number.isFinite(options.fallbackRadius) ? options.fallbackRadius : 0.5;
      const playerBounds = options.playerBounds || null;
      const extras = Array.isArray(options.extraTargets) ? options.extraTargets.slice() : [];
      const extraCollection = options.extraCollection || extras;
      const extraRadius = Number.isFinite(options.extraTargetRadius)
        ? options.extraTargetRadius
        : fallbackRadius;
      const extraType = options.extraTargetType || 'mob';
      const allowExtraAdjustment = options.allowSecondaryAdjustmentForExtra !== false;
      const active = mobs.slice();
      for (let i = 0; i < active.length; i += 1) {
        const mob = active[i];
        if (!mob || !mobs.includes(mob)) {
          continue;
        }
        if (playerBounds) {
          this.resolveMobPlayerCollision(mob, playerBounds, {
            fallbackRadius,
            type,
            onFailure: (error) => this.handleMobCollisionFailure(type, mob, error),
          });
          if (!mobs.includes(mob)) {
            continue;
          }
        }
        for (let j = i + 1; j < active.length; j += 1) {
          const other = active[j];
          if (!other || !mobs.includes(other)) {
            continue;
          }
          this.resolveMobPairCollision(mob, other, {
            fallbackRadiusA: fallbackRadius,
            fallbackRadiusB: fallbackRadius,
            typeA: type,
            typeB: type,
            onFailureA: (error) => this.handleMobCollisionFailure(type, mob, error),
            onFailureB: (error) => this.handleMobCollisionFailure(type, other, error),
          });
          if (!mobs.includes(mob)) {
            break;
          }
        }
        if (!mobs.includes(mob)) {
          continue;
        }
        for (const extra of extras) {
          if (!extra) {
            continue;
          }
          if (Array.isArray(extraCollection) && !extraCollection.includes(extra)) {
            continue;
          }
          if (extra === mob) {
            continue;
          }
          this.resolveMobPairCollision(mob, extra, {
            fallbackRadiusA: fallbackRadius,
            fallbackRadiusB: extraRadius,
            allowSecondaryAdjustment: allowExtraAdjustment,
            typeA: type,
            typeB: extraType,
            onFailureA: (error) => this.handleMobCollisionFailure(type, mob, error),
            onFailureB: (error) => this.handleMobCollisionFailure(extraType, extra, error),
          });
          if (!mobs.includes(mob)) {
            break;
          }
        }
      }
    }

    createMobCollisionError(message, details = {}) {
      const error = new Error(message || 'mob-collision-failure');
      if (details && typeof details === 'object') {
        error.details = { ...details };
      }
      return error;
    }

    dispatchMobCollisionFailure(type, mob, error, handler) {
      let handled = false;
      if (typeof handler === 'function') {
        try {
          handler(error);
          handled = true;
        } catch (handlerError) {
          if (typeof console !== 'undefined' && typeof console.error === 'function') {
            console.error('Mob collision failure handler threw.', handlerError);
          }
        }
      }
      if (!handled) {
        this.handleMobCollisionFailure(type, mob, error);
      }
    }

    handleMobCollisionFailure(type, mob, error) {
      if (!mob) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.warn === 'function') {
        console.warn('Mob collision handling failed — rebuilding entity.', {
          type,
          id: mob?.id ?? null,
          error,
        });
      }
      if (type === 'zombie' && !Array.isArray(this.zombies)) {
        this.zombies = [];
      }
      if (type === 'golem' && !Array.isArray(this.golems)) {
        this.golems = [];
      }
      if (type === 'zombie') {
        this.removeZombie(mob);
        if (this.isNight() && this.zombies.length < ZOMBIE_MAX_PER_DIMENSION) {
          try {
            this.spawnZombie();
          } catch (spawnError) {
            if (typeof console !== 'undefined' && typeof console.error === 'function') {
              console.error('Failed to respawn zombie after collision failure.', spawnError);
            }
            notifyLiveDiagnostics(
              'ai',
              'Failed to respawn zombie after collision failure.',
              { error: normaliseLiveDiagnosticError(spawnError) },
            );
          }
        }
        return;
      }
      if (type === 'golem') {
        this.removeGolem(mob);
        const shouldSpawnGuard = this.isNight() || this.zombies.length > 0;
        if (shouldSpawnGuard && this.golems.length < GOLEM_MAX_PER_DIMENSION) {
          try {
            this.spawnGolem();
          } catch (spawnError) {
            if (typeof console !== 'undefined' && typeof console.error === 'function') {
              console.error('Failed to respawn golem after collision failure.', spawnError);
            }
            notifyLiveDiagnostics(
              'ai',
              'Failed to respawn golem after collision failure.',
              { error: normaliseLiveDiagnosticError(spawnError) },
            );
          }
        }
      }
    }

    ensureEntityGroup(kind) {
      if (!kind) {
        return null;
      }
      const THREE =
        this.THREE ||
        (typeof globalThis !== 'undefined' && globalThis.THREE ? globalThis.THREE : null) ||
        (typeof window !== 'undefined' && window.THREE ? window.THREE : null);
      if (!THREE || typeof THREE.Group !== 'function') {
        return null;
      }
      const property = `${kind}Group`;
      let group = this[property];
      if (!(group instanceof THREE.Group)) {
        group = new THREE.Group();
        group.name = `${kind.charAt(0).toUpperCase() + kind.slice(1)}Group`;
        this[property] = group;
      }
      const worldRoot = this.worldRoot || this.scene;
      if (!worldRoot || typeof worldRoot.add !== 'function') {
        this.handleEntityAttachmentFailure(kind, {
          reason: worldRoot ? 'world-root-invalid' : 'world-root-unavailable',
        });
        return null;
      }
      if (group.parent && group.parent !== worldRoot && typeof group.parent.remove === 'function') {
        try {
          group.parent.remove(group);
        } catch (error) {
          this.handleEntityAttachmentFailure(kind, { reason: 'group-detach-failed', error });
          return null;
        }
      }
      if (group.parent !== worldRoot) {
        try {
          worldRoot.add(group);
        } catch (error) {
          this.handleEntityAttachmentFailure(kind, { reason: 'group-attach-failed', error });
          return null;
        }
      }
      if (group.parent !== worldRoot) {
        this.handleEntityAttachmentFailure(kind, { reason: 'group-parent-mismatch' });
        return null;
      }
      return group;
    }

    handleEntityAttachmentFailure(kind, context = {}) {
      if (this.aiAttachmentFailureAnnounced) {
        return;
      }
      this.aiAttachmentFailureAnnounced = true;
      const label = typeof kind === 'string' && kind.trim().length ? kind.trim() : 'entity';
      const friendly = label.replace(/[-_]+/g, ' ').trim() || 'entity';
      const capitalised = `${friendly.charAt(0).toUpperCase()}${friendly.slice(1)}`;
      const message =
        `${capitalised} AI offline — AI scripts could not attach ${friendly} actors to the world. Reload the page to continue your run.`;
      if (typeof console !== 'undefined' && typeof console.error === 'function') {
        const logContext = { kind: label, reason: context.reason ?? 'unknown' };
        if (context.error) {
          logContext.error = context.error;
        }
        console.error('AI scripts failed to attach to entity group.', logContext);
      }
      notifyLiveDiagnostics(
        'ai',
        message,
        {
          kind: label,
          reason: context.reason ?? 'unknown',
          error: normaliseLiveDiagnosticError(context.error),
        },
      );
      if (typeof this.emitGameEvent === 'function') {
        const detail = { kind: label, reason: context.reason ?? 'unknown' };
        if (context.error instanceof Error) {
          detail.errorMessage = context.error.message;
          detail.errorName = context.error.name;
        }
        this.emitGameEvent('ai-attachment-failed', detail);
      }
      const failureDetails = {
        stage: `ai:${label}`,
        errorName: 'AI_ENTITY_ATTACHMENT_FAILED',
      };
      if (context.error instanceof Error) {
        failureDetails.error = context.error;
      }
      this.presentRendererFailure(message, failureDetails);
      const overlayDetail = {
        kind: label,
        reason: context.reason ?? 'unknown',
      };
      if (context.error instanceof Error) {
        overlayDetail.errorName = context.error.name ?? undefined;
        overlayDetail.errorMessage = context.error.message ?? undefined;
      }
      this.showAiDebugOverlay(message, overlayDetail);
    }

    showAiDebugOverlay(message, details = {}) {
      const scope =
        (typeof window !== 'undefined' && window) ||
        (typeof globalThis !== 'undefined' && globalThis) ||
        null;
      if (!scope) {
        return false;
      }
      const summaryMessage =
        typeof message === 'string' && message.trim().length
          ? message.trim()
          : 'AI scripts offline — reload the page to recover.';
      const overlayApi =
        scope.bootstrapOverlay ||
        scope.InfiniteRails?.bootstrapOverlay ||
        scope.__INFINITE_RAILS_BOOTSTRAP_OVERLAY__ ||
        null;
      const detailPayload = details && typeof details === 'object' ? { ...details } : {};
      if (overlayApi && typeof overlayApi.showError === 'function') {
        try {
          overlayApi.showError({
            title: 'AI systems offline',
            message: summaryMessage,
          });
          if (typeof overlayApi.setDiagnostic === 'function') {
            overlayApi.setDiagnostic('renderer', {
              status: 'error',
              message: summaryMessage,
            });
          }
          if (typeof overlayApi.logEvent === 'function') {
            overlayApi.logEvent('ai', summaryMessage, {
              level: 'error',
              detail: detailPayload,
            });
          }
          return true;
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('AI debug overlay API unavailable; using DOM fallback.', error);
          }
        }
      }
      const doc =
        this.canvas?.ownerDocument ||
        scope.document ||
        (typeof document !== 'undefined' ? document : null);
      if (!doc || typeof doc.getElementById !== 'function') {
        return false;
      }
      const overlay = doc.getElementById('globalOverlay');
      if (!overlay) {
        return false;
      }
      if (typeof overlay.removeAttribute === 'function') {
        overlay.removeAttribute('hidden');
      }
      if (typeof overlay.setAttribute === 'function') {
        overlay.setAttribute('data-mode', 'error');
        overlay.setAttribute('data-fallback-active', 'true');
      }
      overlay.hidden = false;
      try {
        setInertState(overlay, false);
        activateOverlayIsolation(overlay);
      } catch (error) {
        if (typeof console !== 'undefined' && typeof console.debug === 'function') {
          console.debug('Failed to update inert state for AI overlay fallback.', error);
        }
      }
      const titleEl = doc.getElementById('globalOverlayTitle');
      if (titleEl) {
        titleEl.textContent = 'AI systems offline';
      }
      const messageEl = doc.getElementById('globalOverlayMessage');
      if (messageEl) {
        messageEl.textContent = summaryMessage;
      }
      const rendererDiagnostic =
        typeof doc.querySelector === 'function' ? doc.querySelector('[data-diagnostic="renderer"]') : null;
      if (rendererDiagnostic && typeof rendererDiagnostic.setAttribute === 'function') {
        rendererDiagnostic.setAttribute('data-status', 'error');
      }
      const rendererStatusEl = doc.getElementById('globalOverlayRendererStatus');
      if (rendererStatusEl) {
        rendererStatusEl.textContent = 'AI scripts offline — reload to recover.';
      }
      return true;
    }

    createGolemActor() {
      const THREE = this.THREE;
      if (!THREE) return null;
      const group = new THREE.Group();
      const supportsStandardMaterial = typeof THREE.MeshStandardMaterial === 'function';
      const BodyMaterialClass = supportsStandardMaterial ? THREE.MeshStandardMaterial : THREE.MeshBasicMaterial;
      const AccentMaterialClass = supportsStandardMaterial ? THREE.MeshStandardMaterial : THREE.MeshBasicMaterial;
      const bodyMaterial = new BodyMaterialClass(
        supportsStandardMaterial
          ? { color: '#d9c9a7', roughness: 0.7, metalness: 0.1 }
          : { color: '#d9c9a7' },
      );
      const accentMaterial = new AccentMaterialClass(
        supportsStandardMaterial
          ? { color: '#ffb347', emissive: '#ff7043', emissiveIntensity: 0.3 }
          : { color: '#ffb347' },
      );
      const body = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.6, 0.6), bodyMaterial);
      body.position.y = 0.8;
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), bodyMaterial.clone());
      head.position.y = 1.6;
      const eye = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.12, 0.02), accentMaterial);
      eye.position.set(0, 1.6, 0.32);
      const armGeometry = new THREE.BoxGeometry(0.28, 0.9, 0.28);
      const leftArm = new THREE.Mesh(armGeometry, bodyMaterial.clone());
      leftArm.position.set(-0.65, 0.6, 0);
      const rightArm = new THREE.Mesh(armGeometry, bodyMaterial.clone());
      rightArm.position.set(0.65, 0.6, 0);
      const legGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.3);
      const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial.clone());
      leftLeg.position.set(-0.25, 0.1, 0);
      const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial.clone());
      rightLeg.position.set(0.25, 0.1, 0);
      [body, head, eye, leftArm, rightArm, leftLeg, rightLeg].forEach((mesh) => {
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        group.add(mesh);
      });
      return group;
    }

    spawnGolem() {
      const THREE = this.THREE;
      const golemGroup = this.ensureEntityGroup('golem');
      if (!THREE || !golemGroup) return;
      if (!Array.isArray(this.golems)) {
        this.golems = [];
      }
      if (this.golems.length >= GOLEM_MAX_PER_DIMENSION) return;
      const actor = this.createGolemActor();
      if (!actor) return;
      const base = this.getPlayerWorldPosition(this.tmpVector3);
      const angle = Math.random() * Math.PI * 2;
      const radius = 6 + Math.random() * 4;
      const x = base.x + Math.cos(angle) * radius;
      const z = base.z + Math.sin(angle) * radius;
      const ground = this.sampleGroundHeight(x, z);
      actor.position.set(x, ground + 1, z);
      this.ensureNavigationMeshForWorldPosition(x, z);
      golemGroup.add(actor);
      const golem = {
        id: `golem-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
        mesh: actor,
        collisionRadius: GOLEM_COLLISION_RADIUS,
        cooldown: 0,
        speed: 3.1,
        placeholder: true,
        animation: null,
      };
      this.golems.push(golem);
      this.upgradeGolem(golem);
      this.lastGolemSpawn = this.elapsed;
      this.showHint('An iron golem joins your defense.');
    }

    updateGolems(delta) {
      const golemGroup = this.ensureEntityGroup('golem');
      if (!golemGroup) return;
      if (!Array.isArray(this.golems)) {
        this.golems = [];
      }
      const shouldSpawnGuard = this.isNight() || this.zombies.length > 0;
      if (
        shouldSpawnGuard &&
        this.elapsed - this.lastGolemSpawn > GOLEM_SPAWN_INTERVAL &&
        this.golems.length < GOLEM_MAX_PER_DIMENSION
      ) {
        this.spawnGolem();
      }
      if (!this.golems.length) return;
      const THREE = this.THREE;
      const playerPosition = this.getPlayerWorldPosition(this.tmpVector3);
      this.ensureNavigationMeshForActorPosition('golem', playerPosition.x, playerPosition.z, {
        reason: 'golem-escort-target',
        stage: 'player-tracking',
      });
      for (const golem of this.golems) {
        if (!Number.isFinite(golem.collisionRadius)) {
          golem.collisionRadius = GOLEM_COLLISION_RADIUS;
        }
        golem.cooldown = Math.max(0, golem.cooldown - delta);
        const target = this.findNearestZombie(golem.mesh.position) ?? null;
        const destination = target?.mesh?.position ?? playerPosition;
        const golemChunkKey = this.getChunkKeyForWorldPosition(golem.mesh.position.x, golem.mesh.position.z);
        this.ensureNavigationMeshForActorPosition('golem', golem.mesh.position.x, golem.mesh.position.z, {
          reason: 'golem-chase',
          stage: 'current',
          golemId: golem.id,
        });
        if (destination) {
          this.ensureNavigationMeshForActorPosition('golem', destination.x, destination.z, {
            reason: target ? 'golem-target' : 'golem-escort',
            stage: target ? 'target' : 'escort',
            golemId: golem.id,
            zombieId: target?.id ?? null,
          });
        }
        if (destination) {
          this.tmpVector.subVectors(destination, golem.mesh.position);
          const distance = this.tmpVector.length();
          if (!Number.isFinite(distance)) {
            this.warnAiMovementFailure('golem', {
              stage: 'chase',
              reason: 'distance-invalid',
              golemId: golem.id,
              zombieId: target?.id ?? null,
              chunkKey: golemChunkKey ?? null,
            });
            continue;
          }
          let baseState = 'idle';
          if (distance > 0.001) {
            this.tmpVector.normalize();
            this.tmpVector2.copy(this.tmpVector).multiplyScalar(golem.speed * delta);
            golem.mesh.position.add(this.tmpVector2);
            golem.mesh.rotation.y = Math.atan2(this.tmpVector.x, this.tmpVector.z);
            if (this.tmpVector2.lengthSq() > 1e-6) {
              baseState = 'walk';
            }
          }
          const ground = this.sampleGroundHeight(golem.mesh.position.x, golem.mesh.position.z);
          golem.mesh.position.y = THREE.MathUtils.lerp(golem.mesh.position.y, ground + 1.1, delta * 8);
          if (
            !Number.isFinite(golem.mesh.position.x) ||
            !Number.isFinite(golem.mesh.position.y) ||
            !Number.isFinite(golem.mesh.position.z)
          ) {
            this.warnAiMovementFailure('golem', {
              stage: 'integration',
              reason: 'position-invalid',
              golemId: golem.id,
              zombieId: target?.id ?? null,
              chunkKey: golemChunkKey ?? null,
              x: golem.mesh.position.x,
              y: golem.mesh.position.y,
              z: golem.mesh.position.z,
            });
          }
          if (target && distance < GOLEM_CONTACT_RANGE && golem.cooldown <= 0) {
            this.removeZombie(target);
            golem.cooldown = 1.1;
            this.score += 0.5;
            this.addScoreBreakdown('combat', 0.5);
            this.updateHud();
            this.audio.play('zombieGroan', { volume: 0.3 });
            this.showHint('Iron golem smashed a zombie!');
            this.scheduleScoreSync('golem-defense');
            if (golem.animation) {
              this.triggerAnimationRigPulse(golem.animation, 'attack', {
                duration: 0.8,
                fadeIn: 0.1,
                fadeOut: 0.25,
                fallbackState: baseState,
              });
            }
          }
          if (golem.animation) {
            this.setAnimationRigState(golem.animation, baseState);
            this.updateAnimationRig(golem.animation, delta);
          }
        } else if (golem.animation) {
          this.setAnimationRigState(golem.animation, 'idle');
          this.updateAnimationRig(golem.animation, delta);
        }
      }
      const playerBounds = this.getPlayerPhysicsBounds();
      this.resolveMobCollectionCollisions(this.golems, {
        type: 'golem',
        fallbackRadius: GOLEM_COLLISION_RADIUS,
        playerBounds,
      });
      const beforeCullCount = this.golems.length;
      this.golems = this.golems.filter((golem) => {
        const keep = golem.mesh.parent === this.golemGroup;
        if (!keep && golem.animation) {
          this.disposeAnimationRig(golem.animation);
          golem.animation = null;
        }
        return keep;
      });
      const removedCount = beforeCullCount - this.golems.length;
      if (removedCount > 0 && shouldSpawnGuard && this.golems.length < GOLEM_MAX_PER_DIMENSION) {
        this.spawnGolem();
      }
    }

    runImmediateGolemDefense() {
      if (typeof this.updateGolems !== 'function') {
        return;
      }
      try {
        this.updateGolems(0);
      } catch (error) {
        console.warn('Failed to synchronise golem defence after zombie spawn.', error);
      }
    }

    clearGolems() {
      if (!this.golems.length) return;
      for (const golem of this.golems) {
        if (golem.animation) {
          this.disposeAnimationRig(golem.animation);
          golem.animation = null;
        }
        this.golemGroup.remove(golem.mesh);
        disposeObject3D(golem.mesh);
      }
      this.golemGroup?.clear?.();
      this.golems = [];
    }

    removeGolem(target) {
      if (!target) return;
      if (!Array.isArray(this.golems)) {
        this.golems = [];
      }
      const index = this.golems.indexOf(target);
      if (index >= 0) {
        this.golems.splice(index, 1);
      }
      if (target.animation) {
        this.disposeAnimationRig(target.animation);
        target.animation = null;
      }
      if (target.mesh && this.golemGroup?.remove) {
        try {
          this.golemGroup.remove(target.mesh);
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Failed to detach golem mesh during removal.', error);
          }
        }
      }
      if (target.mesh) {
        disposeObject3D(target.mesh);
      }
    }

    damagePlayer(amount) {
      const previous = this.health;
      this.health = Math.max(0, this.health - amount);
      if (this.health !== previous) {
        this.updateHud();
        this.audio.play('playerHit', {
          volume: 0.58 + Math.random() * 0.18,
          rate: 0.88 + Math.random() * 0.12,
        });
        this.triggerCameraImpulse(0.6, 0.4);
      }
      if (this.health <= 0) {
        this.handleDefeat();
      }
    }

    handleDefeat() {
      const maxHealth = Number.isFinite(this.maxHealth)
        ? Math.max(0, Math.round(this.maxHealth))
        : FALLBACK_HEALTH;
      this.health = maxHealth || FALLBACK_HEALTH;
      const breathCapacity = Number.isFinite(this.playerBreathCapacity)
        ? Math.max(1, Math.round(this.playerBreathCapacity))
        : FALLBACK_BREATH;
      this.playerBreath = breathCapacity;
      this.restoreRespawnInventorySnapshot();
      const penalty = Math.min(4, Math.max(0, this.score ?? 0));
      if (penalty > 0) {
        this.addScoreBreakdown('penalties', penalty);
      }
      this.score = Math.max(0, this.score - 4);
      this.verticalVelocity = 0;
      this.isGrounded = false;
      this.positionPlayer();
      this.clearZombies();
      this.lastZombieSpawn = this.elapsed;
      this.clearGolems();
      this.lastGolemSpawn = this.elapsed;
      this.updateHud({ reason: 'respawn' });
      this.scheduleScoreSync('respawn');
      this.audio.play('bubble', { volume: 0.45 });
      console.error(
        'Respawn handler invoked. Ensure checkpoint logic restores player position, inventory, and status effects as expected.',
      );
    }

    mineBlock() {
      const intersections = this.castFromCamera();
      if (!intersections.length) return;
      const hit = intersections.find((intersection) => intersection.object?.userData?.columnKey);
      if (!hit) return;
      const mesh = hit.object;
      const columnKey = mesh.userData.columnKey;
      const column = this.columns.get(columnKey);
      if (!column || !column.length) return;
      const top = column[column.length - 1];
      if (top !== mesh) {
        return;
      }
      column.pop();
      if (mesh.parent) {
        mesh.parent.remove(mesh);
      } else {
        this.terrainGroup.remove(mesh);
      }
      const removedChunkKey = mesh.userData?.chunkKey || this.getTerrainChunkKey(mesh.userData.gx, mesh.userData.gz);
      this.markTerrainChunkDirty(removedChunkKey);
      this.blocksMined += 1;
      const blockType = mesh.userData.blockType || 'stone';
      const blockScore = blockType === 'stone' ? 1 : 0.75;
      this.score += blockScore;
      this.addScoreBreakdown('exploration', blockScore);
      this.heightMap[mesh.userData.gx][mesh.userData.gz] = column.length;
      if (column.length) {
        const newTop = column[column.length - 1];
        newTop.material = this.materials.grass;
        newTop.userData.blockType = 'grass-block';
      }
      this.updatePortalFrameStateForColumn(mesh.userData.gx, mesh.userData.gz);
      const drops = this.getDropsForBlock(blockType);
      if (drops.length) {
        this.collectDrops(drops);
      }
      this.markGuidanceProgress('gather');
      this.updateHud();
      this.audio.playRandom(['miningA', 'miningB'], {
        volume: 0.45 + Math.random() * 0.2,
        rate: 0.92 + Math.random() * 0.12,
      });
      this.triggerCameraImpulse(0.45, 0.22);
    }

    placeBlock() {
      const intersections = this.castFromCamera();
      if (!Array.isArray(intersections) || !intersections.length) return;
      const hit = intersections.find((intersection) => intersection.object?.userData?.columnKey);
      if (!hit) return;
      const mesh = hit.object;
      const { columnKey, gx, gz } = mesh.userData || {};
      if (typeof columnKey !== 'string') {
        return;
      }
      if (!Number.isInteger(gx) || !Number.isInteger(gz)) {
        return;
      }
      const column = this.columns.get(columnKey) ?? [];
      const newLevel = column.length;
      const worldX = mesh.position.x;
      const worldZ = mesh.position.z;
      if (newLevel >= 12) {
        this.showHint('Column at maximum height. Try another spot.');
        return;
      }
      const allowed = new Set(['grass-block', 'dirt', 'stone']);
      const selectedSlot = this.hotbar?.[this.selectedHotbarIndex];
      const selectedItem = selectedSlot?.item;
      if (!selectedItem || selectedSlot.quantity <= 0 || !allowed.has(selectedItem)) {
        this.showHint('Select a block in your hotbar to place it.');
        return;
      }
      let portalSlot = null;
      if (selectedItem === 'stone') {
        portalSlot = this.getPortalFrameSlotForPlacement(gx, gz, newLevel);
      }
      if (portalSlot) {
        const obstructions = this.collectPortalFrameSlotObstructions(portalSlot);
        if (obstructions.length) {
          const message = this.formatPortalPlacementRejectionMessage(obstructions);
          this.portalFootprintObstructed = true;
          this.portalFootprintObstructionSummary = message;
          this.logPortalFramePlacementRejection(portalSlot, obstructions, {
            gridX: gx,
            gridZ: gz,
            level: newLevel,
          });
          if (typeof this.showHint === 'function') {
            this.showHint(message);
          }
          if (typeof this.updatePortalProgress === 'function') {
            this.updatePortalProgress();
          }
          if (typeof this.setPortalStatusIndicator === 'function') {
            this.setPortalStatusIndicator('blocked', message, 'Portal Blocked');
          }
          return;
        }
      }
      const consumed = this.useSelectedItem({ allow: allowed });
      if (!consumed) {
        this.showHint('Select a block in your hotbar to place it.');
        return;
      }
      const blockType = consumed;
      const material = this.getMaterialForBlock(blockType);
      if (column.length) {
        const prevTop = column[column.length - 1];
        if (prevTop) {
          prevTop.material = this.materials.dirt;
          prevTop.userData.blockType = 'dirt';
        }
      }
      const chunkKey = this.getTerrainChunkKey(gx, gz);
      const chunk = this.ensureTerrainChunk(chunkKey);
      const newMesh = new this.THREE.Mesh(this.blockGeometry, material);
      newMesh.castShadow = true;
      newMesh.receiveShadow = true;
      newMesh.position.set(worldX, newLevel * BLOCK_SIZE + BLOCK_SIZE / 2, worldZ);
      newMesh.matrixAutoUpdate = false;
      newMesh.updateMatrix();
      newMesh.userData = { columnKey, level: newLevel, gx, gz, blockType, chunkKey };
      chunk.add(newMesh);
      this.markTerrainChunkDirty(chunkKey);
      column.push(newMesh);
      this.columns.set(columnKey, column);
      this.heightMap[gx][gz] = column.length;
      this.blocksPlaced += 1;
      const placementPenalty = Math.min(0.25, Math.max(0, this.score ?? 0));
      if (placementPenalty > 0) {
        this.addScoreBreakdown('penalties', placementPenalty);
      }
      this.score = Math.max(0, this.score - 0.25);
      this.updatePortalFrameStateForColumn(gx, gz);
      this.updateHud();
      this.markGuidanceProgress('build');
      this.audio.play('blockPlace', {
        volume: 0.42 + Math.random() * 0.12,
        rate: 1.18 + Math.random() * 0.12,
      });
      this.triggerCameraImpulse(0.32, 0.18);
    }

    castFromCamera() {
      const THREE = this.THREE;
      if (!this.camera) return [];
      const origin = this.getCameraWorldPosition(this.tmpVector3);
      const direction = this.getCameraWorldDirection(this.tmpVector);
      this.raycaster.set(origin, direction.normalize());
      return this.raycaster.intersectObjects(this.terrainGroup.children, true);
    }

    getMaterialForBlock(blockType) {
      if (blockType === 'grass-block') return this.materials.grass;
      if (blockType === 'dirt') return this.materials.dirt;
      return this.materials.stone;
    }

    getDropsForBlock(blockType) {
      const drops = [];
      if (blockType === 'grass-block') {
        drops.push({ item: 'grass-block', quantity: 1 });
        if (Math.random() < 0.35) {
          drops.push({ item: 'stick', quantity: 1 });
        }
      } else if (blockType === 'dirt') {
        drops.push({ item: 'dirt', quantity: 1 });
        if (Math.random() < 0.15) {
          drops.push({ item: 'stick', quantity: 1 });
        }
      } else if (blockType === 'stone') {
        drops.push({ item: 'stone', quantity: 1 });
        if (this.currentDimensionIndex >= 2 && Math.random() < 0.18) {
          drops.push({ item: 'portal-charge', quantity: 1 });
        }
      } else {
        drops.push({ item: blockType, quantity: 1 });
      }
      return drops;
    }

    collectDrops(drops = []) {
      let collectedAny = false;
      drops.forEach(({ item, quantity }) => {
        if (!item || quantity <= 0) return;
        const accepted = this.addItemToInventory(item, quantity);
        if (accepted) {
          collectedAny = true;
        }
      });
      if (collectedAny) {
        this.updateHud();
        this.markGuidanceProgress('collect');
      }
    }

    ensurePlayerPhysicsBody() {
      const THREE = this.THREE;
      const rig = this.playerRig;
      if (!THREE || !rig || typeof THREE.Object3D !== 'function') {
        return this.playerPhysicsBody || null;
      }
      const radius = Number.isFinite(this.playerPhysicsRadius) ? this.playerPhysicsRadius : 0.6;
      const height = Number.isFinite(this.playerPhysicsHeight)
        ? this.playerPhysicsHeight
        : PLAYER_EYE_HEIGHT + 0.2;
      const centerOffset = Number.isFinite(this.playerPhysicsCenterOffset)
        ? this.playerPhysicsCenterOffset
        : -PLAYER_EYE_HEIGHT * 0.5;
      if (!this.playerPhysicsBody || this.playerPhysicsBody.isObject3D !== true) {
        if (
          this.playerPhysicsBody &&
          this.playerPhysicsBody.parent &&
          typeof this.playerPhysicsBody.parent.remove === 'function'
        ) {
          try {
            this.playerPhysicsBody.parent.remove(this.playerPhysicsBody);
          } catch (error) {
            if (typeof console !== 'undefined' && typeof console.debug === 'function') {
              console.debug('Failed to detach stale player physics body.', error);
            }
          }
        }
        const body = new THREE.Object3D();
        body.name = 'PlayerPhysicsBody';
        body.visible = false;
        body.position.set(0, centerOffset, 0);
        body.userData = { radius, height, centerOffset };
        this.playerPhysicsBody = body;
      } else {
        if (this.playerPhysicsBody.userData) {
          this.playerPhysicsBody.userData.radius = radius;
          this.playerPhysicsBody.userData.height = height;
          this.playerPhysicsBody.userData.centerOffset = centerOffset;
        }
        if (this.playerPhysicsBody.position) {
          this.playerPhysicsBody.position.set(0, centerOffset, 0);
        }
      }
      if (this.playerPhysicsBody.parent !== rig && typeof rig.add === 'function') {
        rig.add(this.playerPhysicsBody);
      }
      return this.playerPhysicsBody;
    }

    getPlayerAvatarWorldPosition(target) {
      const THREE = this.THREE;
      let destination = target || null;
      if (!destination) {
        if (THREE && typeof THREE.Vector3 === 'function') {
          if (!this.tmpVector4 || typeof this.tmpVector4.set !== 'function') {
            this.tmpVector4 = new THREE.Vector3();
          }
          destination = this.tmpVector4;
          destination.set(0, 0, 0);
        } else {
          destination = { x: 0, y: 0, z: 0 };
        }
      }
      const avatar = this.playerAvatar;
      if (avatar && typeof avatar.getWorldPosition === 'function') {
        try {
          avatar.getWorldPosition(destination);
          return destination;
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Unable to resolve player avatar world position.', error);
          }
        }
      }
      const rig = this.playerRig;
      if (rig && typeof rig.getWorldPosition === 'function') {
        try {
          rig.getWorldPosition(destination);
          return destination;
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Unable to resolve player rig world position fallback.', error);
          }
        }
      }
      if (rig?.position && typeof destination.copy === 'function') {
        destination.copy(rig.position);
        return destination;
      }
      return this.getPlayerWorldPosition(destination);
    }

    getPlayerWorldPosition(target) {
      const THREE = this.THREE;
      const destination =
        target ||
        (THREE && typeof THREE.Vector3 === 'function'
          ? new THREE.Vector3()
          : { x: 0, y: 0, z: 0 });
      const body = this.ensurePlayerPhysicsBody();
      if (body?.getWorldPosition) {
        body.getWorldPosition(destination);
        return destination;
      }
      const rigPosition = this.playerRig?.position || null;
      if (rigPosition) {
        if (typeof destination.copy === 'function' && typeof rigPosition.copy === 'function') {
          destination.copy(rigPosition);
        } else {
          destination.x = rigPosition.x ?? 0;
          destination.y = rigPosition.y ?? 0;
          destination.z = rigPosition.z ?? 0;
        }
        const offset = Number.isFinite(this.playerPhysicsCenterOffset)
          ? this.playerPhysicsCenterOffset
          : -PLAYER_EYE_HEIGHT * 0.5;
        if (destination.y !== undefined && destination.y !== null) {
          destination.y += offset;
        }
        return destination;
      }
      return this.getCameraWorldPosition(destination);
    }

    getPlayerPhysicsBounds() {
      const THREE = this.THREE;
      const cloneVector = (source) => {
        if (!source) return null;
        if (typeof source.clone === 'function') {
          return source.clone();
        }
        if (THREE && typeof THREE.Vector3 === 'function') {
          return new THREE.Vector3(source.x ?? 0, source.y ?? 0, source.z ?? 0);
        }
        return {
          x: Number.isFinite(source.x) ? source.x : 0,
          y: Number.isFinite(source.y) ? source.y : 0,
          z: Number.isFinite(source.z) ? source.z : 0,
        };
      };
      const body = this.ensurePlayerPhysicsBody();
      const radius = Number.isFinite(body?.userData?.radius)
        ? body.userData.radius
        : Number.isFinite(this.playerPhysicsRadius)
          ? this.playerPhysicsRadius
          : 0.6;
      const height = Number.isFinite(body?.userData?.height)
        ? body.userData.height
        : Number.isFinite(this.playerPhysicsHeight)
          ? this.playerPhysicsHeight
          : PLAYER_EYE_HEIGHT + 0.2;
      const halfHeight = height / 2;
      let center = null;
      if (body?.getWorldPosition) {
        if (THREE && typeof THREE.Vector3 === 'function') {
          center = new THREE.Vector3();
          body.getWorldPosition(center);
        } else {
          const tmp = { x: 0, y: 0, z: 0 };
          body.getWorldPosition(tmp);
          center = {
            x: Number.isFinite(tmp.x) ? tmp.x : 0,
            y: Number.isFinite(tmp.y) ? tmp.y : 0,
            z: Number.isFinite(tmp.z) ? tmp.z : 0,
          };
        }
      } else if (this.playerRig?.position) {
        center = cloneVector(this.playerRig.position);
        const offset = Number.isFinite(this.playerPhysicsCenterOffset)
          ? this.playerPhysicsCenterOffset
          : -PLAYER_EYE_HEIGHT * 0.5;
        if (center && typeof center.y === 'number') {
          center.y += offset;
        }
      } else {
        const fallback = this.getCameraWorldPosition(
          THREE && typeof THREE.Vector3 === 'function' ? new THREE.Vector3() : { x: 0, y: 0, z: 0 },
        );
        center = cloneVector(fallback);
      }
      if (!center) {
        return null;
      }
      return {
        position: center,
        radius,
        top: center.y + halfHeight,
        bottom: center.y - halfHeight,
        height,
      };
    }

    getCameraWorldPosition(target) {
      const THREE = this.THREE;
      const destination = target ?? (THREE ? new THREE.Vector3() : { x: 0, y: 0, z: 0 });
      if (this.camera?.getWorldPosition) {
        this.camera.getWorldPosition(destination);
        return destination;
      }
      if (this.playerRig) {
        destination.copy?.(this.playerRig.position);
        if (!destination.copy) {
          destination.x = this.playerRig.position.x;
          destination.y = this.playerRig.position.y;
          destination.z = this.playerRig.position.z;
        }
        return destination;
      }
      if (destination.set) {
        destination.set(0, 0, 0);
      } else {
        destination.x = 0;
        destination.y = 0;
        destination.z = 0;
      }
      return destination;
    }

    getCameraWorldDirection(target) {
      const THREE = this.THREE;
      const destination = target ?? (THREE ? new THREE.Vector3() : { x: 0, y: 0, z: -1 });
      if (this.camera?.getWorldDirection) {
        this.camera.getWorldDirection(destination);
        if (destination.normalize) destination.normalize();
        return destination;
      }
      if (this.camera?.quaternion && destination.set) {
        destination.set(0, 0, -1).applyQuaternion(this.camera.quaternion).normalize();
        return destination;
      }
      if (destination.set) {
        destination.set(0, 0, -1);
      } else {
        destination.x = 0;
        destination.y = 0;
        destination.z = -1;
      }
      return destination;
    }

    addItemToInventory(item, quantity = 1) {
      const safeItem = typeof item === 'string' ? item : item ?? null;
      const numericQuantity = Number.isFinite(quantity) ? Math.max(0, quantity) : 0;
      if (!safeItem || numericQuantity <= 0) return false;
      const mutateInventory = () => {
        let remaining = numericQuantity;
        if (Array.isArray(this.hotbar)) {
          for (let i = 0; i < this.hotbar.length && remaining > 0; i += 1) {
            const slot = this.hotbar[i];
            if (slot.item === safeItem && slot.quantity < MAX_STACK_SIZE) {
              const add = Math.min(MAX_STACK_SIZE - slot.quantity, remaining);
              slot.quantity += add;
              remaining -= add;
            }
          }
          for (let i = 0; i < this.hotbar.length && remaining > 0; i += 1) {
            const slot = this.hotbar[i];
            if (!slot.item) {
              const add = Math.min(MAX_STACK_SIZE, remaining);
              slot.item = safeItem;
              slot.quantity = add;
              remaining -= add;
            }
          }
        }
        if (remaining > 0) {
          const existing = this.satchel.get(safeItem) ?? 0;
          this.satchel.set(safeItem, existing + remaining);
          remaining = 0;
        }
        if (remaining === 0) {
          this.updateInventoryUi();
          return true;
        }
        return false;
      };
      try {
        return this.withGameplayAtomicSnapshot({ inventory: true }, mutateInventory, { scope: 'inventory-add' });
      } catch (error) {
        if (isAtomicAbortError(error)) {
          if (typeof console !== 'undefined' && typeof console.warn === 'function') {
            console.warn('Inventory add aborted due to asset instability.', error);
          }
          notifyLiveDiagnostics(
            'inventory',
            'Inventory add aborted due to asset instability.',
            { error: normaliseLiveDiagnosticError(error), scope: 'inventory-add', item: safeItem },
            { level: 'warning' },
          );
          return false;
        }
        throw error;
      }
    }

    removeItemFromInventory(item, quantity = 1) {
      const safeItem = typeof item === 'string' ? item : item ?? null;
      const numericQuantity = Number.isFinite(quantity) ? Math.max(0, quantity) : 0;
      if (!safeItem || numericQuantity <= 0) return 0;
      const mutateInventory = () => {
        let remaining = numericQuantity;
        let removed = 0;
        if (Array.isArray(this.hotbar)) {
          for (let i = 0; i < this.hotbar.length && remaining > 0; i += 1) {
            const slot = this.hotbar[i];
            if (slot.item !== safeItem) continue;
            const take = Math.min(slot.quantity, remaining);
            slot.quantity -= take;
            remaining -= take;
            removed += take;
            if (slot.quantity <= 0) {
              slot.item = null;
              slot.quantity = 0;
            }
          }
        }
        if (remaining > 0) {
          const available = this.satchel.get(safeItem) ?? 0;
          const take = Math.min(available, remaining);
          if (take > 0) {
            this.satchel.set(safeItem, available - take);
            remaining -= take;
            removed += take;
          }
          if (this.satchel.get(safeItem) === 0) {
            this.satchel.delete(safeItem);
          }
        }
        if (removed > 0) {
          this.updateInventoryUi();
        }
        return removed;
      };
      try {
        return this.withGameplayAtomicSnapshot({ inventory: true }, mutateInventory, { scope: 'inventory-remove' });
      } catch (error) {
        if (isAtomicAbortError(error)) {
          if (typeof console !== 'undefined' && typeof console.warn === 'function') {
            console.warn('Inventory removal aborted due to asset instability.', error);
          }
          notifyLiveDiagnostics(
            'inventory',
            'Inventory removal aborted due to asset instability.',
            { error: normaliseLiveDiagnosticError(error), scope: 'inventory-remove', item: safeItem },
            { level: 'warning' },
          );
          return 0;
        }
        throw error;
      }
    }

    useSelectedItem({ allow } = {}) {
      const slot = this.hotbar[this.selectedHotbarIndex];
      if (!slot?.item || slot.quantity <= 0) {
        return null;
      }
      if (allow instanceof Set && !allow.has(slot.item)) {
        return null;
      }
      const item = slot.item;
      slot.quantity -= 1;
      if (slot.quantity <= 0) {
        slot.item = null;
        slot.quantity = 0;
        this.refillHotbarSlot(this.selectedHotbarIndex, item);
      }
      this.updateInventoryUi();
      return item;
    }

    refillHotbarSlot(index, item) {
      if (!item) return;
      const available = this.satchel.get(item);
      if (!available) return;
      const slot = this.hotbar[index];
      const take = Math.min(MAX_STACK_SIZE, available);
      slot.item = item;
      slot.quantity = take;
      this.satchel.set(item, available - take);
      if (this.satchel.get(item) === 0) {
        this.satchel.delete(item);
      }
    }

    getTotalInventoryCount() {
      const hotbarTotal = this.hotbar.reduce((sum, slot) => sum + (slot.quantity || 0), 0);
      let satchelTotal = 0;
      this.satchel.forEach((value) => {
        satchelTotal += value;
      });
      return hotbarTotal + satchelTotal;
    }

    updateInventoryUi() {
      this.activeHotbarDrag = null;
      this.activeHotbarPointerDrag = null;
      this.updateHotbarUi();
      this.updateCraftingInventoryUi();
      this.updateInventoryModal();
      this.updateExtendedInventoryUi();
      this.updateHotbarExpansionUi();
      this.updateCraftButtonState();
      this.refreshEquippedItem();
      this.captureRespawnInventorySnapshot();
    }

    captureRespawnInventorySnapshot() {
      if (!Array.isArray(this.hotbar) || !(this.satchel instanceof Map)) {
        return;
      }
      const hotbarSnapshot = this.hotbar.map((slot = { item: null, quantity: 0 }) => ({
        item: slot && typeof slot.item === 'string' ? slot.item : slot?.item ?? null,
        quantity: Number.isFinite(slot?.quantity) ? Math.max(0, slot.quantity) : 0,
      }));
      const satchelSnapshot = [];
      this.satchel.forEach((quantity, item) => {
        const safeItem = typeof item === 'string' ? item : null;
        if (!safeItem) {
          return;
        }
        const safeQuantity = Number.isFinite(quantity) ? Math.max(0, quantity) : 0;
        satchelSnapshot.push([safeItem, safeQuantity]);
      });
      const selectedIndex = Number.isInteger(this.selectedHotbarIndex) ? this.selectedHotbarIndex : 0;
      this.respawnInventorySnapshot = {
        hotbar: hotbarSnapshot,
        satchel: satchelSnapshot,
        selectedHotbarIndex: selectedIndex,
      };
    }

    restoreRespawnInventorySnapshot() {
      const snapshot = this.respawnInventorySnapshot;
      if (!snapshot) {
        return;
      }
      const performRestore = () => {
        let restored = false;
        if (Array.isArray(snapshot.hotbar) && Array.isArray(this.hotbar)) {
          const length = this.hotbar.length;
          for (let i = 0; i < length; i += 1) {
            const target = this.hotbar[i];
            const source = snapshot.hotbar[i] || { item: null, quantity: 0 };
            const item = typeof source.item === 'string' ? source.item : source.item ?? null;
            const quantity = Number.isFinite(source.quantity) ? Math.max(0, source.quantity) : 0;
            if (target) {
              target.item = item;
              target.quantity = quantity;
            } else {
              this.hotbar[i] = { item, quantity };
            }
          }
          restored = true;
        }
        if (Array.isArray(snapshot.satchel) && this.satchel instanceof Map) {
          this.satchel.clear();
          snapshot.satchel.forEach(([item, quantity]) => {
            const safeItem = typeof item === 'string' ? item : null;
            const safeQuantity = Number.isFinite(quantity) ? Math.max(0, quantity) : 0;
            if (safeItem && safeQuantity > 0) {
              this.satchel.set(safeItem, safeQuantity);
            }
          });
          restored = true;
        }
        if (Number.isInteger(snapshot.selectedHotbarIndex) && Array.isArray(this.hotbar) && this.hotbar.length) {
          const clamped = Math.max(0, Math.min(this.hotbar.length - 1, snapshot.selectedHotbarIndex));
          this.selectedHotbarIndex = clamped;
          restored = true;
        }
        if (restored) {
          this.updateInventoryUi();
        }
        return restored;
      };
      try {
        return this.withGameplayAtomicSnapshot({ inventory: true }, performRestore, { scope: 'inventory-restore' });
      } catch (error) {
        if (isAtomicAbortError(error)) {
          if (typeof console !== 'undefined' && typeof console.warn === 'function') {
            console.warn('Inventory restore aborted due to asset instability.', error);
          }
          notifyLiveDiagnostics(
            'inventory',
            'Inventory restore aborted due to asset instability.',
            { error: normaliseLiveDiagnosticError(error), scope: 'inventory-restore' },
            { level: 'warning' },
          );
          return false;
        }
        throw error;
      }
    }

    updateHotbarUi() {
      if (!this.hotbarEl) return;
      const fragment = document.createDocumentFragment();
      this.hotbar.forEach((slot, index) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'hotbar-slot';
        button.dataset.hotbarSlot = String(index);
        const isActive = index === this.selectedHotbarIndex;
        button.dataset.active = isActive ? 'true' : 'false';
        if (slot?.item) {
          const def = getItemDefinition(slot.item);
          button.textContent = `${def.icon} ${slot.quantity}`;
          button.setAttribute('aria-label', formatInventoryLabel(slot.item, slot.quantity));
          button.setAttribute('draggable', 'true');
          const hints = [];
          if (def.description) {
            hints.push(def.description);
          }
          hints.push('Click to equip • Drag to reorder');
          button.setAttribute('data-hint', `${hints.join(' — ')} (×${slot.quantity})`);
          button.addEventListener('dragstart', this.onHotbarDragStart);
        } else {
          button.textContent = '·';
          button.setAttribute('aria-label', 'Empty slot');
          button.setAttribute('draggable', 'false');
          button.setAttribute('data-hint', 'Empty slot — gather resources to fill your hotbar.');
        }
        button.addEventListener('dragenter', this.onHotbarDragEnter);
        button.addEventListener('dragover', this.onHotbarDragOver);
        button.addEventListener('dragleave', this.onHotbarDragLeave);
        button.addEventListener('drop', this.onHotbarDrop);
        button.addEventListener('dragend', this.onHotbarDragEnd);
        button.addEventListener('pointerdown', this.onHotbarPointerDown);
        button.addEventListener('pointerenter', this.onHotbarPointerEnter);
        button.addEventListener('pointerleave', this.onHotbarPointerLeave);
        button.addEventListener('pointerup', this.onHotbarPointerUp);
        button.addEventListener('pointercancel', this.onHotbarPointerCancel);
        fragment.appendChild(button);
      });
      this.hotbarEl.innerHTML = '';
      this.hotbarEl.appendChild(fragment);
    }

    refreshEquippedItem() {
      const slot = Array.isArray(this.hotbar) ? this.hotbar[this.selectedHotbarIndex] : null;
      const rawQuantity = Number.isFinite(slot?.quantity) ? slot.quantity : 0;
      const quantity = Math.max(0, rawQuantity);
      const itemId = slot?.item && quantity > 0 ? slot.item : null;
      this.updateHandOverlay(itemId, quantity);
      const normalisedQuantity = itemId ? quantity : 0;
      if (this.equippedItemId === itemId && this.equippedItemQuantity === normalisedQuantity) {
        this.pendingEquippedItemId = itemId || null;
        if (!itemId) {
          this.attachEquippedItemModel(null);
        }
        return;
      }
      this.equippedItemId = itemId;
      this.equippedItemQuantity = normalisedQuantity;
      this.pendingEquippedItemId = itemId || null;
      this.attachEquippedItemModel(itemId);
    }

    updateHandOverlay(itemId, quantity = 0) {
      const overlay = this.handOverlayEl;
      const icon = this.handOverlayIconEl;
      const labelEl = this.handOverlayLabelEl;
      const hasItem = Boolean(itemId) && quantity > 0;
      const datasetValue = hasItem ? itemId : 'fist';
      const count = hasItem ? Math.max(1, quantity) : 0;
      if (overlay) {
        if (!overlay.dataset) {
          overlay.dataset = {};
        }
        overlay.dataset.item = datasetValue;
        overlay.dataset.quantity = String(count);
        if (typeof overlay.removeAttribute === 'function') {
          overlay.removeAttribute('aria-hidden');
          const ariaLabel = hasItem ? formatInventoryLabel(itemId, count) : 'Fist equipped';
          overlay.setAttribute('aria-label', ariaLabel);
        }
        overlay.hidden = false;
        if (typeof overlay.removeAttribute === 'function') {
          overlay.removeAttribute('hidden');
        }
      }
      if (icon) {
        if (!icon.dataset) {
          icon.dataset = {};
        }
        icon.dataset.item = datasetValue;
      }
      if (labelEl) {
        if (hasItem) {
          const definition = getItemDefinition(itemId);
          const label = definition?.label || itemId;
          labelEl.textContent = count > 1 ? `${label} ×${count}` : label;
        } else {
          labelEl.textContent = 'Fist';
        }
      }
    }

    ensureHandItemAnchor() {
      if (!this.THREE || !this.rightHandGroup) {
        return null;
      }
      if (this.handItemAnchor && this.handItemAnchor.parent) {
        return this.handItemAnchor;
      }
      const anchor = new this.THREE.Group();
      anchor.name = 'EquippedItemAnchor';
      anchor.position.set(0.18, -0.18, 0.16);
      anchor.rotation.set(-0.55, 0.88, 0.35);
      this.rightHandGroup.add(anchor);
      this.handItemAnchor = anchor;
      return anchor;
    }

    disposeEquippedItemModel() {
      if (!this.equippedItemMesh) {
        return;
      }
      const mesh = this.equippedItemMesh;
      if (mesh.parent && typeof mesh.parent.remove === 'function') {
        mesh.parent.remove(mesh);
      }
      disposeObject3D(mesh);
      this.equippedItemMesh = null;
    }

    attachEquippedItemModel(itemId) {
      this.pendingEquippedItemId = itemId || null;
      if (!itemId) {
        this.disposeEquippedItemModel();
        return;
      }
      const anchor = this.ensureHandItemAnchor();
      if (!anchor) {
        return;
      }
      if (this.equippedItemMesh?.userData?.itemId === itemId && this.equippedItemMesh.parent === anchor) {
        return;
      }
      this.disposeEquippedItemModel();
      const model = this.buildEquippedItemModel(itemId);
      if (!model) {
        return;
      }
      anchor.add(model);
      this.equippedItemMesh = model;
    }

    buildEquippedItemModel(itemId) {
      const THREE = this.THREE;
      if (!THREE || !itemId) {
        return null;
      }
      const group = new THREE.Group();
      group.name = `EquippedItem:${itemId}`;
      const makeMaterial = (hex, options = {}) => {
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color(hex),
          roughness: options.roughness ?? 0.55,
          metalness: options.metalness ?? 0.25,
        });
        if (options.emissive) {
          material.emissive = new THREE.Color(options.emissive);
          material.emissiveIntensity = options.emissiveIntensity ?? 0.6;
        }
        return material;
      };
      const colorFromMaterial = (material, fallback) => {
        if (material?.color && typeof material.color.getHexString === 'function') {
          return `#${material.color.getHexString()}`;
        }
        return fallback;
      };
      const addMesh = (geometry, material) => {
        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        group.add(mesh);
        return mesh;
      };
      if (itemId === 'stone-pickaxe') {
        const handleMaterial = makeMaterial('#8b5a2b', { roughness: 0.6, metalness: 0.08 });
        const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.64, 8), handleMaterial);
        handle.rotation.z = Math.PI / 2;
        handle.position.set(0, -0.05, 0);
        handle.castShadow = true;
        handle.receiveShadow = true;
        group.add(handle);
        const headColor = colorFromMaterial(this.materials?.stone, '#9a9a9a');
        const headMaterial = makeMaterial(headColor, { roughness: 0.45, metalness: 0.35 });
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.36, 0.12, 0.16), headMaterial);
        head.position.set(0.18, 0.12, 0);
        head.rotation.z = -Math.PI / 6;
        head.castShadow = true;
        head.receiveShadow = true;
        group.add(head);
        const spike = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.1, 0.1), headMaterial.clone());
        spike.position.set(0.18, 0.2, 0);
        spike.rotation.z = Math.PI / 4;
        spike.castShadow = true;
        spike.receiveShadow = true;
        group.add(spike);
      } else if (itemId === 'stick') {
        const stickMaterial = makeMaterial('#a97142', { roughness: 0.65, metalness: 0.05 });
        const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.045, 0.6, 7), stickMaterial);
        rod.rotation.z = Math.PI / 2;
        rod.position.set(0, -0.05, 0);
        rod.castShadow = true;
        rod.receiveShadow = true;
        group.add(rod);
      } else if (itemId === 'portal-charge') {
        const chargeMaterial = makeMaterial('#7f5af0', {
          roughness: 0.25,
          metalness: 0.4,
          emissive: '#2cb67d',
          emissiveIntensity: 0.75,
        });
        const core = new THREE.Mesh(new THREE.IcosahedronGeometry(0.18, 0), chargeMaterial);
        core.castShadow = true;
        core.receiveShadow = true;
        group.add(core);
      } else if (itemId === 'eternal-ingot') {
        const ingotMaterial = makeMaterial('#fbbf24', { roughness: 0.3, metalness: 0.78 });
        const ingot = new THREE.Mesh(new THREE.BoxGeometry(0.38, 0.16, 0.2), ingotMaterial);
        ingot.castShadow = true;
        ingot.receiveShadow = true;
        group.add(ingot);
      } else if (itemId === 'grass-block') {
        const topColor = colorFromMaterial(this.materials?.grass, '#69c368');
        const sideColor = colorFromMaterial(this.materials?.dirt, '#a66a33');
        const base = addMesh(new THREE.BoxGeometry(0.34, 0.2, 0.34), makeMaterial(sideColor, { roughness: 0.7, metalness: 0.12 }));
        base.position.y = -0.04;
        const top = addMesh(new THREE.BoxGeometry(0.34, 0.14, 0.34), makeMaterial(topColor, { roughness: 0.5, metalness: 0.1 }));
        top.position.y = 0.16;
      } else if (itemId === 'dirt') {
        const dirtColor = colorFromMaterial(this.materials?.dirt, '#a66a33');
        addMesh(new THREE.BoxGeometry(0.34, 0.34, 0.34), makeMaterial(dirtColor, { roughness: 0.68, metalness: 0.12 }));
      } else if (itemId === 'stone') {
        const stoneColor = colorFromMaterial(this.materials?.stone, '#9a9a9a');
        addMesh(new THREE.BoxGeometry(0.34, 0.34, 0.34), makeMaterial(stoneColor, { roughness: 0.55, metalness: 0.3 }));
      } else {
        const fallbackColor = colorFromMaterial(this.materials?.stone, '#9a9a9a');
        addMesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), makeMaterial(fallbackColor, { roughness: 0.6, metalness: 0.2 }));
      }
      group.userData = { ...(group.userData || {}), itemId };
      group.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      return group;
    }

    clearHotbarDragIndicators() {
      if (!this.hotbarEl) return;
      this.hotbarEl
        .querySelectorAll('.hotbar-slot.dragging, .hotbar-slot.drag-over')
        .forEach((node) => node.classList.remove('dragging', 'drag-over'));
    }

    getHotbarSlotIndexFromElement(element) {
      if (!(element instanceof HTMLElement)) return null;
      const raw = element.dataset?.hotbarSlot ?? '-1';
      const index = Number.parseInt(raw, 10);
      if (!Number.isInteger(index) || index < 0 || index >= this.hotbar.length) {
        return null;
      }
      return index;
    }

    swapHotbarSlots(fromIndex, toIndex) {
      if (!Number.isInteger(fromIndex) || !Number.isInteger(toIndex)) return false;
      if (fromIndex === toIndex) return false;
      if (fromIndex < 0 || toIndex < 0) return false;
      if (fromIndex >= this.hotbar.length || toIndex >= this.hotbar.length) return false;
      const performSwap = () => {
        const from = this.hotbar[fromIndex];
        const to = this.hotbar[toIndex];
        this.hotbar[fromIndex] = to;
        this.hotbar[toIndex] = from;
        if (this.selectedHotbarIndex === fromIndex) {
          this.selectedHotbarIndex = toIndex;
        } else if (this.selectedHotbarIndex === toIndex) {
          this.selectedHotbarIndex = fromIndex;
        }
        this.updateInventoryUi();
        return true;
      };
      try {
        return this.withGameplayAtomicSnapshot({ inventory: true }, performSwap, { scope: 'inventory-swap' });
      } catch (error) {
        if (isAtomicAbortError(error)) {
          if (typeof console !== 'undefined' && typeof console.warn === 'function') {
            console.warn('Inventory swap aborted due to asset instability.', error);
          }
          notifyLiveDiagnostics(
            'inventory',
            'Inventory swap aborted due to asset instability.',
            {
              error: normaliseLiveDiagnosticError(error),
              scope: 'inventory-swap',
              fromIndex,
              toIndex,
            },
            { level: 'warning' },
          );
          return false;
        }
        throw error;
      }
    }

    handleHotbarDragStart(event) {
      const button = event.currentTarget;
      const index = this.getHotbarSlotIndexFromElement(button);
      if (index === null) {
        event.preventDefault();
        return;
      }
      const slot = this.hotbar[index];
      if (!slot?.item) {
        event.preventDefault();
        return;
      }
      this.activeHotbarDrag = { from: index };
      button.classList.add('dragging');
      if (event.dataTransfer) {
        try {
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', String(index));
        } catch (error) {
          // Ignore unsupported drag data operations.
        }
      }
    }

    handleHotbarDragEnter(event) {
      if (!this.activeHotbarDrag) return;
      event.preventDefault();
      event.currentTarget.classList.add('drag-over');
    }

    handleHotbarDragOver(event) {
      if (!this.activeHotbarDrag) return;
      event.preventDefault();
      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = 'move';
      }
    }

    handleHotbarDragLeave(event) {
      if (!this.activeHotbarDrag) return;
      const { currentTarget, relatedTarget } = event;
      if (relatedTarget instanceof HTMLElement && currentTarget.contains(relatedTarget)) {
        return;
      }
      currentTarget.classList.remove('drag-over');
    }

    handleHotbarDrop(event) {
      if (!this.activeHotbarDrag) return;
      event.preventDefault();
      let fromIndex = this.activeHotbarDrag.from;
      const targetIndex = this.getHotbarSlotIndexFromElement(event.currentTarget);
      if (event.dataTransfer) {
        try {
          const raw = event.dataTransfer.getData('text/plain');
          const parsed = Number.parseInt(raw, 10);
          if (Number.isInteger(parsed)) {
            fromIndex = parsed;
          }
        } catch (error) {
          // Ignore unsupported drag data operations.
        }
      }
      this.clearHotbarDragIndicators();
      this.activeHotbarDrag = null;
      if (fromIndex === null || targetIndex === null) {
        return;
      }
      this.swapHotbarSlots(fromIndex, targetIndex);
    }

    handleHotbarDragEnd() {
      this.clearHotbarDragIndicators();
      this.activeHotbarDrag = null;
    }

    isTouchLikePointerEvent(event) {
      const pointerType = event?.pointerType;
      if (pointerType === 'touch' || pointerType === 'pen') {
        return true;
      }
      if (!pointerType && this.isTouchPreferred) {
        return true;
      }
      return false;
    }

    isActiveHotbarPointer(event) {
      if (!this.activeHotbarPointerDrag) return false;
      const { pointerId } = this.activeHotbarPointerDrag;
      if (pointerId === null || pointerId === undefined) {
        return true;
      }
      return pointerId === event?.pointerId;
    }

    handleHotbarPointerDown(event) {
      if (!this.isTouchLikePointerEvent(event)) {
        return;
      }
      const button = event.currentTarget;
      const index = this.getHotbarSlotIndexFromElement(button);
      if (index === null) {
        return;
      }
      const slot = this.hotbar[index];
      if (!slot?.item) {
        return;
      }
      this.clearHotbarDragIndicators();
      const pointerId = Number.isFinite(event.pointerId) ? event.pointerId : null;
      this.activeHotbarPointerDrag = { from: index, pointerId };
      button.classList.add('dragging');
      if (pointerId !== null && typeof button.setPointerCapture === 'function') {
        try {
          button.setPointerCapture(pointerId);
        } catch (error) {
          // Ignore pointer capture failures on unsupported elements/browsers.
        }
      }
    }

    handleHotbarPointerEnter(event) {
      if (!this.isTouchLikePointerEvent(event)) {
        return;
      }
      if (!this.isActiveHotbarPointer(event)) {
        return;
      }
      event.currentTarget.classList.add('drag-over');
    }

    handleHotbarPointerLeave(event) {
      if (!this.isActiveHotbarPointer(event)) {
        return;
      }
      event.currentTarget.classList.remove('drag-over');
    }

    handleHotbarPointerUp(event) {
      if (!this.isActiveHotbarPointer(event)) {
        return;
      }
      const pointerId = this.activeHotbarPointerDrag?.pointerId ?? null;
      const fromIndex = this.activeHotbarPointerDrag?.from ?? null;
      this.activeHotbarPointerDrag = null;
      this.clearHotbarDragIndicators();
      const button = event.currentTarget;
      if (pointerId !== null && typeof button.releasePointerCapture === 'function') {
        try {
          button.releasePointerCapture(pointerId);
        } catch (error) {
          // Ignore pointer capture release failures.
        }
      }
      const targetIndex = this.getHotbarSlotIndexFromElement(button);
      if (fromIndex === null || targetIndex === null || fromIndex === targetIndex) {
        return;
      }
      const swapped = this.swapHotbarSlots(fromIndex, targetIndex);
      if (swapped) {
        this.ignoreNextHotbarClick = true;
      }
    }

    handleHotbarPointerCancel(event) {
      if (!this.isActiveHotbarPointer(event)) {
        return;
      }
      const pointerId = this.activeHotbarPointerDrag?.pointerId ?? null;
      this.activeHotbarPointerDrag = null;
      this.clearHotbarDragIndicators();
      const button = event.currentTarget;
      if (pointerId !== null && typeof button.releasePointerCapture === 'function') {
        try {
          button.releasePointerCapture(pointerId);
        } catch (error) {
          // Ignore pointer capture release failures.
        }
      }
    }

    getCombinedInventoryEntries() {
      const aggregate = new Map();
      this.hotbar.forEach((slot) => {
        if (!slot?.item || slot.quantity <= 0) return;
        aggregate.set(slot.item, (aggregate.get(slot.item) ?? 0) + slot.quantity);
      });
      this.satchel.forEach((quantity, item) => {
        if (!quantity) return;
        aggregate.set(item, (aggregate.get(item) ?? 0) + quantity);
      });
      return Array.from(aggregate.entries()).map(([item, quantity]) => ({ item, quantity }));
    }

    isTextureUnavailable(key) {
      if (!key) {
        return false;
      }
      const set = this.textureFallbackMissingKeys;
      if (!set || typeof set.has !== 'function') {
        return false;
      }
      return set.has(key);
    }

    isMaterialUnavailable(key) {
      if (!key) {
        return false;
      }
      const materials = this.materials || {};
      return !materials[key];
    }

    getItemVisualStatus(itemId) {
      const def = getItemDefinition(itemId);
      const textureKeys = normaliseVisualKeyList(def.textureKeys || def.textureKey);
      const materialKeys = normaliseVisualKeyList(def.materialKeys || def.materialKey);
      const missingTextures = textureKeys.filter((key) => this.isTextureUnavailable(key));
      const missingMaterials = materialKeys.filter((key) => this.isMaterialUnavailable(key));
      return {
        missing: missingTextures.length > 0 || missingMaterials.length > 0,
        missingTextures,
        missingMaterials,
      };
    }

    describeItemVisualStatus(itemId, status = null) {
      const visualStatus = status || this.getItemVisualStatus(itemId);
      if (!visualStatus || visualStatus.missing !== true) {
        return '';
      }
      const parts = [];
      if (Array.isArray(visualStatus.missingTextures) && visualStatus.missingTextures.length) {
        const label = visualStatus.missingTextures.length > 1 ? 'textures' : 'texture';
        parts.push(`${label}: ${visualStatus.missingTextures.join(', ')}`);
      }
      if (Array.isArray(visualStatus.missingMaterials) && visualStatus.missingMaterials.length) {
        const label = visualStatus.missingMaterials.length > 1 ? 'materials' : 'material';
        parts.push(`${label}: ${visualStatus.missingMaterials.join(', ')}`);
      }
      const summary = parts.join(' • ');
      return summary ? `Missing ${summary}` : 'Missing visuals';
    }

    getRecipeVisualStatus(recipe, key) {
      const parts = this.getRecipeSequence(recipe, key);
      const missingIngredients = [];
      parts.forEach((itemId) => {
        const status = this.getItemVisualStatus(itemId);
        if (status.missing) {
          missingIngredients.push({ itemId, status });
        }
      });
      const outputStatus = recipe?.id ? this.getItemVisualStatus(recipe.id) : { missing: false };
      return {
        missing: outputStatus.missing || missingIngredients.length > 0,
        outputStatus,
        missingIngredients,
      };
    }

    describeRecipeVisualStatus(recipe, key, status = null) {
      const visualStatus = status || this.getRecipeVisualStatus(recipe, key);
      if (!visualStatus || !visualStatus.missing) {
        return '';
      }
      const parts = [];
      if (visualStatus.outputStatus?.missing && recipe?.id) {
        const outputLabel = getItemDefinition(recipe.id).label;
        const summary = this.describeItemVisualStatus(recipe.id, visualStatus.outputStatus);
        parts.push(summary ? `${outputLabel} — ${summary}` : `Missing visuals for ${outputLabel}`);
      }
      visualStatus.missingIngredients.forEach(({ itemId, status: ingredientStatus }) => {
        const ingredientLabel = getItemDefinition(itemId).label;
        const summary = this.describeItemVisualStatus(itemId, ingredientStatus);
        parts.push(summary ? `${ingredientLabel} — ${summary}` : `Missing visuals for ${ingredientLabel}`);
      });
      const summary = parts.filter(Boolean).join(' • ');
      return summary || 'Missing visuals';
    }

    updateCraftingInventoryUi() {
      if (!this.craftingInventoryEl) return;
      const fragment = document.createDocumentFragment();
      const items = this.getCombinedInventoryEntries();
      items.sort((a, b) => b.quantity - a.quantity);
      items.forEach(({ item, quantity }) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'crafting-inventory__item';
        button.dataset.itemId = item;
        button.dataset.quantity = String(quantity);
        const label = formatInventoryLabel(item, quantity);
        const visualStatus = this.getItemVisualStatus(item);
        const visualSummary = this.describeItemVisualStatus(item, visualStatus);
        const summaryMarkup =
          visualStatus.missing === true
            ? `<span class="visual-warning">${escapeHtml(visualSummary || 'Missing visuals')}</span>`
            : '';
        button.innerHTML = `${escapeHtml(label)}${summaryMarkup}`;
        button.dataset.visual = visualStatus.missing ? 'missing' : 'ready';
        if (visualSummary) {
          button.dataset.visualSummary = visualSummary;
        } else {
          delete button.dataset.visualSummary;
        }
        button.setAttribute('role', 'listitem');
        button.setAttribute(
          'aria-label',
          visualSummary ? `${label}. ${visualSummary}.` : label,
        );
        const def = getItemDefinition(item);
        const hintParts = [];
        if (def.description) {
          hintParts.push(def.description);
        }
        if (visualSummary) {
          hintParts.push(visualSummary);
        }
        hintParts.push(`Tap to queue • Carrying ×${quantity}`);
        button.setAttribute('data-hint', hintParts.join(' — '));
        fragment.appendChild(button);
      });
      this.craftingInventoryEl.innerHTML = '';
      this.craftingInventoryEl.appendChild(fragment);
    }

    updateInventoryModal() {
      if (!this.inventoryGridEl) return;
      const items = this.getCombinedInventoryEntries();
      items.sort((a, b) => a.item.localeCompare(b.item));
      this.inventoryGridEl.innerHTML = '';
      if (!items.length) {
        this.inventoryGridEl.textContent = 'Inventory empty — gather resources to craft.';
        return;
      }
      items.forEach(({ item, quantity }) => {
        const cell = document.createElement('div');
        cell.className = 'inventory-grid__cell';
        const label = formatInventoryLabel(item, quantity);
        const visualStatus = this.getItemVisualStatus(item);
        const visualSummary = this.describeItemVisualStatus(item, visualStatus);
        const summaryMarkup =
          visualStatus.missing === true
            ? `<span class="visual-warning">${escapeHtml(visualSummary || 'Missing visuals')}</span>`
            : '';
        cell.innerHTML = `<span>${escapeHtml(label)}</span>${summaryMarkup}`;
        cell.dataset.visual = visualStatus.missing ? 'missing' : 'ready';
        if (visualSummary) {
          cell.dataset.visualSummary = visualSummary;
        } else {
          delete cell.dataset.visualSummary;
        }
        cell.setAttribute('aria-label', visualSummary ? `${label}. ${visualSummary}.` : label);
        this.inventoryGridEl.appendChild(cell);
      });
      if (this.inventoryOverflowEl) {
        const satchelOnly = Array.from(this.satchel.entries()).reduce((sum, [, value]) => sum + value, 0);
        if (satchelOnly > 0) {
          this.inventoryOverflowEl.hidden = false;
          this.inventoryOverflowEl.textContent = `${satchelOnly} items stored in satchel reserves.`;
        } else {
          this.inventoryOverflowEl.hidden = true;
          this.inventoryOverflowEl.textContent = '';
        }
      }
    }

    updateExtendedInventoryUi() {
      if (!this.extendedInventoryEl) return;
      const items = this.getCombinedInventoryEntries();
      items.sort((a, b) => a.item.localeCompare(b.item));
      const fragment = document.createDocumentFragment();
      if (!items.length) {
        const empty = document.createElement('p');
        empty.className = 'inventory-extended__empty';
        empty.textContent = 'Gather resources to populate your satchel.';
        fragment.appendChild(empty);
      } else {
        items.forEach(({ item, quantity }) => {
          const def = getItemDefinition(item);
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'inventory-slot';
          button.dataset.itemId = item;
          button.dataset.quantity = String(quantity);
          const visualStatus = this.getItemVisualStatus(item);
          const visualSummary = this.describeItemVisualStatus(item, visualStatus);
          const summaryMarkup =
            visualStatus.missing === true
              ? `<span class="visual-warning">${escapeHtml(visualSummary || 'Missing visuals')}</span>`
              : '';
          button.innerHTML = `<span>${escapeHtml(def.label)}</span><span class="quantity">×${quantity}</span>${summaryMarkup}`;
          button.dataset.visual = visualStatus.missing ? 'missing' : 'ready';
          if (visualSummary) {
            button.dataset.visualSummary = visualSummary;
          } else {
            delete button.dataset.visualSummary;
          }
          const ariaLabel = `${def.label} ×${quantity}`;
          button.setAttribute('aria-label', visualSummary ? `${ariaLabel}. ${visualSummary}.` : ariaLabel);
          const hintParts = [];
          if (def.description) {
            hintParts.push(def.description);
          }
          if (visualSummary) {
            hintParts.push(visualSummary);
          }
          hintParts.push(`Tap to queue • Stored ×${quantity}`);
          button.setAttribute('data-hint', hintParts.join(' — '));
          fragment.appendChild(button);
        });
      }
      this.extendedInventoryEl.innerHTML = '';
      this.extendedInventoryEl.appendChild(fragment);
    }

    updateHotbarExpansionUi() {
      const expanded = this.hotbarExpanded === true;
      if (this.extendedInventoryEl) {
        this.extendedInventoryEl.dataset.visible = expanded ? 'true' : 'false';
        setElementHidden(this.extendedInventoryEl, !expanded);
      }
      if (this.hotbarExpandButton) {
        this.hotbarExpandButton.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        if (this.hotbarExpandButton.tagName === 'BUTTON') {
          this.hotbarExpandButton.textContent = expanded ? 'Collapse Inventory' : 'Expand Inventory';
        }
      }
    }

    toggleHotbarExpansion(forceValue) {
      const next = typeof forceValue === 'boolean' ? forceValue : !this.hotbarExpanded;
      if (this.hotbarExpanded === next) {
        this.updateHotbarExpansionUi();
        return this.hotbarExpanded;
      }
      this.hotbarExpanded = next;
      this.updateHotbarExpansionUi();
      return this.hotbarExpanded;
    }

    selectHotbarSlot(index, announce = true) {
      if (!Number.isInteger(index) || index < 0 || index >= this.hotbar.length) {
        return;
      }
      this.selectedHotbarIndex = index;
      this.updateHotbarUi();
      this.refreshEquippedItem();
      if (announce) {
        const slot = this.hotbar[index];
        const label = slot?.item ? formatInventoryLabel(slot.item, slot.quantity) : 'Empty slot';
        this.showHint(`Selected ${label}`);
      }
    }

    cycleHotbar(direction) {
      const next = (this.selectedHotbarIndex + direction + this.hotbar.length) % this.hotbar.length;
      this.selectHotbarSlot(next, true);
    }

    showHint(message) {
      if (!this.playerHintEl || !message) return;
      this.playerHintEl.textContent = message;
      this.playerHintEl.classList.add('visible');
      this.playerHintEl.removeAttribute('data-variant');
      this.lastHintMessage = message;
      this.pointerLockFallbackMessageActive = false;
      this.pointerLockFallbackNoticeShown = false;
      this.updateFooterSummary();
    }

    handleEventDispatchError(context, error) {
      const label = context || 'processing the last input';
      const dedupeKey = `${label}|${error?.message ?? 'unknown'}`;
      if (this.eventFailureNotices.has(dedupeKey)) {
        return;
      }
      this.eventFailureNotices.add(dedupeKey);
      if (typeof console !== 'undefined') {
        console.error(`Event handler failed while ${label}.`, error);
      }
      this.presentRendererFailure(
        `Critical input error detected while ${label}. Reload the page to continue exploring.`,
        { error, stage: `event:${label}` }
      );
    }

    noteEventBindingFailure(details = {}) {
      const {
        targetLabel = 'unknown',
        eventName = 'unknown',
        contextLabel = null,
        reason = 'unknown',
        handlerLabel = null,
        error = null,
        meta = null,
      } = details;
      const timestamp = Date.now();
      const failureRecord = {
        targetLabel,
        eventName,
        contextLabel,
        reason,
        handler: handlerLabel,
        errorMessage: error?.message ?? null,
        errorStack: typeof error?.stack === 'string' ? error.stack : null,
        meta: meta || null,
        timestamp,
      };
      if (!Array.isArray(this.eventBindingFailures)) {
        this.eventBindingFailures = [];
      }
      this.eventBindingFailures.push(failureRecord);
      if (!(this.eventBindingFailureNotices instanceof Set)) {
        this.eventBindingFailureNotices = new Set();
      }
      const dedupeKey = `${targetLabel}|${eventName}|${contextLabel || ''}|${reason}`;
      if (this.eventBindingFailureNotices.has(dedupeKey)) {
        return;
      }
      this.eventBindingFailureNotices.add(dedupeKey);
      if (typeof console !== 'undefined' && typeof console.error === 'function') {
        const summaryParts = [`Failed to bind ${eventName}`];
        if (targetLabel && targetLabel !== 'unknown') {
          summaryParts.push(`listener to ${targetLabel}`);
        } else {
          summaryParts.push('listener');
        }
        if (contextLabel) {
          summaryParts.push(`while ${contextLabel}`);
        }
        const message = `[SimpleExperience] ${summaryParts.join(' ')}: ${reason}.`;
        const logDetails = {
          target: targetLabel,
          event: eventName,
          reason,
        };
        if (contextLabel) {
          logDetails.context = contextLabel;
        }
        if (handlerLabel) {
          logDetails.handler = handlerLabel;
        }
        if (meta) {
          logDetails.meta = meta;
        }
        if (error) {
          logDetails.error = error;
        }
        console.error(message, logDetails);
      }
    }

    addSafeEventListener(target, eventName, handler, options = {}) {
      const { context = null, eventOptions = undefined } = options;
      const normalizedEventName = typeof eventName === 'string' ? eventName : '';
      const contextLabel = context || (normalizedEventName ? `handling ${normalizedEventName}` : 'handling event');
      const targetLabel = this.describeEventTarget(target);
      const handlerLabel = typeof handler === 'function' && handler.name ? handler.name : null;

      if (!normalizedEventName) {
        this.noteEventBindingFailure({
          targetLabel,
          eventName: normalizedEventName || 'unknown',
          contextLabel,
          reason: 'invalid-event',
          handlerLabel,
        });
        return false;
      }

      if (typeof handler !== 'function') {
        this.noteEventBindingFailure({
          targetLabel,
          eventName: normalizedEventName,
          contextLabel,
          reason: 'invalid-handler',
          meta: { handlerType: typeof handler },
        });
        return false;
      }

      if (!target) {
        this.noteEventBindingFailure({
          targetLabel,
          eventName: normalizedEventName,
          contextLabel,
          reason: 'missing-target',
          handlerLabel,
        });
        return false;
      }

      if (typeof target.addEventListener !== 'function') {
        this.noteEventBindingFailure({
          targetLabel,
          eventName: normalizedEventName,
          contextLabel,
          reason: 'invalid-target',
          handlerLabel,
          meta: { targetType: typeof target },
        });
        return false;
      }

      const safeHandler = (...args) => {
        try {
          handler(...args);
        } catch (error) {
          this.handleEventDispatchError(contextLabel, error);
        }
      };

      try {
        target.addEventListener(normalizedEventName, safeHandler, eventOptions);
      } catch (bindError) {
        this.noteEventBindingFailure({
          targetLabel,
          eventName: normalizedEventName,
          contextLabel,
          reason: 'bind-error',
          handlerLabel,
          error: bindError,
        });
        return false;
      }

      if (!Array.isArray(this.boundEventRecords)) {
        this.boundEventRecords = [];
      }
      this.boundEventRecords.push({
        targetLabel,
        eventName: normalizedEventName,
        contextLabel,
      });
      if (!Array.isArray(this.boundEventDisposers)) {
        this.boundEventDisposers = [];
      }
      this.boundEventDisposers.push(() => {
        if (typeof target.removeEventListener === 'function') {
          try {
            target.removeEventListener(normalizedEventName, safeHandler, eventOptions);
          } catch (removeError) {
            if (typeof console !== 'undefined') {
              console.debug('Failed to remove event listener cleanly.', {
                event: normalizedEventName,
                removeError,
              });
            }
          }
        }
      });

      return true;
    }

    describeEventTarget(target) {
      if (!target) {
        return 'unknown';
      }
      const scopeWindow = typeof window !== 'undefined' ? window : null;
      if (scopeWindow && target === scopeWindow) {
        return 'window';
      }
      const scopeDocument = typeof document !== 'undefined' ? document : null;
      if (scopeDocument && target === scopeDocument) {
        return 'document';
      }
      if (this.canvas && target === this.canvas) {
        return 'canvas';
      }
      if (typeof target.nodeName === 'string' && target.nodeName) {
        return target.nodeName.toLowerCase();
      }
      if (typeof target.constructor?.name === 'string' && target.constructor.name) {
        return target.constructor.name;
      }
      return 'unknown';
    }

    handleAssetLoadFailure(key, error, options = {}) {
      const summary = this.buildAssetDebugSummary(key);
      if (error && typeof console !== 'undefined') {
        console.error(`Asset load failure for ${key || 'unknown asset'}.`, error);
      }
      if (key === 'steve') {
        this.ensurePlayerAvatarPlaceholder('failed');
      } else if (key === 'arm') {
        this.ensurePlayerArmsVisible();
      }
      const messageMap = {
        arm: 'First-person hands offline — showing simplified explorer arms.',
        steve: 'Explorer avatar unavailable — using the fallback rig until models return.',
        zombie: 'Hostile models offline — zombies now appear as simplified husks.',
        golem: 'Iron golems using simplified armour while detailed models load.',
        chest: 'Treasure chests using simplified casings while detailed models load.',
      };
      let fallbackMessage = (options.fallbackMessage || messageMap[key] || '').trim();
      const missingLabel = summary.primarySourceLabel || summary.fileName || summary.primarySource || null;
      if (!fallbackMessage) {
        const friendly = summary.friendlyName || this.describeAssetKey(key);
        fallbackMessage = friendly
          ? `${friendly.charAt(0).toUpperCase()}${friendly.slice(1)} failed to load.`
          : 'Critical assets failed to load.';
      }
      const ensurePlaceholderExplanation = (message) => {
        const trimmed = (message || '').trim();
        if (!trimmed) {
          return 'Placeholder visuals active until assets recover.';
        }
        if (/[Pp]laceholder/.test(trimmed) || /simplified/.test(trimmed) || /fallback/.test(trimmed)) {
          return trimmed;
        }
        if (trimmed.endsWith('.')) {
          return `${trimmed} Placeholder visuals active until assets recover.`;
        }
        return `${trimmed} — placeholder visuals active until assets recover.`;
      };
      if (missingLabel && !fallbackMessage.includes(missingLabel)) {
        fallbackMessage = `${fallbackMessage} (Missing: ${missingLabel})`;
      }
      fallbackMessage = ensurePlaceholderExplanation(fallbackMessage);
      this.recordMajorIssue(fallbackMessage, { scope: 'assets', code: typeof key === 'string' && key ? key : null });
      this.recordAssetFailure(key, { error, fallbackMessage, assetSummary: summary });
      if (!fallbackMessage) {
        return;
      }
      const dedupeKey = `${key || 'asset'}|${fallbackMessage}`;
      if (this.assetFailureNotices.has(dedupeKey)) {
        return;
      }
      this.assetFailureNotices.add(dedupeKey);
      if (this.playerHintEl) {
        this.playerHintEl.textContent = fallbackMessage;
        this.playerHintEl.classList.add('visible');
        this.playerHintEl.setAttribute('data-variant', 'warning');
      }
      this.lastHintMessage = fallbackMessage;
      if (this.footerStatusEl) {
        this.footerStatusEl.textContent = fallbackMessage;
      }
      if (this.footerEl) {
        this.footerEl.dataset.state = 'warning';
      }
      this.emitGameEvent('asset-fallback', {
        key,
        message: fallbackMessage,
        failureCount: this.assetFailureCounts.get(typeof key === 'string' && key ? key : 'asset') || 1,
      });
      if (this.enforceAssetPreloadStrictness && !this.criticalAssetPreloadFailed) {
        const friendly = this.describeAssetKey(key);
        const message =
          (fallbackMessage || '').trim() ||
          (friendly ? `Critical asset ${friendly} failed to load. Reload to try again.` : 'Critical assets failed to load. Reload to try again.');
        this.abortDueToAssetFailure(message, {
          stage: 'asset-load',
          error: error || null,
          key: typeof key === 'string' && key ? key : 'asset',
        });
      }
    }

    noteAssetRetry(key, attemptNumber, error, url, delayMs) {
      const friendlyName = this.describeAssetKey(key);
      const nextAttempt = Math.min(this.assetRetryLimit, attemptNumber + 1);
      const resolvedDelay = Number.isFinite(delayMs) ? Math.max(0, Math.floor(delayMs)) : this.computeAssetRetryDelay(attemptNumber);
      const delaySeconds = Number.isFinite(resolvedDelay) ? Math.max(0, Math.round(resolvedDelay / 1000)) : null;
      const delaySuffix = delaySeconds
        ? ` in ${delaySeconds} second${delaySeconds === 1 ? '' : 's'}`
        : '';
      if (typeof console !== 'undefined') {
        console.warn(
          `Retrying ${friendlyName} asset (attempt ${nextAttempt} of ${this.assetRetryLimit}) after a loading error${delaySuffix}.`,
          {
            key,
            attempt: attemptNumber,
            nextAttempt,
            url,
            delayMs: resolvedDelay,
            error,
          },
        );
      }
      this.emitGameEvent('asset-retry-scheduled', {
        key,
        attempt: nextAttempt,
        previousAttempt: attemptNumber,
        limit: this.assetRetryLimit,
        url,
        delayMs: resolvedDelay,
        errorMessage: error?.message ?? null,
        kind: 'models',
      });
    }

    computeAssetRetryDelay(attemptNumber) {
      const exponent = Math.max(0, attemptNumber - 1);
      const multiplier = Math.pow(1.8, exponent);
      const delay = Math.round(this.assetRetryBackoffMs * multiplier);
      return Math.min(this.assetRetryBackoffMaxMs, Math.max(this.assetRetryBackoffMs, delay));
    }

    delay(ms) {
      const duration = Math.max(0, Number.isFinite(ms) ? Math.floor(ms) : 0);
      return new Promise((resolve) => {
        setTimeout(resolve, duration);
      });
    }

    recordAssetFailure(key, context = {}) {
      const normalisedKey = typeof key === 'string' && key.trim().length ? key : 'asset';
      const previous = this.assetFailureCounts.get(normalisedKey) || 0;
      const next = previous + 1;
      this.assetFailureCounts.set(normalisedKey, next);
      const summary =
        context?.assetSummary && typeof context.assetSummary === 'object'
          ? context.assetSummary
          : this.buildAssetDebugSummary(normalisedKey);
      const detail = {
        key: normalisedKey,
        failureCount: next,
        fallbackMessage: context?.fallbackMessage || null,
        errorMessage: context?.error?.message ?? null,
        assetLabel: summary?.debugLabel ?? null,
        assetFriendlyName: summary?.friendlyName ?? null,
        assetFileName: summary?.fileName ?? null,
        assetExtension: summary?.extension ?? null,
        assetSource: summary?.primarySource ?? null,
        assetSourceLabel: summary?.primarySourceLabel ?? null,
        assetSources: Array.isArray(summary?.sources) ? summary.sources.slice(0, 10) : [],
        timestamp: Date.now(),
      };
      this.emitGameEvent('asset-load-failure', detail);
      if (typeof this.markGameplayInstability === 'function') {
        this.markGameplayInstability('asset-failure');
      }
      if (next >= this.assetRecoveryPromptThreshold) {
        this.assetRecoveryPendingKeys.add(normalisedKey);
        this.promptAssetRecovery();
      }
    }

    describeAssetKey(key) {
      const normalisedKey = typeof key === 'string' && key.trim().length ? key : 'asset';
      if (normalisedKey.startsWith('texture:')) {
        const textureKey = normalisedKey.slice('texture:'.length);
        const label = this.describeVoxelTextureKey(textureKey);
        return `${label} textures`;
      }
      const mapping = {
        arm: 'first-person hands',
        steve: 'explorer avatar',
        zombie: 'zombie models',
        golem: 'golem armour',
        asset: 'critical assets',
      };
      return mapping[normalisedKey] || `${normalisedKey} assets`;
    }

    resolveAssetSourceCandidates(key) {
      if (typeof key !== 'string' || !key.trim()) {
        return [];
      }
      const normalised = key.trim();
      if (normalised.startsWith('texture:')) {
        const textureKey = normalised.slice('texture:'.length);
        const sources = this.getExternalTextureSources(textureKey) || [];
        if (sources.length) {
          return sources;
        }
        return [`${textureKey}.png`];
      }
      const url = MODEL_URLS[normalised];
      if (typeof url === 'string' && url.trim()) {
        return [url.trim()];
      }
      return [];
    }

    extractAssetSourceMetadata(source) {
      if (typeof source !== 'string') {
        return null;
      }
      const trimmed = source.trim();
      if (!trimmed) {
        return null;
      }
      if (/^data:/i.test(trimmed)) {
        const mimeMatch = trimmed.match(/^data:([^;,]+)/i);
        const mime = mimeMatch ? mimeMatch[1] : null;
        const subtype = mime && mime.includes('/') ? mime.split('/').pop() : null;
        const extension = subtype ? subtype.split('+')[0].toLowerCase() : null;
        const label = mime ? `data URI (${mime})` : 'data URI';
        return {
          source: trimmed,
          fileName: null,
          extension,
          label,
        };
      }
      let pathname = trimmed;
      try {
        const parsed = new URL(trimmed, typeof window !== 'undefined' ? window.location?.href : undefined);
        pathname = parsed.pathname || trimmed;
      } catch (error) {
        const queryIndex = pathname.indexOf('?');
        if (queryIndex >= 0) {
          pathname = pathname.slice(0, queryIndex);
        }
        const hashIndex = pathname.indexOf('#');
        if (hashIndex >= 0) {
          pathname = pathname.slice(0, hashIndex);
        }
      }
      const segments = pathname.split('/').filter(Boolean);
      const fileName = segments.length ? segments[segments.length - 1] : null;
      let extension = null;
      if (fileName && fileName.includes('.')) {
        extension = fileName.split('.').pop().toLowerCase();
      }
      const label = fileName || trimmed;
      return {
        source: trimmed,
        fileName: fileName || null,
        extension,
        label,
      };
    }

    buildAssetDebugSummary(key) {
      const normalised = typeof key === 'string' && key.trim().length ? key.trim() : 'asset';
      const friendlyName = this.describeAssetKey(normalised);
      const candidates = this.resolveAssetSourceCandidates(normalised);
      const primary = candidates.length ? candidates[0] : null;
      const metadata = primary ? this.extractAssetSourceMetadata(primary) : null;
      let fileName = metadata?.fileName || null;
      let extension = metadata?.extension || null;
      if (!fileName && normalised.startsWith('texture:')) {
        const textureKey = normalised.slice('texture:'.length);
        fileName = `${textureKey}.png`;
      }
      if (!extension && fileName && fileName.includes('.')) {
        extension = fileName.split('.').pop().toLowerCase();
      }
      const debugLabel = metadata?.label
        ? `${friendlyName} (${metadata.label})`
        : fileName
          ? `${friendlyName} (${fileName})`
          : friendlyName;
      return {
        key: normalised,
        friendlyName,
        sources: candidates.slice(),
        primarySource: primary,
        primarySourceLabel: metadata?.label || (fileName ? fileName : null),
        fileName,
        extension,
        debugLabel,
      };
    }

    formatAssetSourceSummaryList(summaries = []) {
      const labels = [];
      summaries.forEach((entry) => {
        const label =
          (typeof entry?.primarySourceLabel === 'string' && entry.primarySourceLabel.trim()) ||
          (typeof entry?.fileName === 'string' && entry.fileName.trim());
        if (label && !labels.includes(label)) {
          labels.push(label);
        }
      });
      if (!labels.length) {
        return '';
      }
      if (labels.length === 1) {
        return labels[0];
      }
      if (labels.length === 2) {
        return `${labels[0]} and ${labels[1]}`;
      }
      const head = labels.slice(0, -1).join(', ');
      return `${head}, and ${labels[labels.length - 1]}`;
    }

    buildAssetDelayIndicator(key, context = {}) {
      const normalisedKey = typeof key === 'string' && key.trim().length ? key.trim() : 'asset';
      const label = this.describeAssetKey(normalisedKey);
      const capitalised = label.charAt(0).toUpperCase() + label.slice(1);
      const delayMs = Number.isFinite(context.delayMs)
        ? Math.max(0, context.delayMs)
        : this.assetDelayIndicatorThresholdMs;
      const assetKind = context.kind || 'asset';
      return {
        key: normalisedKey,
        label,
        title: `Loading ${capitalised}`,
        message: `Loading the ${label} — placeholder assets are active until streaming completes.`,
        hint: `Loading the ${label} — placeholder assets are active until streaming completes.`,
        delayMs,
        assetKind,
      };
    }

    buildAssetRecoveryMessage(precomputedSummaries = null) {
      if (!this.assetRecoveryPendingKeys.size) {
        return 'Critical assets failed to load after multiple attempts. Reload the page or retry the stream to continue.';
      }
      const summaries = Array.isArray(precomputedSummaries)
        ? precomputedSummaries
        : Array.from(this.assetRecoveryPendingKeys).map((key) => this.buildAssetDebugSummary(key));
      const friendlyNames = summaries.map((entry) => entry.friendlyName);
      let label = friendlyNames[0] || 'critical assets';
      if (friendlyNames.length === 2) {
        label = `${friendlyNames[0]} and ${friendlyNames[1]}`;
      } else if (friendlyNames.length > 2) {
        const initial = friendlyNames.slice(0, -1).join(', ');
        label = `${initial}, and ${friendlyNames[friendlyNames.length - 1]}`;
      }
      const capitalised = label.charAt(0).toUpperCase() + label.slice(1);
      let message = `${capitalised} failed to load after multiple attempts. Reload the page to rebuild caches or press “Retry Assets” to try again.`;
      const sourceSummary = this.formatAssetSourceSummaryList(summaries);
      if (sourceSummary) {
        message += ` Missing files: ${sourceSummary}.`;
      }
      return message;
    }

    updateAssetRecoveryPromptMessage(messageOverride = null) {
      const message = messageOverride || this.buildAssetRecoveryMessage();
      if (this.assetRecoveryTitleEl) {
        this.assetRecoveryTitleEl.textContent = 'Restore missing assets';
      }
      if (this.assetRecoveryMessageEl) {
        this.assetRecoveryMessageEl.textContent = message;
      }
      if (this.assetRecoveryActionsEl) {
        this.assetRecoveryActionsEl.hidden = false;
      }
    }

    showAssetRecoveryPrompt() {
      if (!this.assetRecoveryOverlayEl) {
        return;
      }
      this.updateAssetRecoveryPromptMessage();
      this.assetRecoveryOverlayEl.hidden = false;
      this.assetRecoveryOverlayEl.removeAttribute('hidden');
      setInertState(this.assetRecoveryOverlayEl, false);
      activateOverlayIsolation(this.assetRecoveryOverlayEl);
      this.assetRecoveryOverlayEl.setAttribute('data-mode', 'error');
      if (this.assetRecoveryDialogEl) {
        this.assetRecoveryDialogEl.setAttribute('aria-busy', 'false');
      }
      this.assetRecoveryPromptActive = true;
      if (typeof this.assetRecoveryDialogEl?.focus === 'function') {
        try {
          this.assetRecoveryDialogEl.focus();
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Unable to focus asset recovery dialog.', error);
          }
        }
      }
    }

    promptAssetRecovery() {
      const summaries = Array.from(this.assetRecoveryPendingKeys).map((key) => this.buildAssetDebugSummary(key));
      const message = this.buildAssetRecoveryMessage(summaries);
      if (this.assetRecoveryOverlayEl) {
        const eventDetail = {
          keys: Array.from(this.assetRecoveryPendingKeys),
          failureCounts: Array.from(this.assetFailureCounts.entries()),
          assetSummaries: summaries.map((entry) => ({
            key: entry.key,
            label: entry.friendlyName,
            source: entry.primarySource ?? null,
            sourceLabel: entry.primarySourceLabel ?? null,
            fileName: entry.fileName ?? null,
            extension: entry.extension ?? null,
          })),
          message,
        };
        if (this.assetRecoveryPromptActive) {
          this.emitGameEvent('asset-recovery-prompt-update', eventDetail);
        } else {
          this.emitGameEvent('asset-recovery-prompt', eventDetail);
        }
        this.showAssetRecoveryPrompt();
      } else {
        this.showHint(message);
      }
    }

    hideAssetRecoveryPrompt() {
      const wasActive = this.assetRecoveryPromptActive;
      if (!this.assetRecoveryOverlayEl) {
        this.assetRecoveryPromptActive = false;
        if (wasActive) {
          this.focusGameViewport();
        }
        return;
      }
      setInertState(this.assetRecoveryOverlayEl, true);
      releaseOverlayIsolation(this.assetRecoveryOverlayEl);
      this.assetRecoveryOverlayEl.setAttribute('hidden', '');
      this.assetRecoveryOverlayEl.hidden = true;
      this.assetRecoveryPromptActive = false;
      if (wasActive) {
        this.focusGameViewport();
      }
    }

    maybeHideAssetRecoveryPrompt() {
      if (!this.assetRecoveryPromptActive) {
        return;
      }
      if (this.assetRecoveryPendingKeys.size === 0) {
        this.hideAssetRecoveryPrompt();
      } else {
        this.updateAssetRecoveryPromptMessage();
      }
    }

    handleAssetRecoveryRetry() {
      const keys = Array.from(this.assetRecoveryPendingKeys);
      if (!keys.length) {
        this.hideAssetRecoveryPrompt();
        return;
      }
      this.emitGameEvent('asset-retry-requested', { keys, source: 'player' });
      this.retryFailedAssets(keys);
    }

    handleAssetRecoveryReload() {
      const keys = Array.from(this.assetRecoveryPendingKeys);
      this.emitGameEvent('asset-recovery-reload-requested', { keys, source: 'player' });
      const scope =
        (typeof window !== 'undefined' && window) ||
        (typeof globalThis !== 'undefined' && globalThis) ||
        null;
      if (scope?.location?.reload) {
        scope.location.reload();
        return;
      }
      this.hideAssetRecoveryPrompt();
      this.showHint('Reload the page to restore missing assets.');
    }

    bindAssetRecoveryControls() {
      if (this.assetRecoveryControlsBound) {
        return;
      }
      if (!this.assetRecoveryOverlayEl) {
        return;
      }
      if (this.assetRecoveryRetryButton) {
        this.addSafeEventListener(this.assetRecoveryRetryButton, 'click', this.onAssetRecoveryRetryClick, {
          context: 'retrying missing assets',
        });
      }
      if (this.assetRecoveryReloadButton) {
        this.addSafeEventListener(this.assetRecoveryReloadButton, 'click', this.onAssetRecoveryReloadClick, {
          context: 'reloading after asset failure',
        });
      }
      this.assetRecoveryControlsBound = true;
    }

    retryFailedAssets(keys = []) {
      const uniqueKeys = Array.from(
        new Set(
          keys
            .map((entry) => (typeof entry === 'string' ? entry.trim() : ''))
            .filter((entry) => entry.length > 0),
        ),
      );
      if (!uniqueKeys.length) {
        this.hideAssetRecoveryPrompt();
        return;
      }
      uniqueKeys.forEach((assetKey) => {
        this.assetFailureCounts.delete(assetKey);
        this.assetRecoveryPendingKeys.delete(assetKey);
        this.assetRetryState.delete(assetKey);
        this.clearAssetFailureNoticesForKey(assetKey);
        this.clearAssetDelayNoticesForKey(assetKey);
        this.loadedModels.delete(assetKey);
        this.modelPromises.delete(assetKey);
      });
      if (this.THREE?.Cache?.clear) {
        try {
          this.THREE.Cache.clear();
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Unable to clear Three.js cache during asset retry.', error);
          }
        }
      }
      this.hideAssetRecoveryPrompt();
      this.emitGameEvent('asset-retry-queued', { keys: uniqueKeys });
      this.showHint('Retrying asset stream — missing details will restore shortly.');
      if (uniqueKeys.includes('arm')) {
        this.loadFirstPersonArms(this.activeSessionId);
      }
      if (uniqueKeys.includes('steve')) {
        this.loadPlayerCharacter();
      }
      if (uniqueKeys.includes('zombie') && Array.isArray(this.zombies)) {
        this.zombies.forEach((zombie) => {
          if (zombie && zombie.placeholder !== false) {
            this.upgradeZombie(zombie);
          }
        });
      }
      if (uniqueKeys.includes('golem') && Array.isArray(this.golems)) {
        this.golems.forEach((golem) => {
          if (golem && golem.placeholder !== false) {
            this.upgradeGolem(golem);
          }
        });
      }
      this.enqueueLazyModelWarmup(uniqueKeys);
      this.maybeHideAssetRecoveryPrompt();
    }

    clearAssetFailureNoticesForKey(key) {
      if (!key || !this.assetFailureNotices) {
        return;
      }
      const prefix = `${key}|`;
      Array.from(this.assetFailureNotices).forEach((entry) => {
        if (entry.startsWith(prefix)) {
          this.assetFailureNotices.delete(entry);
        }
      });
    }

    handleHotbarClick(event) {
      if (this.ignoreNextHotbarClick) {
        this.ignoreNextHotbarClick = false;
        if (event?.preventDefault) {
          event.preventDefault();
        }
        return;
      }
      const button = event.target.closest('[data-hotbar-slot]');
      if (!button) return;
      const index = Number.parseInt(button.dataset.hotbarSlot ?? '-1', 10);
      if (!Number.isInteger(index)) return;
      this.selectHotbarSlot(index, true);
    }

    handleCanvasWheel(event) {
      if (!this.pointerLocked) return;
      event.preventDefault();
      const delta = event.deltaY > 0 ? 1 : -1;
      this.cycleHotbar(delta);
    }

    handleVictoryReplay(event) {
      const button = event?.target?.closest('[data-action="replay-run"]');
      if (!button) {
        return;
      }
      if (event?.preventDefault) {
        event.preventDefault();
      }
      if (typeof window !== 'undefined' && typeof window.location?.reload === 'function') {
        window.location.reload();
      }
    }

    queueCraftingItem(item) {
      if (!item) return false;
      const slotCount = this.getCraftingSlotCount();
      if (this.craftingState.sequence.length >= slotCount) {
        this.showHint('Sequence full — craft or clear to add more.');
        return false;
      }
      const available = this.getInventoryCountForItem(item);
      const planned = this.craftingState.sequence.filter((entry) => entry === item).length;
      if (planned >= available) {
        this.showHint('Not enough resources in your satchel. Gather more.');
        return false;
      }
      this.craftingState.sequence.push(item);
      this.refreshCraftingUi();
      return true;
    }

    handleCraftingInventoryClick(event) {
      const button = event.target.closest('[data-item-id]');
      if (!button) return;
      const item = button.dataset.itemId;
      if (!item) return;
      this.queueCraftingItem(item);
    }

    handleCraftingInventoryFocus(event) {
      const button = event.target.closest('[data-item-id]');
      if (!button) {
        return;
      }
      const item = button.dataset.itemId;
      if (!item) {
        return;
      }
      const quantity = Number.parseInt(button.dataset.quantity ?? '0', 10);
      const def = getItemDefinition(item);
      const recipes = this.getRecipesUsingItem(item);
      const matches = recipes.length
        ? recipes.slice(0, 3).map((entry) => {
            const sequenceText = this.formatRecipeSequence(entry.parts);
            const summary = this.formatRecipeStepSummary(entry.positions, entry.parts.length);
            const detail = summary ? `${summary}, +${entry.recipe.score} pts` : `+${entry.recipe.score} pts`;
            return `${entry.recipe.label} — ${sequenceText} (${detail})`;
          })
        : ['Experiment with this resource to discover new recipes.'];
      let description = def.description || def.label;
      if (quantity > 0) {
        description += ` — You carry ×${quantity}.`;
      }
      description += ' Tap to queue it into the crafting sequence.';
      this.showCraftingHelperHint('inventory', {
        title: def.label,
        description,
        matches,
      });
    }

    handleCraftingInventoryBlur(event) {
      if (event?.relatedTarget && event.currentTarget?.contains?.(event.relatedTarget)) {
        return;
      }
      this.clearCraftingHelperHint('inventory');
    }

    handleExtendedInventoryClick(event) {
      const button = event.target.closest('[data-item-id]');
      if (!button) return;
      const item = button.dataset.itemId;
      if (!item) return;
      this.queueCraftingItem(item);
    }

    handleCraftSuggestionFocus(event) {
      const button = event.target.closest('[data-recipe-key]');
      if (!button) {
        return;
      }
      const key = button.dataset.recipeKey;
      if (!key) {
        return;
      }
      const recipe = this.craftingRecipes.get(key);
      if (!recipe) {
        return;
      }
      const parts = this.getRecipeSequence(recipe, key);
      const descriptionSegments = [];
      if (recipe.description) {
        descriptionSegments.push(recipe.description);
      }
      const eligibility = this.computeRecipeEligibility(recipe, key);
      const eligibilitySummary = this.describeRecipeEligibility(eligibility);
      if (eligibilitySummary) {
        descriptionSegments.push(eligibilitySummary);
      }
      descriptionSegments.push(`Autofill to award +${recipe.score} pts.`);
      this.showCraftingHelperHint('recipe', {
        title: recipe.label,
        description: descriptionSegments.join(' '),
        matches: [`Sequence: ${this.formatRecipeSequence(parts)}`, `Reward: +${recipe.score} pts`],
      });
    }

    handleCraftSuggestionBlur(event) {
      if (event?.relatedTarget && event.currentTarget?.contains?.(event.relatedTarget)) {
        return;
      }
      this.clearCraftingHelperHint('recipe');
    }

    handleCraftSequenceClick(event) {
      const button = event.target.closest('[data-sequence-index]');
      if (!button) return;
      const index = Number.parseInt(button.dataset.sequenceIndex ?? '-1', 10);
      if (!Number.isInteger(index) || index < 0 || index >= this.craftingState.sequence.length) {
        return;
      }
      this.craftingState.sequence.splice(index, 1);
      this.refreshCraftingUi();
    }

    handleCraftSequenceFocus(event) {
      const button = event.target.closest('[data-sequence-index]');
      if (!button) {
        return;
      }
      const index = Number.parseInt(button.dataset.sequenceIndex ?? '-1', 10);
      if (!Number.isInteger(index)) {
        return;
      }
      const sequence = Array.isArray(this.craftingState?.sequence) ? this.craftingState.sequence : [];
      const item = sequence[index];
      if (item) {
        const def = getItemDefinition(item);
        const matches = this.buildRecipeMatchSummaries(this.findRecipesMatchingPrefix(sequence), 3);
        const details = matches.length
          ? matches
          : ['Sequence incomplete — continue adding ingredients to discover matches.'];
        let description = def.description || def.label;
        description += ' Click to remove this step from the sequence.';
        this.showCraftingHelperHint('sequence', {
          title: `Step ${index + 1}: ${def.label}`,
          description,
          matches: details,
        });
      } else {
        const prefix = sequence.slice(0, index);
        const matches = this.buildRecipeMatchSummaries(this.findRecipesMatchingPrefix(prefix), 3);
        const details = matches.length
          ? matches
          : ['Experiment with ingredients to discover new recipes.'];
        this.showCraftingHelperHint('sequence', {
          title: `Slot ${index + 1}`,
          description: 'Empty slot — drop an ingredient here to extend the recipe.',
          matches: details,
        });
      }
    }

    handleCraftSequenceBlur(event) {
      if (event?.relatedTarget && event.currentTarget?.contains?.(event.relatedTarget)) {
        return;
      }
      this.clearCraftingHelperHint('sequence');
    }

    handleClearCraft() {
      if (!this.craftingState.sequence.length) return;
      this.craftingState.sequence = [];
      this.refreshCraftingUi();
    }

    handleCraftButton() {
      const craftedSequence = this.craftingState.sequence.slice();
      const validation = this.updateCraftButtonState(this.validateCraftingSequence());
      if (!validation.valid) {
        this.showHint(validation.message || 'Sequence unstable.');
        this.announceCraftingValidation(validation);
        return;
      }
      const { recipe, key } = validation;
      recipe.sequence.forEach((itemId) => {
        this.removeItemFromInventory(itemId, 1);
      });
      this.addItemToInventory(recipe.id, 1);
      this.craftingState.sequence = [];
      this.craftedRecipes.add(recipe.id);
      this.craftingState.unlocked.set(key, recipe);
      this.score += recipe.score;
      this.addScoreBreakdown('recipes', recipe.score);
      this.savePersistentUnlocks();
      this.announceCraftingValidation({ valid: true });
      this.showHint(validation.message || `${recipe.label} crafted!`);
      this.refreshCraftingUi();
      this.updateHud();
      this.markGuidanceProgress('craft');
      this.scheduleScoreSync('recipe-crafted');
      this.audio.play('craftChime', { volume: 0.6 });
      this.emitGameEvent('recipe-crafted', {
        recipeId: recipe.id,
        recipeKey: key,
        recipeLabel: recipe.label,
        scoreAwarded: recipe.score,
        sequence: craftedSequence,
        inventoryCount: this.getTotalInventoryCount(),
      });
    }

    handleCraftSuggestionClick(event) {
      const button = event.target.closest('[data-recipe-key]');
      if (!button) return;
      if (button.getAttribute('aria-disabled') === 'true') {
        if (event?.preventDefault) {
          event.preventDefault();
        }
        const status = button.dataset.status || 'missing';
        if (status === 'locked') {
          this.showHint('Discover this recipe before crafting it.');
        } else if (status === 'missing') {
          const summary = button.dataset.missingSummary || '';
          const message = summary
            ? `Missing ingredients: ${summary}.`
            : 'Gather the missing ingredients to craft this recipe.';
          this.showHint(message);
        } else {
          this.showHint('Recipe unavailable.');
        }
        return;
      }
      const key = button.dataset.recipeKey;
      if (!key) return;
      const parts = key.split(',').filter(Boolean);
      this.craftingState.sequence = parts.slice(0, this.getCraftingSlotCount());
      this.refreshCraftingUi();
    }

    handleCraftSearchInput(event) {
      this.craftingState.searchTerm = (event.target?.value || '').toLowerCase();
      this.updateCraftingSearchResults();
    }

    handleOpenCrafting(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      this.toggleCraftingModal(true);
    }

    handleCloseCrafting(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      this.toggleCraftingModal(false);
    }

    handleInventorySort(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      this.sortInventoryByQuantity();
      this.updateInventoryUi();
      this.showHint('Inventory sorted.');
      this.inventorySortButton?.setAttribute('aria-pressed', 'true');
    }

    handleInventoryToggle(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      const willOpen = this.inventoryModal?.hidden !== false;
      this.toggleInventoryModal(willOpen);
    }

    getInventoryCountForItem(item) {
      if (!item) return 0;
      let total = 0;
      this.hotbar.forEach((slot) => {
        if (slot.item === item) {
          total += slot.quantity;
        }
      });
      total += this.satchel.get(item) ?? 0;
      return total;
    }

    getCraftingSlotCount() {
      const count = Number.parseInt(this.craftSequenceEl?.dataset.slotCount ?? '0', 10);
      return Number.isInteger(count) && count > 0 ? count : 7;
    }

    toggleCraftingModal(visible) {
      if (!this.craftingModal) return;
      if (visible) {
        this.craftingModal.hidden = false;
        setInertState(this.craftingModal, false);
        activateOverlayIsolation(this.craftingModal);
        document.exitPointerLock?.();
        this.refreshCraftingUi();
      } else {
        this.craftingModal.hidden = true;
        setInertState(this.craftingModal, true);
        releaseOverlayIsolation(this.craftingModal);
        this.toggleCraftingSearch(false);
        this.focusGameViewport();
        this.clearCraftingHelperHint();
      }
      if (this.craftLauncherButton) {
        this.craftLauncherButton.setAttribute('aria-expanded', visible ? 'true' : 'false');
      }
    }

    toggleInventoryModal(visible) {
      if (!this.inventoryModal) return;
      if (visible) {
        this.inventoryModal.hidden = false;
        setInertState(this.inventoryModal, false);
        activateOverlayIsolation(this.inventoryModal);
        document.exitPointerLock?.();
        this.updateInventoryModal();
        this.inventorySortButton?.setAttribute('aria-pressed', 'false');
      } else {
        this.inventoryModal.hidden = true;
        setInertState(this.inventoryModal, true);
        releaseOverlayIsolation(this.inventoryModal);
        this.focusGameViewport();
        this.inventorySortButton?.setAttribute('aria-pressed', 'false');
      }
      this.openInventoryButtons.forEach((btn) => {
        if (!btn) return;
        btn.setAttribute('aria-expanded', visible ? 'true' : 'false');
        if (btn.tagName === 'BUTTON') {
          btn.textContent = visible ? 'Close Inventory' : 'Open Inventory';
        }
      });
    }

    toggleCraftingSearch(visible) {
      if (!this.craftingSearchPanel) return;
      if (visible) {
        this.craftingSearchPanel.hidden = false;
        setInertState(this.craftingSearchPanel, false);
        this.updateCraftingSearchResults();
        this.craftingSearchInput?.focus();
      } else {
        this.craftingSearchPanel.hidden = true;
        setInertState(this.craftingSearchPanel, true);
        this.craftingState.searchTerm = '';
      }
    }

    refreshCraftingUi() {
      this.updateCraftingSequenceUi();
      this.updateCraftingInventoryUi();
      this.updateCraftingSuggestions();
      this.updateCraftButtonState();
      this.updateCraftingHelperOverlay();
    }

    updateCraftingSequenceUi() {
      if (!this.craftSequenceEl) return;
      const slotCount = this.getCraftingSlotCount();
      const fragment = document.createDocumentFragment();
      for (let i = 0; i < slotCount; i += 1) {
        const item = this.craftingState.sequence[i] ?? null;
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'crafting-sequence__slot';
        button.dataset.sequenceIndex = i;
        if (item) {
          const def = getItemDefinition(item);
          button.textContent = formatInventoryLabel(item, 1);
          button.setAttribute('aria-label', `Remove ${def.label} from sequence`);
          button.setAttribute('data-hint', `Click to remove ${def.label} from the sequence.`);
        } else {
          button.textContent = '·';
          button.setAttribute('aria-label', 'Empty sequence slot');
          button.setAttribute('data-hint', 'Empty slot — drop an ingredient here.');
        }
        fragment.appendChild(button);
      }
      this.craftSequenceEl.innerHTML = '';
      this.craftSequenceEl.appendChild(fragment);
    }

    updateCraftingSuggestions() {
      if (!this.craftSuggestionsEl) return;
      const fragment = document.createDocumentFragment();
      const entries = Array.from(this.craftingState.unlocked.entries());
      entries.sort((a, b) => a[1].label.localeCompare(b[1].label));
      entries.forEach(([key, recipe]) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'crafting-suggestions__item';
        button.dataset.recipeKey = key;
        const sequenceText = key.replace(/,/g, ' → ');
        const recipeVisualStatus = this.getRecipeVisualStatus(recipe, key);
        const recipeVisualSummary = this.describeRecipeVisualStatus(
          recipe,
          key,
          recipeVisualStatus,
        );
        const suggestionLabel = `${recipe.label} (${sequenceText})`;
        button.textContent =
          recipeVisualStatus.missing === true
            ? `${suggestionLabel} • ${recipeVisualSummary || 'Missing visuals'}`
            : suggestionLabel;
        const eligibility = this.computeRecipeEligibility(recipe, key);
        const statusToken = this.getRecipeEligibilityToken(eligibility);
        const statusLabel = this.describeRecipeEligibility(eligibility);
        const missingSummary = eligibility.hasMaterials
          ? ''
          : this.describeMissingIngredients(eligibility.missing);
        button.dataset.status = statusToken;
        button.dataset.eligible = eligibility.eligible ? 'true' : 'false';
        button.dataset.unlocked = eligibility.unlocked ? 'true' : 'false';
        if (missingSummary) {
          button.dataset.missingSummary = missingSummary;
        }
        if (eligibility.eligible) {
          button.removeAttribute('aria-disabled');
        } else {
          button.setAttribute('aria-disabled', 'true');
        }
        button.dataset.visual = recipeVisualStatus.missing ? 'missing' : 'ready';
        if (recipeVisualSummary) {
          button.dataset.visualSummary = recipeVisualSummary;
        } else {
          delete button.dataset.visualSummary;
        }
        const hintParts = [];
        if (recipe.description) {
          hintParts.push(recipe.description);
        }
        if (statusLabel) {
          hintParts.push(statusLabel);
        }
        if (recipeVisualSummary) {
          hintParts.push(recipeVisualSummary);
        }
        hintParts.push(`Autofill sequence • +${recipe.score} pts`);
        button.setAttribute('data-hint', hintParts.join(' — '));
        const li = document.createElement('li');
        li.dataset.status = statusToken;
        li.dataset.eligible = button.dataset.eligible;
        li.dataset.visual = button.dataset.visual;
        li.appendChild(button);
        fragment.appendChild(li);
      });
      if (!entries.length) {
        const empty = document.createElement('li');
        empty.textContent = 'Discover recipes to unlock quick sequences.';
        fragment.appendChild(empty);
      }
      this.craftSuggestionsEl.innerHTML = '';
      this.craftSuggestionsEl.appendChild(fragment);
    }

    updateCraftButtonState(presetValidation = null) {
      if (!this.craftButton) return presetValidation;
      const validation = presetValidation || this.validateCraftingSequence();
      this.craftingState.lastValidation = validation;
      const enabled = validation.valid === true;
      this.craftButton.disabled = !enabled;
      this.craftButton.dataset.eligible = enabled ? 'true' : 'false';
      if (validation.reason) {
        this.craftButton.dataset.validationState = enabled ? 'ready' : validation.reason;
      } else {
        delete this.craftButton.dataset.validationState;
      }
      const hintMessage = enabled
        ? validation.recipe
          ? `Ready to craft ${validation.recipe.label}.`
          : 'Ready to craft.'
        : validation.message || 'Sequence unstable.';
      if (hintMessage) {
        this.craftButton.setAttribute('data-hint', hintMessage);
      } else {
        this.craftButton.removeAttribute('data-hint');
      }
      return validation;
    }

    buildIngredientCount(parts = []) {
      const tally = new Map();
      if (!Array.isArray(parts)) {
        return tally;
      }
      parts.forEach((itemId) => {
        if (!itemId) return;
        tally.set(itemId, (tally.get(itemId) ?? 0) + 1);
      });
      return tally;
    }

    findRecipeByIngredients(sequence) {
      if (!Array.isArray(sequence) || !sequence.length) {
        return null;
      }
      const target = this.buildIngredientCount(sequence);
      let match = null;
      this.craftingRecipes.forEach((recipe, key) => {
        if (match || !recipe) {
          return;
        }
        const parts = this.getRecipeSequence(recipe, key);
        if (parts.length !== sequence.length) {
          return;
        }
        const counts = this.buildIngredientCount(parts);
        if (counts.size !== target.size) {
          return;
        }
        let valid = true;
        for (const [itemId, required] of counts.entries()) {
          if (target.get(itemId) !== required) {
            valid = false;
            break;
          }
        }
        if (valid) {
          match = { recipe, key, parts };
        }
      });
      return match;
    }

    describeMissingIngredients(missing = []) {
      if (!Array.isArray(missing) || !missing.length) {
        return '';
      }
      return missing
        .map((entry) => {
          const def = getItemDefinition(entry.itemId);
          const shortfall = Number.isFinite(entry.missing) ? Math.max(1, entry.missing) : 1;
          return `${def.label} ×${shortfall}`;
        })
        .join(', ');
    }

    resolveCraftingValidationModule() {
      const scope =
        (typeof window !== 'undefined' && window) ||
        (typeof globalThis !== 'undefined' && globalThis) ||
        null;
      const candidate = scope?.Crafting ?? null;
      if (
        candidate &&
        typeof candidate.validateCraftAttempt === 'function' &&
        typeof candidate.createCraftingState === 'function'
      ) {
        this.craftingValidationModule = candidate;
        this.craftingValidationModuleResolved = true;
        return this.craftingValidationModule;
      }
      if (!this.craftingValidationModuleResolved) {
        this.craftingValidationModuleResolved = true;
      }
      return this.craftingValidationModule;
    }

    buildCraftingInventorySnapshot() {
      const inventory = {};
      const hotbar = {};
      if (Array.isArray(this.hotbar)) {
        this.hotbar.forEach((slot) => {
          if (!slot || !slot.item) {
            return;
          }
          const quantity = Number.isFinite(slot.quantity) ? Math.max(0, slot.quantity) : 0;
          if (quantity <= 0) {
            return;
          }
          hotbar[slot.item] = (hotbar[slot.item] || 0) + quantity;
          inventory[slot.item] = (inventory[slot.item] || 0) + quantity;
        });
      }
      if (this.satchel && typeof this.satchel.forEach === 'function') {
        this.satchel.forEach((quantity, itemId) => {
          if (!itemId) {
            return;
          }
          const count = Number.isFinite(quantity) ? Math.max(0, quantity) : 0;
          if (count <= 0) {
            return;
          }
          inventory[itemId] = (inventory[itemId] || 0) + count;
        });
      }
      return { inventory, hotbar };
    }

    findRecipeMetadataById(recipeId) {
      if (!recipeId) {
        return null;
      }
      let match = null;
      this.craftingRecipes.forEach((recipe, key) => {
        if (match || !recipe || recipe.id !== recipeId) {
          return;
        }
        match = { recipe, key, parts: this.getRecipeSequence(recipe, key) };
      });
      return match;
    }

    buildCraftingValidationState() {
      const module = this.resolveCraftingValidationModule();
      if (!module) {
        return null;
      }
      const recipes = [];
      const dimensionIds = new Set();
      this.craftingRecipes.forEach((recipe, key) => {
        if (!recipe) {
          return;
        }
        const parts = this.getRecipeSequence(recipe, key);
        const unlock = recipe.unlock || recipe.dimension || 'origin';
        dimensionIds.add(unlock);
        recipes.push({
          id: recipe.id,
          name: recipe.label,
          sequence: parts.slice(),
          output: { item: recipe.id, quantity: 1 },
          unlock,
          points: Number.isFinite(recipe.score) ? recipe.score : 0,
        });
      });
      if (!recipes.length) {
        return null;
      }
      const { inventory, hotbar } = this.buildCraftingInventorySnapshot();
      const unlockedRecipes = [];
      this.craftingState.unlocked.forEach((entry) => {
        if (entry?.id) {
          unlockedRecipes.push(entry.id);
        }
      });
      const knownRecipes = Array.from(this.craftedRecipes || []);
      const unlockedDimensions = dimensionIds.size ? Array.from(dimensionIds) : ['origin'];
      const state = module.createCraftingState({
        recipes,
        inventory,
        hotbar,
        unlockedRecipes,
        knownRecipes,
        unlockedDimensions,
        points: Number.isFinite(this.score) ? this.score : 0,
      });
      return { module, state };
    }

    translateCraftingModuleValidation(sequence, attempt) {
      if (!attempt) {
        return null;
      }
      if (attempt.reason === 'empty-sequence') {
        return {
          valid: false,
          reason: 'empty-sequence',
          message: 'Add items to the sequence to craft.',
        };
      }
      const filtered = Array.isArray(sequence) ? sequence.filter(Boolean) : [];
      const key = filtered.join(',');
      const baseMatch = key && this.craftingRecipes.has(key)
        ? { recipe: this.craftingRecipes.get(key), key, parts: filtered.slice() }
        : null;
      const matchById = (id) => {
        if (!id) {
          return baseMatch;
        }
        return this.findRecipeMetadataById(id) || baseMatch;
      };
      if (!attempt.valid) {
        const reason = attempt.reason || 'no-recipe';
        if (reason === 'order-mismatch') {
          const target =
            (attempt.recipe && matchById(attempt.recipe.id)) ||
            this.findRecipeByIngredients(filtered) ||
            baseMatch;
          const recipe = target?.recipe || null;
          const parts = target?.parts || attempt.recipe?.sequence || [];
          const order = this.formatRecipeSequence(parts);
          const label =
            (recipe && recipe.label) ||
            (attempt.recipe && (attempt.recipe.label || attempt.recipe.name)) ||
            'Recipe';
          return {
            valid: false,
            reason,
            recipe,
            message: order
              ? `${label} requires the order ${order}.`
              : attempt.alert || 'Recipe ingredients detected, but the order is incorrect.',
          };
        }
        if (reason === 'missing-ingredients') {
          const target =
            (attempt.recipe && matchById(attempt.recipe.id)) ||
            baseMatch;
          const summary = this.describeMissingIngredients(attempt.missing);
          return {
            valid: false,
            reason,
            recipe: target?.recipe || null,
            missing: Array.isArray(attempt.missing) ? attempt.missing : [],
            message: summary
              ? `Missing materials: ${summary}.`
              : attempt.alert || 'Missing materials for this recipe.',
          };
        }
        if (reason === 'no-recipe') {
          return {
            valid: false,
            reason,
            message: attempt.alert || 'Sequence fizzles. No recipe matched.',
          };
        }
        return {
          valid: false,
          reason,
          message: attempt.alert || 'Sequence unstable.',
        };
      }
      const target =
        (attempt.recipe && matchById(attempt.recipe.id)) ||
        baseMatch;
      const recipe = target?.recipe || null;
      const sequenceKey = target?.key || (target?.parts?.join(',') ?? key);
      const label =
        (recipe && recipe.label) ||
        (attempt.recipe && (attempt.recipe.label || attempt.recipe.name)) ||
        'Recipe';
      return {
        valid: true,
        reason: 'ready',
        recipe,
        key: sequenceKey,
        message: `${label} crafted!`,
      };
    }

    validateCraftingSequence() {
      const sequence = Array.isArray(this.craftingState?.sequence)
        ? this.craftingState.sequence.filter(Boolean)
        : [];
      if (!sequence.length) {
        return {
          valid: false,
          reason: 'empty-sequence',
          message: 'Add items to the sequence to craft.',
        };
      }
      const validationState = this.buildCraftingValidationState();
      if (validationState) {
        const attempt = validationState.module.validateCraftAttempt(
          validationState.state,
          sequence,
        );
        const translated = this.translateCraftingModuleValidation(sequence, attempt);
        if (translated) {
          return translated;
        }
      }
      const key = sequence.join(',');
      const recipe = this.craftingRecipes.get(key);
      if (!recipe) {
        const ingredientMatch = this.findRecipeByIngredients(sequence);
        if (ingredientMatch) {
          const order = this.formatRecipeSequence(ingredientMatch.parts);
          return {
            valid: false,
            reason: 'order-mismatch',
            recipe: ingredientMatch.recipe,
            message: `${ingredientMatch.recipe.label} requires the order ${order}.`,
          };
        }
        return {
          valid: false,
          reason: 'no-recipe',
          message: 'Sequence fizzles. No recipe matched.',
        };
      }
      const eligibility = this.computeRecipeEligibility(recipe, key, { requireUnlock: false });
      if (!eligibility.hasMaterials) {
        const summary = this.describeMissingIngredients(eligibility.missing);
        return {
          valid: false,
          reason: 'missing-ingredients',
          recipe,
          missing: eligibility.missing,
          message: summary ? `Missing materials: ${summary}.` : 'Missing materials for this recipe.',
        };
      }
      return {
        valid: true,
        reason: 'ready',
        recipe,
        key,
        message: `${recipe.label} crafted!`,
      };
    }

    announceCraftingValidation(validation) {
      if (!validation) {
        return;
      }
      if (!validation.valid) {
        const matches = [];
        if (validation.reason === 'order-mismatch' && validation.recipe) {
          const parts = this.getRecipeSequence(validation.recipe);
          matches.push(
            `${validation.recipe.label} — ${this.formatRecipeSequence(parts)} • +${validation.recipe.score} pts`,
          );
        } else if (validation.reason === 'missing-ingredients' && Array.isArray(validation.missing)) {
          const summary = this.describeMissingIngredients(validation.missing);
          if (summary) {
            matches.push(`Still required: ${summary}`);
          }
        }
        this.showCraftingHelperHint('craft-validation', {
          title: 'Sequence Invalid',
          description: validation.message || 'This combination cannot be crafted yet.',
          matches,
        });
      } else {
        this.clearCraftingHelperHint('craft-validation');
      }
    }

    updateCraftingSearchResults() {
      if (!this.craftingSearchResultsEl) return;
      const term = (this.craftingState.searchTerm || '').trim().toLowerCase();
      const results = [];
      this.craftingRecipes.forEach((recipe, key) => {
        const labelMatch = recipe.label.toLowerCase().includes(term);
        const keyMatch = key.toLowerCase().includes(term);
        if (!term || labelMatch || keyMatch) {
          results.push({ key, recipe });
        }
      });
      const fragment = document.createDocumentFragment();
      results.slice(0, 12).forEach(({ key, recipe }) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'crafting-search__result';
        button.dataset.recipeKey = key;
        const sequenceParts = this.getRecipeSequence(recipe, key);
        const sequenceText = this.formatRecipeSequence(sequenceParts);
        const recipeVisualStatus = this.getRecipeVisualStatus(recipe, key);
        const recipeVisualSummary = this.describeRecipeVisualStatus(
          recipe,
          key,
          recipeVisualStatus,
        );
        const eligibility = this.computeRecipeEligibility(recipe, key);
        const statusToken = this.getRecipeEligibilityToken(eligibility);
        const statusLabel = this.describeRecipeEligibility(eligibility);
        const missingSummary = eligibility.hasMaterials
          ? ''
          : this.describeMissingIngredients(eligibility.missing);
        button.dataset.status = statusToken;
        button.dataset.eligible = eligibility.eligible ? 'true' : 'false';
        button.dataset.unlocked = eligibility.unlocked ? 'true' : 'false';
        if (missingSummary) {
          button.dataset.missingSummary = missingSummary;
        }
        if (eligibility.eligible) {
          button.removeAttribute('aria-disabled');
        } else {
          button.setAttribute('aria-disabled', 'true');
        }
        button.dataset.visual = recipeVisualStatus.missing ? 'missing' : 'ready';
        if (recipeVisualSummary) {
          button.dataset.visualSummary = recipeVisualSummary;
        } else {
          delete button.dataset.visualSummary;
        }
        const title = document.createElement('span');
        title.textContent = recipe.label;
        const order = document.createElement('span');
        order.className = 'crafting-search-panel__result-output';
        order.textContent = sequenceText;
        const subtitle = document.createElement('span');
        subtitle.className = 'crafting-search-panel__result-subtitle';
        const subtitleParts = [];
        if (statusLabel) {
          subtitleParts.push(statusLabel);
        }
        subtitleParts.push(`+${recipe.score} pts`);
        if (recipeVisualSummary) {
          subtitleParts.push(recipeVisualSummary);
        }
        subtitle.textContent = subtitleParts.join(' • ');
        button.innerHTML = '';
        button.append(title, order, subtitle);
        const hintParts = [];
        if (recipe.description) {
          hintParts.push(recipe.description);
        }
        if (statusLabel) {
          hintParts.push(statusLabel);
        }
        if (recipeVisualSummary) {
          hintParts.push(recipeVisualSummary);
        }
        hintParts.push(`Reward: +${recipe.score} pts`);
        hintParts.push(`Order: ${sequenceText}`);
        button.setAttribute('data-hint', hintParts.join(' — '));
        const li = document.createElement('li');
        li.dataset.status = statusToken;
        li.dataset.eligible = button.dataset.eligible;
        li.dataset.visual = button.dataset.visual;
        li.appendChild(button);
        fragment.appendChild(li);
      });
      if (!results.length) {
        const li = document.createElement('li');
        li.className = 'crafting-search__empty';
        li.textContent = 'No recipes match that phrase.';
        fragment.appendChild(li);
      }
      this.craftingSearchResultsEl.innerHTML = '';
      this.craftingSearchResultsEl.appendChild(fragment);
    }

    getRecipeSequence(recipe, key) {
      if (Array.isArray(recipe?.sequence) && recipe.sequence.length) {
        return recipe.sequence.slice();
      }
      if (typeof key === 'string' && key.length) {
        return key.split(',').filter(Boolean);
      }
      return [];
    }

    formatRecipeSequence(parts) {
      if (!Array.isArray(parts) || !parts.length) {
        return '—';
      }
      return parts.map((itemId) => getItemDefinition(itemId).label).join(' → ');
    }

    hasMaterialsForRecipe(recipe) {
      const parts = this.getRecipeSequence(recipe);
      if (!parts.length) {
        return false;
      }
      const counts = new Map();
      parts.forEach((itemId) => {
        counts.set(itemId, (counts.get(itemId) ?? 0) + 1);
      });
      for (const [itemId, required] of counts.entries()) {
        if (this.getInventoryCountForItem(itemId) < required) {
          return false;
        }
      }
      return true;
    }

    computeRecipeEligibility(recipe, key, options = {}) {
      if (!recipe) {
        return { unlocked: false, hasMaterials: false, eligible: false, missing: [], key: '' };
      }
      const parts = this.getRecipeSequence(recipe, key);
      const sequenceKey = typeof key === 'string' && key.length ? key : parts.join(',');
      const unlocked = this.craftingState.unlocked.has(sequenceKey);
      const counts = this.buildIngredientCount(parts);
      const missing = [];
      counts.forEach((required, itemId) => {
        const available = this.getInventoryCountForItem(itemId);
        if (available < required) {
          missing.push({
            itemId,
            required,
            available,
            missing: required - available,
          });
        }
      });
      const hasMaterials = missing.length === 0;
      const requireUnlock = options.requireUnlock !== false;
      const eligible = (requireUnlock ? unlocked : true) && hasMaterials;
      return { unlocked, hasMaterials, eligible, missing, key: sequenceKey };
    }

    describeRecipeEligibility(eligibility) {
      if (!eligibility) {
        return 'Unavailable';
      }
      if (!eligibility.unlocked) {
        return 'Recipe undiscovered';
      }
      if (!eligibility.hasMaterials) {
        const summary = this.describeMissingIngredients(eligibility.missing);
        return summary ? `Missing ingredients: ${summary}` : 'Missing ingredients';
      }
      return 'Ready to craft';
    }

    getRecipeEligibilityToken(eligibility) {
      if (!eligibility) {
        return 'unavailable';
      }
      if (!eligibility.unlocked) {
        return 'locked';
      }
      if (!eligibility.hasMaterials) {
        return 'missing';
      }
      return 'ready';
    }

    findRecipesMatchingPrefix(sequence) {
      if (!Array.isArray(sequence)) {
        return [];
      }
      const matches = [];
      this.craftingRecipes.forEach((recipe, key) => {
        const parts = this.getRecipeSequence(recipe, key);
        let valid = true;
        for (let i = 0; i < sequence.length; i += 1) {
          if (parts[i] !== sequence[i]) {
            valid = false;
            break;
          }
        }
        if (!valid) {
          return;
        }
        const remaining = Math.max(0, parts.length - sequence.length);
        const nextId = parts[sequence.length] || null;
        matches.push({ recipe, key, parts, remaining, nextId });
      });
      matches.sort((a, b) => {
        if (a.remaining !== b.remaining) {
          return a.remaining - b.remaining;
        }
        return a.recipe.label.localeCompare(b.recipe.label);
      });
      return matches;
    }

    getRecipesUsingItem(itemId) {
      if (!itemId) {
        return [];
      }
      const results = [];
      this.craftingRecipes.forEach((recipe, key) => {
        const parts = this.getRecipeSequence(recipe, key);
        const positions = [];
        parts.forEach((part, index) => {
          if (part === itemId) {
            positions.push(index);
          }
        });
        if (positions.length) {
          results.push({ recipe, parts, positions });
        }
      });
      results.sort((a, b) => a.recipe.label.localeCompare(b.recipe.label));
      return results;
    }

    formatRecipeStepSummary(positions, total) {
      if (!Array.isArray(positions) || !positions.length || !Number.isFinite(total) || total <= 0) {
        return '';
      }
      if (positions.length === total) {
        return 'used in every step';
      }
      if (positions.length === 1) {
        return `used at step ${positions[0] + 1} of ${total}`;
      }
      return `used at steps ${positions.map((index) => index + 1).join(', ')} of ${total}`;
    }

    buildRecipeMatchSummaries(matches, limit = 3) {
      if (!Array.isArray(matches) || !matches.length) {
        return [];
      }
      return matches.slice(0, limit).map((match) => {
        const parts = match.parts;
        const sequenceText = this.formatRecipeSequence(parts);
        let status = '';
        if (match.remaining === 0) {
          status = this.hasMaterialsForRecipe(match.recipe) ? 'Ready to craft' : 'Missing ingredients';
        } else if (match.nextId) {
          status = `Next: ${getItemDefinition(match.nextId).label}`;
        }
        const base = `${match.recipe.label} — ${sequenceText}`;
        const bonus = `+${match.recipe.score} pts`;
        return status ? `${base} (${status}) • ${bonus}` : `${base} • ${bonus}`;
      });
    }

    showCraftingHelperHint(source, payload = {}) {
      if (!this.craftingHelperEl) {
        return;
      }
      this.craftingHelperOverride = {
        source: source || 'default',
        title: payload.title || null,
        description: payload.description || null,
        matches: Array.isArray(payload.matches) ? payload.matches.filter((text) => typeof text === 'string' && text.trim()) : [],
      };
      this.updateCraftingHelperOverlay();
    }

    clearCraftingHelperHint(source) {
      if (!this.craftingHelperEl) {
        return;
      }
      if (source && this.craftingHelperOverride?.source && this.craftingHelperOverride.source !== source) {
        return;
      }
      this.craftingHelperOverride = null;
      this.updateCraftingHelperOverlay();
    }

    updateCraftingHelperOverlay() {
      const helperEl = this.craftingHelperEl;
      if (!helperEl) {
        return;
      }
      const titleEl = this.craftingHelperTitleEl;
      const descriptionEl = this.craftingHelperDescriptionEl;
      const matchesEl = this.craftingHelperMatchesEl;
      const defaultTitle = 'Recipe Helper';
      let title = defaultTitle;
      let description = 'Queue materials to preview known recipes.';
      const matchSummaries = [];
      const override = this.craftingHelperOverride;

      if (override) {
        if (override.title) {
          title = override.title;
        }
        if (override.description) {
          description = override.description;
        }
        if (Array.isArray(override.matches) && override.matches.length) {
          override.matches.forEach((text) => {
            if (text && typeof text === 'string') {
              matchSummaries.push(text);
            }
          });
        }
      } else {
        const sequence = Array.isArray(this.craftingState?.sequence) ? this.craftingState.sequence : [];
        if (sequence.length === 0) {
          const unlocked = Array.from(this.craftingState?.unlocked?.values?.() || []);
          if (unlocked.length) {
            description = 'Select an unlocked recipe to auto-fill the crafting circle.';
            unlocked.slice(0, 3).forEach((recipe) => {
              const parts = this.getRecipeSequence(recipe);
              matchSummaries.push(`${recipe.label} — ${this.formatRecipeSequence(parts)} • +${recipe.score} pts`);
            });
          } else {
            description = 'Drag ingredients from your satchel to experiment with new combinations.';
          }
        } else {
          const prefixMatches = this.findRecipesMatchingPrefix(sequence);
          if (prefixMatches.length) {
            const top = prefixMatches[0];
            if (top.remaining === 0) {
              const readyText = this.hasMaterialsForRecipe(top.recipe)
                ? 'Ready to craft — press Craft Item to claim the reward.'
                : 'Recipe located — gather the remaining ingredients to craft it.';
              description = `${top.recipe.label} detected. ${readyText}`;
            } else if (top.nextId) {
              const nextLabel = getItemDefinition(top.nextId).label;
              description = `Next add ${nextLabel} to craft ${top.recipe.label}.`;
            }
            this.buildRecipeMatchSummaries(prefixMatches, 3).forEach((summary) => matchSummaries.push(summary));
          } else {
            description = 'No known recipes use this order yet. Try reordering the sequence.';
          }
        }
      }

      if (titleEl) {
        titleEl.textContent = title;
      }
      if (descriptionEl) {
        descriptionEl.textContent = description;
      }
      if (matchesEl) {
        matchesEl.innerHTML = '';
        if (matchSummaries.length) {
          const fragment = document.createDocumentFragment();
          matchSummaries.slice(0, 3).forEach((text) => {
            const li = document.createElement('li');
            li.textContent = text;
            fragment.appendChild(li);
          });
          matchesEl.appendChild(fragment);
        }
        matchesEl.setAttribute('data-empty', matchSummaries.length ? 'false' : 'true');
      }
      helperEl.dataset.state = override
        ? 'focused'
        : this.craftingState.sequence.length
          ? 'active'
          : 'idle';
      helperEl.setAttribute('data-has-matches', matchSummaries.length ? 'true' : 'false');
    }

    sortInventoryByQuantity() {
      const performSort = () => {
        const items = Array.isArray(this.hotbar) ? this.hotbar.filter((slot) => slot?.item) : [];
        items.sort((a, b) => (Number(b?.quantity) || 0) - (Number(a?.quantity) || 0));
        const reordered = [];
        items.forEach((slot) => {
          const itemId = typeof slot?.item === 'string' ? slot.item : slot?.item ?? null;
          const quantity = Number.isFinite(slot?.quantity) ? slot.quantity : 0;
          reordered.push({ item: itemId, quantity });
        });
        const targetLength = Array.isArray(this.hotbar) ? this.hotbar.length : HOTBAR_SLOTS;
        while (reordered.length < targetLength) {
          reordered.push({ item: null, quantity: 0 });
        }
        this.hotbar = reordered;
        this.selectedHotbarIndex = 0;
        return reordered;
      };
      try {
        return this.withGameplayAtomicSnapshot({ inventory: true }, performSort, { scope: 'inventory-sort' });
      } catch (error) {
        if (isAtomicAbortError(error)) {
          if (typeof console !== 'undefined' && typeof console.warn === 'function') {
            console.warn('Inventory sort aborted due to asset instability.', error);
          }
          notifyLiveDiagnostics(
            'inventory',
            'Inventory sort aborted due to asset instability.',
            { error: normaliseLiveDiagnosticError(error), scope: 'inventory-sort' },
            { level: 'warning' },
          );
          return null;
        }
        throw error;
      }
    }

    addScoreBreakdown(category, amount) {
      const key = typeof category === 'string' && category.trim() ? category.trim() : 'misc';
      const numericAmount = Number(amount);
      if (!Number.isFinite(numericAmount) || numericAmount === 0) {
        return;
      }
      const applyScoreMutation = () => {
        if (!this.scoreBreakdown || typeof this.scoreBreakdown !== 'object') {
          this.scoreBreakdown = {};
        }
        const previous = Number.isFinite(this.scoreBreakdown[key]) ? this.scoreBreakdown[key] : 0;
        this.scoreBreakdown[key] = previous + numericAmount;
        if (numericAmount > 0) {
          this.notifyScoreEvent(key, numericAmount);
        }
        return this.scoreBreakdown[key];
      };
      try {
        return this.withGameplayAtomicSnapshot({ score: true }, applyScoreMutation, { scope: 'score' });
      } catch (error) {
        if (isAtomicAbortError(error)) {
          if (typeof console !== 'undefined' && typeof console.warn === 'function') {
            console.warn('Score update aborted due to asset instability.', error);
          }
          notifyLiveDiagnostics(
            'score',
            'Score update aborted due to asset instability.',
            { error: normaliseLiveDiagnosticError(error), scope: 'score', category: key },
            { level: 'warning' },
          );
          return null;
        }
        throw error;
      }
    }

    getScoreBreakdownSnapshot() {
      const snapshot = {};
      const source = this.scoreBreakdown && typeof this.scoreBreakdown === 'object' ? this.scoreBreakdown : {};
      Object.entries(source).forEach(([key, value]) => {
        if (typeof key !== 'string') return;
        const trimmed = key.trim();
        if (!trimmed) return;
        const numeric = Number(value);
        if (Number.isFinite(numeric)) {
          snapshot[trimmed] = numeric;
        }
      });
      return snapshot;
    }

    getScoreSnapshot() {
      const breakdown = this.getScoreBreakdownSnapshot();
      return {
        total: Math.round(this.score ?? 0),
        recipes: this.craftedRecipes?.size ?? 0,
        craftingEvents: this.craftingScoreEvents ?? 0,
        dimensions: Math.max(0, this.currentDimensionIndex + 1),
        dimensionEvents: this.dimensionScoreEvents ?? 0,
        portalEvents: this.portalScoreEvents ?? 0,
        combatEvents: this.combatScoreEvents ?? 0,
        lootEvents: this.lootScoreEvents ?? 0,
        breakdown,
      };
    }

    getPlayerStatusSnapshot() {
      const maxHealth = Number.isFinite(this.maxHealth)
        ? Math.max(0, Math.round(this.maxHealth))
        : FALLBACK_HEALTH;
      const health = Math.max(
        0,
        Math.round(Number.isFinite(this.health) ? this.health : maxHealth || FALLBACK_HEALTH),
      );
      const maxBreath = Number.isFinite(this.playerBreathCapacity)
        ? Math.max(1, Math.round(this.playerBreathCapacity))
        : FALLBACK_BREATH;
      const breath = Math.max(
        0,
        Math.round(Number.isFinite(this.playerBreath) ? this.playerBreath : maxBreath),
      );
      const breathPercent = maxBreath > 0 ? Math.round((breath / maxBreath) * 100) : 0;
      return {
        health,
        maxHealth: maxHealth || FALLBACK_HEALTH,
        hearts: Math.max(0, health / 2),
        breath,
        maxBreath,
        bubbles: Math.max(0, Math.min(5, Math.ceil(breath / 2))),
        breathPercent,
      };
    }

    notifyScoreEvent(category, amount) {
      if (!Number.isFinite(amount) || amount <= 0) {
        return;
      }
      const normalizedKey = typeof category === 'string' ? category.trim().toLowerCase() : '';
      if (!normalizedKey) {
        return;
      }
      switch (normalizedKey) {
        case 'recipes':
          this.craftingScoreEvents = (this.craftingScoreEvents || 0) + 1;
          break;
        case 'dimensions':
          this.dimensionScoreEvents = (this.dimensionScoreEvents || 0) + 1;
          break;
        case 'portal':
          this.portalScoreEvents = (this.portalScoreEvents || 0) + 1;
          break;
        case 'combat':
          this.combatScoreEvents = (this.combatScoreEvents || 0) + 1;
          break;
        case 'loot':
          this.lootScoreEvents = (this.lootScoreEvents || 0) + 1;
          break;
        default:
          break;
      }
      const panel = this.scorePanelEl || this.ui?.scorePanelEl || null;
      if (panel && panel.classList) {
        panel.classList.remove('score-overlay--flash');
        // Trigger a reflow so the animation can restart.
        void panel.offsetWidth;
        panel.classList.add('score-overlay--flash');
      }
      const targets = this.scoreMetricElements || {};
      const element = targets[normalizedKey];
      if (element) {
        const timers = this.scoreMetricFlashTimers || (this.scoreMetricFlashTimers = new Map());
        if (timers.has(element)) {
          clearTimeout(timers.get(element));
          timers.delete(element);
        }
        element.classList.remove('score-overlay__metric-value--flash');
        void element.offsetWidth;
        element.classList.add('score-overlay__metric-value--flash');
        element.dataset.delta = `+${this.formatPointValue(amount)} pts`;
        const timer = setTimeout(() => {
          element.classList.remove('score-overlay__metric-value--flash');
          delete element.dataset.delta;
          timers.delete(element);
        }, 900);
        timers.set(element, timer);
      }
      if (typeof this.updateHud === 'function') {
        this.updateHud({ reason: 'score-event' });
      }
      const syncReason = normalizedKey ? `score-${normalizedKey}` : 'score-event';
      this.scheduleScoreSync(syncReason);
    }

    formatPointValue(value) {
      const numeric = Math.max(0, Number(value) || 0);
      if (!Number.isFinite(numeric)) {
        return '0';
      }
      const maxFractionDigits = numeric < 1 ? 2 : numeric < 10 ? 1 : 0;
      return numeric.toLocaleString(undefined, {
        minimumFractionDigits: 0,
        maximumFractionDigits: maxFractionDigits,
      });
    }

    updateHud(reasonOrOptions) {
      const options =
        typeof reasonOrOptions === 'string'
          ? { reason: reasonOrOptions }
          : reasonOrOptions && typeof reasonOrOptions === 'object'
            ? reasonOrOptions
            : {};
      const reason =
        typeof options.reason === 'string' && options.reason.trim().length
          ? options.reason.trim()
          : 'hud-update';
      const shouldPublish = options.publish !== false;
      const {
        heartsEl,
        bubblesEl,
        scoreTotalEl,
        scoreRecipesEl,
        scoreDimensionsEl,
        scorePortalsEl,
        scoreCombatEl,
        scoreLootEl,
      } = this.ui;
      const playerStatus = this.getPlayerStatusSnapshot();
      const previousStatus = this.lastPlayerStatusSnapshot || null;
      if (heartsEl) {
        heartsEl.innerHTML = createHeartMarkup(playerStatus, previousStatus);
        heartsEl.dataset.health = String(playerStatus.health);
        heartsEl.dataset.maxHealth = String(playerStatus.maxHealth);
      }
      if (bubblesEl) {
        bubblesEl.innerHTML = createBubbleMarkup(playerStatus, previousStatus);
        bubblesEl.dataset.breath = String(playerStatus.breath);
        bubblesEl.dataset.maxBreath = String(playerStatus.maxBreath);
        bubblesEl.dataset.breathPercent = String(playerStatus.breathPercent);
      }
      this.lastPlayerStatusSnapshot = playerStatus;
      if (scoreTotalEl) {
        const roundedScore = Math.round(this.score ?? 0);
        scoreTotalEl.textContent = roundedScore.toLocaleString();
      }
      if (scoreRecipesEl) {
        const recipeCount = this.craftingScoreEvents ?? 0;
        const recipePoints = this.scoreBreakdown?.recipes ?? 0;
        const label = recipeCount === 1 ? 'craft' : 'crafts';
        scoreRecipesEl.textContent = `${recipeCount} ${label} (+${this.formatPointValue(recipePoints)} pts)`;
      }
      if (scoreDimensionsEl) {
        const dimensionCount = Math.max(1, this.currentDimensionIndex + 1);
        const dimensionPoints = this.scoreBreakdown?.dimensions ?? 0;
        const penaltyPoints = this.scoreBreakdown?.penalties ?? 0;
        let display = `${dimensionCount} (+${this.formatPointValue(dimensionPoints)} pts`;
        if (penaltyPoints > 0) {
          display += `, -${this.formatPointValue(penaltyPoints)} penalty`;
        }
        display += ')';
        scoreDimensionsEl.textContent = display;
      }
      if (scorePortalsEl) {
        const portalCount = this.portalScoreEvents ?? 0;
        const portalPoints = this.scoreBreakdown?.portal ?? 0;
        const label = portalCount === 1 ? 'event' : 'events';
        scorePortalsEl.textContent = `${portalCount} ${label} (+${this.formatPointValue(portalPoints)} pts)`;
      }
      if (scoreCombatEl) {
        const combatCount = this.combatScoreEvents ?? 0;
        const combatPoints = this.scoreBreakdown?.combat ?? 0;
        const label = combatCount === 1 ? 'victory' : 'victories';
        scoreCombatEl.textContent = `${combatCount} ${label} (+${this.formatPointValue(combatPoints)} pts)`;
      }
      if (scoreLootEl) {
        const lootCount = this.lootScoreEvents ?? 0;
        const lootPoints = this.scoreBreakdown?.loot ?? 0;
        const label = lootCount === 1 ? 'find' : 'finds';
        scoreLootEl.textContent = `${lootCount} ${label} (+${this.formatPointValue(lootPoints)} pts)`;
      }
      this.updateInventoryUi();
      this.updateDimensionInfoPanel();
      this.updatePortalProgress();
      this.updateFooterSummary();
      if (shouldPublish && typeof this.publishStateSnapshot === 'function') {
        this.publishStateSnapshot(reason);
      }
    }

    setPortalStatusIndicator(state, message, label) {
      const stateLabels = {
        inactive: 'Portal Dormant',
        building: 'Portal Stabilising',
        ready: 'Portal Ready',
        active: 'Portal Active',
        blocked: 'Portal Blocked',
        victory: 'Network Secured',
      };
      const nextState = state || 'inactive';
      const nextMessage = message || 'Portal dormant';
      const nextLabel = label || stateLabels[nextState] || 'Portal Status';
      const previousState = this.portalStatusState;
      const previousMessage = this.portalStatusMessage;
      const previousLabel = this.portalStatusLabel;
      if (
        previousState === nextState &&
        previousMessage === nextMessage &&
        previousLabel === nextLabel
      ) {
        return;
      }
      this.portalStatusState = nextState;
      this.portalStatusMessage = nextMessage;
      this.portalStatusLabel = nextLabel;
      const {
        portalStatusEl,
        portalStatusText,
        portalStatusStateText,
        portalStatusDetailText,
        portalStatusIcon,
      } = this.ui;
      if (portalStatusEl) {
        portalStatusEl.dataset.state = nextState;
        portalStatusEl.setAttribute('aria-label', `Portal status: ${nextLabel}. ${nextMessage}`);
        portalStatusEl.classList.remove('portal-status--flash');
        void portalStatusEl.offsetWidth;
        portalStatusEl.classList.add('portal-status--flash');
        const globalScope = typeof globalThis !== 'undefined' ? globalThis : undefined;
        const clearTimer =
          (typeof window !== 'undefined' ? window?.clearTimeout : undefined) ||
          globalScope?.clearTimeout ||
          clearTimeout;
        const setTimer =
          (typeof window !== 'undefined' ? window?.setTimeout : undefined) ||
          globalScope?.setTimeout ||
          setTimeout;
        if (typeof clearTimer === 'function' && typeof setTimer === 'function') {
          clearTimer(this.portalStatusFlashTimer);
          this.portalStatusFlashTimer = setTimer(() => {
            portalStatusEl.classList.remove('portal-status--flash');
            this.portalStatusFlashTimer = null;
          }, 620);
        }
      }
      if (portalStatusStateText) {
        portalStatusStateText.textContent = nextLabel;
      }
      if (portalStatusDetailText) {
        portalStatusDetailText.textContent = nextMessage;
      } else if (!portalStatusStateText && portalStatusText) {
        portalStatusText.textContent = nextMessage;
      } else if (portalStatusText && !portalStatusDetailText && portalStatusStateText) {
        portalStatusText.textContent = `${nextLabel}: ${nextMessage}`;
      }
      if (portalStatusIcon) {
        portalStatusIcon.dataset.state = nextState;
      }
      if (previousState !== nextState) {
        if (nextState === 'active' && typeof this.previewUpcomingDimension === 'function') {
          this.previewUpcomingDimension();
        }
        const audioController = this.audio;
        const canPlayAudio = audioController && typeof audioController.play === 'function';
        if (!canPlayAudio) {
          return;
        }
        if (nextState === 'active') {
          audioController.play('portalActivate', { volume: 0.7 });
        } else if (nextState === 'ready') {
          audioController.play('portalPrimed', { volume: 0.55 });
        } else if (nextState === 'building') {
          audioController.play('portalPrimed', { volume: 0.35 });
        } else if (nextState === 'blocked') {
          audioController.play('portalDormant', { volume: 0.45 });
        } else if (nextState === 'inactive' && previousState !== 'inactive') {
          audioController.play('portalDormant', { volume: 0.38 });
        } else if (previousState === 'active' && nextState !== 'victory') {
          audioController.play('portalDormant', { volume: 0.5 });
        }
      }
    }

    getPortalStatusSnapshot() {
      const obstructionState = this.refreshPortalObstructionState();
      const required = this.portalFrameRequiredCount || PORTAL_BLOCK_REQUIREMENT;
      const rawProgress = required > 0 ? this.portalBlocksPlaced / required : 0;
      const progress = Math.min(1, Math.max(0, rawProgress));
      const progressPercent = Math.round(progress * 100);
      const remainingBlocks = Math.max(0, Math.ceil(required - this.portalBlocksPlaced));
      const nextTheme = DIMENSION_THEME[this.currentDimensionIndex + 1] ?? null;
      const nextName = nextTheme?.name ?? null;
      const nextRulesSummary = nextTheme ? this.buildDimensionRuleSummary(nextTheme) : '';
      let statusState = 'inactive';
      let statusLabel = 'Portal Dormant';
      let statusMessage = remainingBlocks
        ? `${remainingBlocks} frame block${remainingBlocks === 1 ? '' : 's'} required to stabilise.`
        : 'Awaiting ignition sequence';
      let progressLabel = `Portal frame ${progressPercent}%`;
      if (this.victoryAchieved) {
        progressLabel = 'Eternal Ingot secured';
        statusState = 'victory';
        statusLabel = 'Network Secured';
        statusMessage = 'Eternal Ingot secured';
      } else if (this.netheriteChallengeActive && this.dimensionSettings?.id === 'netherite') {
        const seconds = Number.isFinite(this.netheriteCountdownDisplay)
          ? Math.max(0, this.netheriteCountdownDisplay)
          : Math.ceil(Math.max(0, this.netheriteCountdownSeconds - this.netheriteChallengeTimer));
        progressLabel = `Collapse in ${seconds}s`;
        statusState = 'active';
        statusLabel = 'Collapse Imminent';
        statusMessage = `Collapse in ${seconds}s`;
      } else if (this.portalActivated) {
        progressLabel = 'Portal stabilised';
        statusState = 'active';
        statusLabel = 'Portal Active';
        if (nextName) {
          statusMessage = `Next: ${nextName}${nextRulesSummary ? ` — ${nextRulesSummary}` : ''}`;
        } else {
          statusMessage = 'Gateway stabilised — return to base.';
        }
      } else if (this.portalReady) {
        progressLabel = 'Portal ready — press F to ignite';
        statusState = 'ready';
        statusLabel = 'Portal Ready';
        statusMessage = nextName
          ? `Ignite with F to access ${nextName}.`
          : 'Ignite with F to open the final gateway.';
      } else if (obstructionState.blocked && !this.portalActivated) {
        progressLabel = 'Clear the portal footprint';
        statusState = 'blocked';
        statusLabel = 'Portal Blocked';
        statusMessage = obstructionState.summary || 'Gateway occupied';
      } else if (!this.portalFrameFootprintValid && this.portalFrameValidationMessage) {
        progressLabel = 'Align the portal frame';
        statusState = 'blocked';
        statusLabel = 'Portal Frame Invalid';
        statusMessage = this.portalFrameValidationMessage;
      } else if (!this.portalFrameInteriorValid && this.portalBlocksPlaced > 0) {
        progressLabel = 'Clear the portal interior';
        statusState = 'blocked';
        statusLabel = 'Portal Blocked';
        statusMessage = 'Interior obstructed';
      } else if (progress > 0) {
        statusState = 'building';
        statusLabel = 'Portal Stabilising';
        statusMessage = `${progressPercent}% frame integrity`;
      }

      let displayProgress = this.victoryAchieved ? 1 : progress;
      if (this.portalReady && !this.portalActivated) {
        displayProgress = 1;
      } else if (obstructionState.blocked && !this.portalActivated) {
        displayProgress = Math.min(displayProgress, 0.5);
      } else if (
        !this.portalFrameFootprintValid &&
        !this.portalActivated &&
        this.portalFrameValidationMessage
      ) {
        displayProgress = Math.min(displayProgress, 0.5);
      } else if (!this.portalFrameInteriorValid && !this.portalActivated) {
        displayProgress = Math.min(displayProgress, 0.5);
      } else if (this.netheriteChallengeActive && this.dimensionSettings?.id === 'netherite') {
        const remaining = Math.max(0, this.netheriteCountdownSeconds - this.netheriteChallengeTimer);
        const fraction =
          this.netheriteCountdownSeconds > 0
            ? 1 - Math.min(1, remaining / this.netheriteCountdownSeconds)
            : 1;
        displayProgress = Math.max(displayProgress, fraction);
      }

      if (this.portalShaderFallbackActive && !this.victoryAchieved) {
        statusLabel = 'Portal Fallback';
        statusMessage = PORTAL_SHADER_FALLBACK_ANNOUNCEMENT;
        progressLabel = 'Portal fallback active';
      }

      return {
        progress,
        progressPercent,
        remainingBlocks,
        requiredBlocks: required,
        state: statusState,
        statusLabel,
        statusMessage,
        progressLabel,
        displayProgress,
        blocked: Boolean(obstructionState.blocked),
        obstructionSummary: obstructionState.summary || '',
        previewSummary: this.portalPreviewSummary
          ? { ...this.portalPreviewSummary }
          : null,
        nextDimension: nextName,
        nextRules: nextRulesSummary,
      };
    }

    updatePortalProgress() {
      const { portalProgressLabel, portalProgressBar } = this.ui;
      const snapshot = this.getPortalStatusSnapshot();
      if (portalProgressLabel && snapshot.progressLabel) {
        portalProgressLabel.textContent = snapshot.progressLabel;
      }
      this.setPortalStatusIndicator(snapshot.state, snapshot.statusMessage, snapshot.statusLabel);
      if (portalProgressBar && Number.isFinite(snapshot.displayProgress)) {
        portalProgressBar.style.setProperty('--progress', snapshot.displayProgress.toFixed(2));
      }
    }

    updateFooterSummary() {
      if (!this.footerEl) return;
      const scoreValue = Math.round(this.score ?? 0);
      if (this.footerScoreEl) {
        this.footerScoreEl.textContent = scoreValue.toLocaleString();
      }
      const currentTheme = this.dimensionSettings ?? DIMENSION_THEME[this.currentDimensionIndex] ?? null;
      const dimensionName = currentTheme?.name ?? 'Unknown Realm';
      if (this.footerDimensionEl) {
        this.footerDimensionEl.textContent = dimensionName;
      }
      let statusMessage = '';
      if (this.victoryAchieved) {
        statusMessage = 'Eternal Ingot secured — portals stabilised.';
      } else if (this.portalActivated) {
        const nextName = this.getNextDimensionName();
        statusMessage = nextName ? `Crossing to ${nextName}.` : 'Crossing to the next realm.';
      } else if (this.portalReady) {
        statusMessage = 'Portal ready — ignite with F to travel.';
      } else if (this.lastHintMessage) {
        statusMessage = this.lastHintMessage;
      } else if (currentTheme?.description) {
        statusMessage = currentTheme.description;
      } else {
        statusMessage = 'Stabilising the portal network.';
      }
      if (this.footerStatusEl) {
        this.footerStatusEl.textContent = statusMessage;
      }
      const state = this.victoryAchieved
        ? 'victory'
        : this.portalActivated
          ? 'transition'
          : this.portalReady
            ? 'ready'
            : 'explore';
      this.footerEl.dataset.state = state;
    }

    revealDimensionIntro(theme, options = {}) {
      const { dimensionIntroEl, dimensionIntroNameEl, dimensionIntroRulesEl } = this.ui;
      if (!dimensionIntroEl || !dimensionIntroNameEl || !dimensionIntroRulesEl) {
        return;
      }
      const timerHost = typeof window !== 'undefined' ? window : globalThis;
      timerHost.clearTimeout(this.dimensionIntroAutoHideTimer);
      timerHost.clearTimeout(this.dimensionIntroFadeTimer);
      const name = typeof theme?.name === 'string' && theme.name.trim() ? theme.name.trim() : 'Unknown Dimension';
      const intent = typeof options.intent === 'string' ? options.intent : 'arrival';
      const rules = this.buildDimensionRuleSummary(theme, options.rulesOverride);
      const heading =
        intent === 'preview'
          ? `Next: ${name}`
          : intent === 'arrival'
            ? `Entering ${name}`
            : name;
      const ruleLabel = intent === 'preview' ? 'Rules Preview' : 'Rules';
      dimensionIntroEl.dataset.intent = intent;
      dimensionIntroNameEl.textContent = heading;
      dimensionIntroRulesEl.textContent = `${ruleLabel}: ${rules}`;
      dimensionIntroEl.hidden = false;
      setInertState(dimensionIntroEl, false);
      activateOverlayIsolation(dimensionIntroEl);
      dimensionIntroEl.classList.remove('active');
      void dimensionIntroEl.offsetWidth;
      dimensionIntroEl.classList.add('active');
      const defaultDuration = intent === 'preview' ? 6400 : 5200;
      const duration = Number.isFinite(options.duration)
        ? Math.max(0, options.duration)
        : defaultDuration;
      if (duration > 0 && !this.prefersReducedMotion) {
        this.dimensionIntroAutoHideTimer = timerHost.setTimeout(() => {
          this.hideDimensionIntro();
        }, duration);
      }
    }

    hideDimensionIntro(immediate = false) {
      const { dimensionIntroEl } = this.ui;
      if (!dimensionIntroEl) {
        return;
      }
      const timerHost = typeof window !== 'undefined' ? window : globalThis;
      timerHost.clearTimeout(this.dimensionIntroAutoHideTimer);
      this.dimensionIntroAutoHideTimer = null;
      timerHost.clearTimeout(this.dimensionIntroFadeTimer);
      const finalize = () => {
        dimensionIntroEl.hidden = true;
        setInertState(dimensionIntroEl, true);
        dimensionIntroEl.dataset.intent = 'hidden';
        releaseOverlayIsolation(dimensionIntroEl);
      };
      if (immediate || this.prefersReducedMotion) {
        dimensionIntroEl.classList.remove('active');
        finalize();
        return;
      }
      dimensionIntroEl.classList.remove('active');
      this.dimensionIntroFadeTimer = timerHost.setTimeout(finalize, 360);
    }

    getNextDimensionName() {
      const nextTheme = DIMENSION_THEME[this.currentDimensionIndex + 1];
      return nextTheme?.name ?? null;
    }

    buildDimensionRuleSummary(theme, override) {
      if (override && typeof override === 'string' && override.trim()) {
        return override.trim();
      }
      if (!theme) {
        return 'Adapt quickly to the realm\'s rules to survive.';
      }
      const descriptors = [];
      const gravity = Number.isFinite(theme?.gravity) ? Number(theme.gravity).toFixed(2) : null;
      if (gravity) {
        descriptors.push(`Gravity ×${gravity}`);
      }
      const speed =
        Number.isFinite(theme?.speedMultiplier) && theme.speedMultiplier !== 1
          ? Number(theme.speedMultiplier).toFixed(2)
          : null;
      if (speed) {
        descriptors.push(`Speed ×${speed}`);
      }
      const extraRules = Array.isArray(theme?.rules)
        ? theme.rules.filter((rule) => typeof rule === 'string' && rule.trim()).map((rule) => rule.trim())
        : typeof theme?.rules === 'string' && theme.rules.trim()
          ? [theme.rules.trim()]
          : [];
      if (extraRules.length) {
        descriptors.push(...extraRules);
      }
      const description = typeof theme?.description === 'string' ? theme.description.trim() : '';
      if (descriptors.length && description) {
        return `${descriptors.join(' · ')} — ${description}`;
      }
      if (description) {
        return description;
      }
      if (descriptors.length) {
        return descriptors.join(' · ');
      }
      return 'Adapt quickly to the realm\'s rules to survive.';
    }

    previewUpcomingDimension() {
      if (this.victoryAchieved) {
        return;
      }
      const nextTheme = DIMENSION_THEME[this.currentDimensionIndex + 1];
      if (!nextTheme) {
        return;
      }
      const summary = this.buildDimensionRuleSummary(nextTheme);
      this.revealDimensionIntro(nextTheme, {
        intent: 'preview',
        duration: 6400,
        rulesOverride: summary,
      });
    }

    getDimensionInfoSnapshot() {
      const index = Math.max(0, this.currentDimensionIndex);
      const total = DIMENSION_THEME.length;
      if (this.victoryAchieved) {
        const rank = this.getPlayerLeaderboardRank();
        const totalRuns = Math.max(this.scoreEntries.length, rank ?? 0);
        const leaderboardLabel = rank
          ? `Rank #${rank} of ${Math.max(totalRuns, rank)}`
          : 'Unranked — connect to publish your run.';
        const scoreLabel = Math.round(this.score);
        return {
          name: 'Netherite Terminus',
          description: 'You stabilised every dimension and recovered the Eternal Ingot.',
          meta: `Score ${scoreLabel} · ${leaderboardLabel}`,
          index,
          total,
          victory: true,
          victoryDetails: {
            title: 'Netherite Terminus',
            message: 'You stabilised every dimension and recovered the Eternal Ingot.',
            meta: `Score ${scoreLabel} · ${leaderboardLabel}`,
            replayAvailable: true,
          },
        };
      }
      const theme = this.dimensionSettings ?? DIMENSION_THEME[index] ?? null;
      const name = theme?.name ?? 'Unknown Realm';
      const description = theme?.description ?? '';
      const gravityValue = Number.isFinite(theme?.gravity) ? Number(theme.gravity) : 1;
      const speedValue = Number.isFinite(theme?.speedMultiplier) ? Number(theme.speedMultiplier) : 1;
      let meta = `Gravity ×${gravityValue.toFixed(2)} · Speed ×${speedValue.toFixed(2)} · Dimension ${
        index + 1
      }/${total}`;
      let countdownSeconds = null;
      if (theme?.id === 'netherite' && !this.victoryAchieved) {
        if (this.netheriteChallengeActive && !this.eternalIngotCollected) {
          const seconds = Number.isFinite(this.netheriteCountdownDisplay)
            ? Math.max(0, this.netheriteCountdownDisplay)
            : Math.ceil(Math.max(0, this.netheriteCountdownSeconds - this.netheriteChallengeTimer));
          countdownSeconds = seconds;
          meta += ` · Collapse in ${seconds}s`;
        } else if (this.eternalIngotCollected) {
          meta += ' · Eternal Ingot secured';
        }
      }
      return {
        name,
        description,
        meta,
        index,
        total,
        victory: false,
        netherite: {
          challengeActive: Boolean(this.netheriteChallengeActive && theme?.id === 'netherite'),
          countdownSeconds,
          ingotCollected: Boolean(this.eternalIngotCollected),
        },
      };
    }

    updateDimensionInfoPanel() {
      const { dimensionInfoEl } = this.ui;
      if (!dimensionInfoEl) return;
      const snapshot = this.getDimensionInfoSnapshot();
      if (snapshot.victory && snapshot.victoryDetails) {
        dimensionInfoEl.innerHTML = `
          <h3>${snapshot.victoryDetails.title}</h3>
          <p>${snapshot.victoryDetails.message}</p>
          <p class="dimension-meta">${snapshot.victoryDetails.meta}</p>
          ${snapshot.victoryDetails.replayAvailable ? '<p><button type="button" class="victory-replay-button" data-action="replay-run">Replay Run</button></p>' : ''}
        `;
        return;
      }
      dimensionInfoEl.dataset.simpleInit = 'true';
      dimensionInfoEl.innerHTML = `
        <h3>${snapshot.name}</h3>
        <p>${snapshot.description ?? ''}</p>
        <p class="dimension-meta">${snapshot.meta ?? ''}</p>
      `;
    }

    showVictoryCelebration() {
      const doc = typeof document !== 'undefined' ? document : null;
      this.victorySummary = this.createRunSummary('victory');
      this.victoryCelebrationActive = true;
      this.victoryShareBusy = false;
      if (this.victoryCelebrationEl) {
        this.victoryCelebrationEl.hidden = false;
        setInertState(this.victoryCelebrationEl, false);
        activateOverlayIsolation(this.victoryCelebrationEl);
        this.victoryCelebrationEl.classList.remove('active');
        void this.victoryCelebrationEl.offsetWidth;
        this.victoryCelebrationEl.classList.add('active');
      }
      if (doc?.body) {
        doc.body.classList.add('victory-celebration-active');
      }
      if (this.victoryShareStatusEl) {
        this.victoryShareStatusEl.textContent = '';
      }
      if (this.victoryShareButton) {
        this.victoryShareButton.disabled = false;
        this.victoryShareButton.removeAttribute('aria-busy');
      }
      if (this.victoryCloseButton) {
        this.victoryCloseButton.disabled = false;
      }
      this.clearVictoryEffectTimers();
      this.prepareVictoryEffects();
      this.updateVictoryCelebrationStats();
      if (typeof requestAnimationFrame === 'function' && this.victoryShareButton?.focus) {
        requestAnimationFrame(() => {
          try {
            this.victoryShareButton.focus({ preventScroll: true });
          } catch (error) {
            // Ignore focus issues if the browser prevents it.
          }
        });
      }
      this.updateFooterSummary();
    }

    hideVictoryCelebration(immediate = false) {
      const doc = typeof document !== 'undefined' ? document : null;
      if (!this.victoryCelebrationEl) {
        this.victoryCelebrationActive = false;
        return;
      }
      this.victoryCelebrationActive = false;
      this.clearVictoryEffectTimers();
      this.victoryCelebrationEl.classList.remove('active');
      setInertState(this.victoryCelebrationEl, true);
      const finalize = () => {
        this.victoryCelebrationEl.hidden = true;
        releaseOverlayIsolation(this.victoryCelebrationEl);
        if (this.victoryConfettiEl) {
          this.victoryConfettiEl.innerHTML = '';
        }
        if (this.victoryFireworksEl) {
          this.victoryFireworksEl.innerHTML = '';
        }
        this.focusGameViewport();
      };
      if (this.victoryHideTimer) {
        clearTimeout(this.victoryHideTimer);
        this.victoryHideTimer = null;
      }
      if (immediate) {
        finalize();
      } else {
        this.victoryHideTimer = setTimeout(finalize, 360);
      }
      if (this.victoryShareStatusEl) {
        this.victoryShareStatusEl.textContent = '';
      }
      if (this.victoryShareButton) {
        this.victoryShareButton.disabled = false;
        this.victoryShareButton.removeAttribute('aria-busy');
      }
      if (doc?.body) {
        doc.body.classList.remove('victory-celebration-active');
      }
      this.updateFooterSummary();
    }

    clearVictoryEffectTimers() {
      if (Array.isArray(this.victoryEffectTimers) && this.victoryEffectTimers.length) {
        this.victoryEffectTimers.forEach((timer) => clearTimeout(timer));
      }
      this.victoryEffectTimers = [];
    }

    prepareVictoryEffects() {
      if (this.prefersReducedMotion) {
        if (this.victoryConfettiEl) {
          this.victoryConfettiEl.innerHTML = '';
        }
        if (this.victoryFireworksEl) {
          this.victoryFireworksEl.innerHTML = '';
        }
        return;
      }
      const doc = typeof document !== 'undefined' ? document : null;
      if (!doc) {
        return;
      }
      if (this.victoryConfettiEl) {
        this.victoryConfettiEl.innerHTML = '';
        const colors = ['#f7b333', '#78f2ff', '#ff5e8b', '#7bff85', '#b19cff'];
        const pieces = 42;
        for (let i = 0; i < pieces; i += 1) {
          const piece = doc.createElement('div');
          piece.className = 'victory-confetti__piece';
          const color = colors[i % colors.length];
          piece.style.setProperty('--x', `${Math.random() * 100}%`);
          piece.style.setProperty('--offset-x', `${(Math.random() - 0.5) * 40}vw`);
          piece.style.setProperty('--rotation', `${Math.floor(Math.random() * 540) - 180}deg`);
          piece.style.setProperty('--duration', `${(2.4 + Math.random() * 1.4).toFixed(2)}s`);
          piece.style.setProperty('--delay', `${(Math.random() * 0.8).toFixed(2)}s`);
          piece.style.setProperty('--color', color);
          this.victoryConfettiEl.appendChild(piece);
        }
      }
      if (this.victoryFireworksEl) {
        this.victoryFireworksEl.innerHTML = '';
        const bursts = 3;
        for (let i = 0; i < bursts; i += 1) {
          const firework = doc.createElement('div');
          firework.className = 'victory-firework';
          firework.style.setProperty('--left', `${20 + Math.random() * 60}%`);
          firework.style.setProperty('--duration', `${(1.6 + Math.random() * 0.6).toFixed(2)}s`);
          firework.style.setProperty('--delay', `${(0.35 * i).toFixed(2)}s`);
          firework.style.setProperty('--travel', `${(-35 - Math.random() * 28).toFixed(2)}vh`);
          firework.style.setProperty('--hue', `${Math.floor(Math.random() * 360)}`);
          const burst = doc.createElement('div');
          burst.className = 'victory-firework__burst';
          firework.appendChild(burst);
          this.victoryFireworksEl.appendChild(firework);
          const timer = setTimeout(() => {
            firework.classList.add('burst');
          }, 550 + Math.random() * 420 + i * 140);
          this.victoryEffectTimers.push(timer);
        }
      }
    }

    updateVictoryCelebrationStats() {
      if (!this.victoryCelebrationActive) {
        return;
      }
      const summary = { ...(this.victorySummary || this.createRunSummary('victory')) };
      summary.score = Math.round(this.score ?? summary.score ?? 0);
      summary.dimensionCount = Math.min(DIMENSION_THEME.length, this.currentDimensionIndex + 1);
      summary.dimensionTotal = DIMENSION_THEME.length;
      summary.runTimeSeconds = Math.round(this.elapsed ?? summary.runTimeSeconds ?? 0);
      summary.recipeCount = this.craftedRecipes?.size ?? summary.recipeCount ?? 0;
      summary.dimensionLabel = this.dimensionSettings?.name ?? summary.dimensionLabel;
      this.victorySummary = summary;
      const rank = this.getPlayerLeaderboardRank();
      const formatRunTime = this.scoreboardUtils?.formatRunTime
        ? (seconds) => this.scoreboardUtils.formatRunTime(seconds)
        : (seconds) => {
            const total = Math.max(0, Math.round(seconds ?? 0));
            const minutes = Math.floor(total / 60);
            const secs = total % 60;
            const pad = (value) => String(value).padStart(2, '0');
            return `${pad(minutes)}:${pad(secs)}`;
          };
      if (this.victoryStatsEl) {
        const stats = [
          { label: 'Final Score', value: summary.score.toLocaleString() },
          {
            label: 'Dimensions Stabilised',
            value: `${summary.dimensionCount}/${summary.dimensionTotal}`,
          },
          { label: 'Recipes Crafted', value: Number(summary.recipeCount || 0).toLocaleString() },
          { label: 'Run Time', value: formatRunTime(summary.runTimeSeconds) },
          { label: 'Leaderboard Rank', value: rank ? `#${rank}` : 'Offline' },
        ];
        const breakdown = this.getScoreBreakdownSnapshot();
        const formatBreakdownValue = (value) =>
          this.formatPointValue
            ? this.formatPointValue(value)
            : Math.max(0, Number(value) || 0).toLocaleString();
        if (breakdown.dimensions !== undefined) {
          stats.push({ label: 'Dimension Score', value: formatBreakdownValue(breakdown.dimensions) });
        }
        if (breakdown.recipes !== undefined) {
          stats.push({ label: 'Crafting Score', value: formatBreakdownValue(breakdown.recipes) });
        }
        if (breakdown.portal !== undefined) {
          const portalCount = this.portalScoreEvents ?? 0;
          const label = portalCount === 1 ? 'Portal Event' : 'Portal Events';
          stats.push({
            label,
            value: `${portalCount.toLocaleString()} • ${formatBreakdownValue(breakdown.portal)} pts`,
          });
        }
        if (breakdown.combat !== undefined) {
          const combatCount = this.combatScoreEvents ?? 0;
          const label = combatCount === 1 ? 'Combat Victory' : 'Combat Victories';
          stats.push({
            label,
            value: `${combatCount.toLocaleString()} • ${formatBreakdownValue(breakdown.combat)} pts`,
          });
        }
        if (breakdown.loot !== undefined) {
          const lootCount = this.lootScoreEvents ?? 0;
          const label = lootCount === 1 ? 'Loot Find' : 'Loot Finds';
          stats.push({
            label,
            value: `${lootCount.toLocaleString()} • ${formatBreakdownValue(breakdown.loot)} pts`,
          });
        }
        if (breakdown.penalties) {
          stats.push({ label: 'Penalties', value: `-${formatBreakdownValue(breakdown.penalties)}` });
        }
        const statsMarkup = stats
          .map(
            (stat) => `
          <div>
            <dt>${escapeHtml(stat.label)}</dt>
            <dd>${escapeHtml(String(stat.value))}</dd>
          </div>
        `,
          )
          .join('');
        this.victoryStatsEl.innerHTML = statsMarkup;
      }
      if (this.victoryMessageEl) {
        const dimensionText = summary.dimensionCount === 1 ? 'dimension' : 'dimensions';
        const rankMessage = rank
          ? `Rank #${rank} on the current leaderboard.`
          : this.apiBaseUrl
            ? 'Sign in to publish your run to the leaderboard.'
            : 'Connect to the leaderboard to publish your run.';
        this.victoryMessageEl.textContent = `You stabilised ${summary.dimensionCount} ${dimensionText} and recovered the Eternal Ingot. ${rankMessage}`;
      }
      if (this.victoryBannerEl?.classList.contains('visible')) {
        const bannerMessage = rank
          ? `Score ${summary.score.toLocaleString()} · Rank #${rank}`
          : `Score ${summary.score.toLocaleString()} · Offline run`;
        this.victoryBannerEl.innerHTML = `
          <h3>Victory</h3>
          <p>${escapeHtml(bannerMessage)}</p>
        `;
      }
    }

    handleVictoryClose(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      this.hideVictoryCelebration();
      this.hideVictoryBanner();
      this.showHint('Celebration closed — continue exploring!');
      try {
        this.canvas?.focus({ preventScroll: true });
      } catch (error) {
        // Ignore focus errors in browsers that block programmatic focus.
      }
      this.updatePointerHintForInputMode();
    }

    async handleVictoryShare(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }
      if (this.victoryShareBusy) {
        return;
      }
      this.victoryShareBusy = true;
      this.updateVictoryCelebrationStats();
      const summary = { ...(this.victorySummary || this.createRunSummary('victory')) };
      const rank = this.getPlayerLeaderboardRank();
      const formatRunTime = this.scoreboardUtils?.formatRunTime
        ? (seconds) => this.scoreboardUtils.formatRunTime(seconds)
        : (seconds) => {
            const total = Math.max(0, Math.round(seconds ?? 0));
            const minutes = Math.floor(total / 60);
            const secs = total % 60;
            const pad = (value) => String(value).padStart(2, '0');
            return `${pad(minutes)}:${pad(secs)}`;
          };
      const baseLines = [
        `Secured the Eternal Ingot in Infinite Rails with ${summary.score.toLocaleString()} points!`,
        `Stabilised ${summary.dimensionCount}/${summary.dimensionTotal} dimensions in ${formatRunTime(summary.runTimeSeconds)}.`,
        rank ? `Current leaderboard rank: #${rank}.` : 'Offline run — connect to publish your rank.',
      ];
      const shareUrl = typeof window !== 'undefined' && window.location ? window.location.href : '';
      const shareText = baseLines.join(' ');
      const clipboardText = shareUrl ? `${shareText}\n${shareUrl}` : shareText;
      const nav = typeof navigator !== 'undefined' ? navigator : null;
      let statusMessage = '';
      if (this.victoryShareButton) {
        this.victoryShareButton.disabled = true;
        this.victoryShareButton.setAttribute('aria-busy', 'true');
      }
      try {
        if (nav?.share) {
          const payload = { title: 'Infinite Rails Victory', text: shareText };
          if (shareUrl) {
            payload.url = shareUrl;
          }
          const canShare = typeof nav.canShare === 'function' ? nav.canShare(payload) : true;
          if (canShare) {
            await nav.share(payload);
            statusMessage = 'Shared your victory!';
          }
        }
        if (!statusMessage && nav?.clipboard?.writeText) {
          await nav.clipboard.writeText(clipboardText);
          statusMessage = 'Copied run summary to clipboard.';
        }
        if (!statusMessage) {
          if (typeof window !== 'undefined' && typeof window.prompt === 'function') {
            window.prompt('Copy your Infinite Rails victory summary:', clipboardText);
            statusMessage = 'Share unsupported — summary ready to copy.';
          } else {
            statusMessage = `Share unsupported — copy this summary: ${clipboardText}`;
          }
        }
        this.scheduleScoreSync('victory-share');
      } catch (error) {
        if (error?.name === 'AbortError') {
          statusMessage = 'Share cancelled.';
        } else {
          console.warn('Victory share failed', error);
          statusMessage = 'Share failed — copy your summary manually.';
        }
      } finally {
        if (this.victoryShareButton) {
          this.victoryShareButton.disabled = false;
          this.victoryShareButton.removeAttribute('aria-busy');
        }
        this.victoryShareBusy = false;
      }
      if (statusMessage) {
        if (this.victoryShareStatusEl) {
          this.victoryShareStatusEl.textContent = statusMessage;
        } else {
          this.showHint(statusMessage);
        }
      }
      this.updateFooterSummary();
    }

    showVictoryBanner(message) {
      if (!this.victoryBannerEl) return;
      const text = typeof message === 'string' && message.trim().length
        ? message.trim()
        : 'Victory achieved — Eternal Ingot secured!';
      this.victoryBannerEl.innerHTML = `
        <h3>Victory</h3>
        <p>${escapeHtml(text)}</p>
      `;
      this.victoryBannerEl.classList.add('visible');
    }

    hideVictoryBanner() {
      if (!this.victoryBannerEl) return;
      this.victoryBannerEl.classList.remove('visible');
      this.victoryBannerEl.innerHTML = '';
    }

    exposeDebugInterface() {
      if (typeof window === 'undefined') {
        return;
      }
      const scope = window;
      scope.__INFINITE_RAILS_ACTIVE_EXPERIENCE__ = this;
      scope.__INFINITE_RAILS_DEBUG__ = {
        experience: this,
        getSnapshot: () => this.getDebugSnapshot(),
        forceNight: (seconds) => this.forceNightCycle(seconds),
        spawnZombieWave: (count) => this.debugSpawnZombieWave(count),
        completePortalFrame: () => this.debugCompletePortalFrame(),
        ignitePortal: (tool) => this.debugIgnitePortal(tool),
        advanceDimension: () => this.debugAdvanceDimension(),
        assetLoads: (limit) => this.getAssetLoadLog(limit),
        setVerboseMode: (enabled) => {
          const controls = scope.InfiniteRails?.debug;
          if (controls && typeof controls.setEnabled === 'function') {
            controls.setEnabled(Boolean(enabled), { source: 'debug-interface' });
            return true;
          }
          return false;
        },
        enableVerboseMode: () => {
          const controls = scope.InfiniteRails?.debug;
          if (controls && typeof controls.setEnabled === 'function') {
            controls.setEnabled(true, { source: 'debug-interface' });
            return true;
          }
          return false;
        },
        disableVerboseMode: () => {
          const controls = scope.InfiniteRails?.debug;
          if (controls && typeof controls.setEnabled === 'function') {
            controls.setEnabled(false, { source: 'debug-interface' });
            return true;
          }
          return false;
        },
        toggleVerboseMode: () => {
          const controls = scope.InfiniteRails?.debug;
          if (controls && typeof controls.toggle === 'function') {
            controls.toggle({ source: 'debug-interface' });
            return true;
          }
          if (controls && typeof controls.setEnabled === 'function' && typeof controls.isEnabled === 'function') {
            try {
              const current = Boolean(controls.isEnabled());
              controls.setEnabled(!current, { source: 'debug-interface' });
              return true;
            } catch (error) {
              console.debug('Verbose mode toggle failed', error);
            }
          }
          return false;
        },
        isVerboseModeEnabled: () => {
          const controls = scope.InfiniteRails?.debug;
          if (controls && typeof controls.isEnabled === 'function') {
            try {
              return Boolean(controls.isEnabled());
            } catch (error) {
              console.debug('Verbose mode probe failed', error);
            }
          }
          return false;
        },
      };
      try {
        scope.dispatchEvent(
          new CustomEvent('infinite-rails:started', {
            detail: {
              mode: 'simple',
              timestamp: Date.now(),
            },
          }),
        );
      } catch (error) {
        console.debug('Debug event dispatch failed', error);
      }
    }

    createWorldSnapshot() {
      if (!Array.isArray(this.heightMap)) {
        return [];
      }
      return this.heightMap.map((row) => (Array.isArray(row) ? row.slice() : []));
    }

    publishStateSnapshot(reason = 'update') {
      if (typeof window === 'undefined') {
        return;
      }
      const scope = window;
      const score = this.getScoreSnapshot();
      const portal = this.getPortalStatusSnapshot();
      const dimension = this.getDimensionInfoSnapshot();
      const player = this.getPlayerStatusSnapshot();
      const signature = this.buildStateSignature({ score, portal, dimension, player });
      if (reason === 'frame' && signature === this.lastPublishedStateSignature) {
        return;
      }
      this.lastPublishedStateSignature = signature;
      const world = this.createWorldSnapshot();
      const daylight = Number.isFinite(this.daylightIntensity)
        ? Math.max(0, Math.min(1, this.daylightIntensity))
        : 0;
      const state = {
        isRunning: Boolean(this.started && !this.rendererUnavailable),
        rendererMode: scope.__INFINITE_RAILS_RENDERER_MODE__ || null,
        world,
        dimension,
        portal,
        score,
        player,
        daylight,
        reason,
        updatedAt: Date.now(),
        signature,
      };
      scope.__INFINITE_RAILS_STATE__ = state;
      if (typeof scope.dispatchEvent === 'function') {
        try {
          scope.dispatchEvent(new CustomEvent('infinite-rails:state', { detail: state }));
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Failed to dispatch state snapshot event.', error);
          }
        }
      }
    }

    buildStateSignature(components = {}) {
      const score = components.score || {};
      const breakdown = score.breakdown || {};
      const sortedBreakdown = Object.keys(breakdown)
        .sort()
        .map((key) => `${key}:${Number.isFinite(breakdown[key]) ? Number(breakdown[key]) : 0}`)
        .join(',');
      const portal = components.portal || {};
      const dimension = components.dimension || {};
      const player = components.player || {};
      return [
        Number.isFinite(score.total) ? Math.round(score.total) : 0,
        Number.isFinite(score.craftingEvents) ? score.craftingEvents : 0,
        Number.isFinite(score.dimensionEvents) ? score.dimensionEvents : 0,
        Number.isFinite(score.portalEvents) ? score.portalEvents : 0,
        Number.isFinite(score.combatEvents) ? score.combatEvents : 0,
        Number.isFinite(score.lootEvents) ? score.lootEvents : 0,
        sortedBreakdown,
        Number.isFinite(player.health) ? player.health : 0,
        dimension.name ?? '',
        Number.isFinite(dimension.index) ? dimension.index : 0,
        dimension.meta ?? '',
        dimension.victory ? 'victory' : '',
        portal.state ?? '',
        portal.statusLabel ?? '',
        portal.progressLabel ?? '',
        portal.statusMessage ?? '',
        Number.isFinite(portal.displayProgress) ? portal.displayProgress.toFixed(2) : '',
        Number.isFinite(portal.remainingBlocks) ? portal.remainingBlocks : '',
      ].join('|');
    }

    getDeveloperMetrics() {
      const stats = this.frameStats || {};
      const fps = Number.isFinite(stats.fps) ? stats.fps : 0;
      const models = this.loadedModels instanceof Map ? this.loadedModels.size : 0;
      const textures = this.textureCache instanceof Map ? this.textureCache.size : 0;
      let audio = 0;
      if (this.audio && typeof this.audio.getLoadedSampleCount === 'function') {
        try {
          audio = this.audio.getLoadedSampleCount();
        } catch (error) {
          audio = 0;
        }
      }
      const assets = {
        pending: this.assetRecoveryPendingKeys instanceof Set ? this.assetRecoveryPendingKeys.size : 0,
        failures: this.assetFailureCounts instanceof Map ? this.assetFailureCounts.size : 0,
      };
      const scene = {
        sceneChildren: Array.isArray(this.scene?.children) ? this.scene.children.length : 0,
        worldChildren: Array.isArray(this.worldRoot?.children) ? this.worldRoot.children.length : 0,
        terrainMeshes: Array.isArray(this.terrainGroup?.children) ? this.terrainGroup.children.length : 0,
        actorCount:
          (Array.isArray(this.zombies) ? this.zombies.length : 0) +
          (Array.isArray(this.golems) ? this.golems.length : 0),
      };
      return {
        fps,
        models,
        textures,
        audio,
        assets,
        scene,
      };
    }

    getDebugSnapshot() {
      const sceneChildCount = Array.isArray(this.scene?.children) ? this.scene.children.length : 0;
      const worldChildCount = Array.isArray(this.worldRoot?.children) ? this.worldRoot.children.length : 0;
      return {
        started: this.started,
        dimension: this.dimensionSettings?.name ?? null,
        dimensionIndex: this.currentDimensionIndex,
        voxelColumns: this.columns?.size ?? 0,
        portalReady: Boolean(this.portalReady),
        portalActivated: Boolean(this.portalActivated),
        zombieCount: Array.isArray(this.zombies) ? this.zombies.length : 0,
        golemCount: Array.isArray(this.golems) ? this.golems.length : 0,
        score: Math.round(this.score ?? 0),
        hotbarSlots: Array.isArray(this.hotbar) ? this.hotbar.length : 0,
        hotbarExpanded: Boolean(this.hotbarExpanded),
        sceneChildren: Math.max(sceneChildCount, worldChildCount),
        hudActive:
          typeof document !== 'undefined' ? document.body.classList.contains('game-active') : false,
        netheriteChallengeActive: Boolean(this.netheriteChallengeActive),
        netheriteCountdown: Math.max(0, Math.ceil(Math.max(0, this.netheriteCountdownSeconds - this.netheriteChallengeTimer))),
        eternalIngotCollected: Boolean(this.eternalIngotCollected),
        daylight: this.daylightIntensity ?? 0,
        assetLoadsRecent: this.getAssetLoadLog(5),
        assetFailures: Array.from(this.assetFailureCounts.entries()),
        assetRecoveryPending: Array.from(this.assetRecoveryPendingKeys),
        assetRecoveryPromptActive: Boolean(this.assetRecoveryPromptActive),
        zombieAi: this.getZombieAIDiagnostics(),
      };
    }

    getZombieAIDiagnostics() {
      const spawnInterval = ZOMBIE_SPAWN_INTERVAL;
      const contactRange = ZOMBIE_CONTACT_RANGE;
      const maxPerDimension = ZOMBIE_MAX_PER_DIMENSION;
      const zombies = Array.isArray(this.zombies) ? this.zombies : [];
      const navigationMeshes = this.navigationMeshes instanceof Map ? this.navigationMeshes : null;
      const navigationSummary = this.navigationMeshSummary || null;
      const activeChunks = new Set();
      const details = [];
      const playerBounds = this.getPlayerPhysicsBounds();
      const playerPosition = playerBounds?.position ?? null;
      for (const zombie of zombies) {
        const chunkKey =
          zombie.navChunkKey ??
          (zombie.mesh?.position
            ? this.getChunkKeyForWorldPosition(zombie.mesh.position.x, zombie.mesh.position.z)
            : null);
        if (chunkKey) {
          activeChunks.add(chunkKey);
        }
        let distanceToPlayer = null;
        if (playerPosition && zombie.mesh?.position?.distanceTo) {
          const distance = zombie.mesh.position.distanceTo(playerPosition);
          if (Number.isFinite(distance)) {
            distanceToPlayer = Number(distance.toFixed(2));
          }
        }
        let lastAttackAgo = null;
        if (Number.isFinite(this.elapsed) && Number.isFinite(zombie.lastAttack)) {
          const delta = this.elapsed - zombie.lastAttack;
          if (Number.isFinite(delta)) {
            lastAttackAgo = Number(delta.toFixed(2));
          }
        }
        details.push({
          id: zombie.id,
          chunk: chunkKey,
          distanceToPlayer,
          lastAttackAgo,
          speed: zombie.speed,
          spawnedAt: zombie.spawnedAt ?? null,
        });
      }
      let timeSinceLastSpawn = null;
      if (Number.isFinite(this.elapsed) && Number.isFinite(this.lastZombieSpawn)) {
        const delta = this.elapsed - this.lastZombieSpawn;
        if (Number.isFinite(delta)) {
          timeSinceLastSpawn = Number(delta.toFixed(2));
        }
      }
      return {
        spawnInterval,
        contactRange,
        maxPerDimension,
        isNight: this.isNight(),
        activeCount: zombies.length,
        lastSpawnAt: this.lastZombieSpawn ?? null,
        timeSinceLastSpawn,
        navigation: {
          chunksTracked: navigationMeshes ? navigationMeshes.size : 0,
          activeChunks: Array.from(activeChunks),
          summary: navigationSummary
            ? {
                chunkCount: navigationSummary.chunkCount ?? 0,
                walkableCells: navigationSummary.walkableCells ?? 0,
                updatedAt: navigationSummary.updatedAt ?? 0,
                reason: navigationSummary.reason ?? null,
              }
            : null,
        },
        zombies: details,
      };
    }

    forceNightCycle(seconds = DAY_LENGTH_SECONDS * 0.75) {
      if (!Number.isFinite(seconds)) {
        seconds = DAY_LENGTH_SECONDS * 0.75;
      }
      this.elapsed = seconds % DAY_LENGTH_SECONDS;
      this.updateDayNightCycle();
      this.lastZombieSpawn = this.elapsed - ZOMBIE_SPAWN_INTERVAL - 0.1;
      return this.daylightIntensity;
    }

    debugSpawnZombieWave(count = 1) {
      const total = Math.max(1, Math.floor(count));
      if (!this.isNight()) {
        this.forceNightCycle();
      }
      let spawned = 0;
      for (let i = 0; i < total; i += 1) {
        if (this.zombies.length >= ZOMBIE_MAX_PER_DIMENSION) {
          break;
        }
        this.spawnZombie();
        spawned += 1;
        this.elapsed += 0.05;
      }
      return spawned;
    }

    debugCompletePortalFrame() {
      if (!this.portalFrameSlots?.size) {
        this.resetPortalFrameState();
      }
      this.portalFrameSlots.forEach((slot) => {
        slot.filled = true;
      });
      this.portalBlocksPlaced = this.portalFrameSlots.size;
      this.portalFrameInteriorValid = true;
      this.portalFrameFootprintValid = true;
      this.portalFrameValidationMessage = '';
      this.highlightPortalFrameIssues([]);
      this.portalFootprintObstructed = false;
      this.portalFootprintObstructionSummary = '';
      this.portalDebugBypassObstructions = true;
      this.checkPortalActivation();
      return this.portalReady;
    }

    debugIgnitePortal(tool = 'torch') {
      if (!this.portalReady) {
        this.debugCompletePortalFrame();
      }
      if (!this.portalActivated) {
        this.ignitePortal(tool);
      }
      return this.portalActivated;
    }

    async debugAdvanceDimension() {
      const previousIndex = this.currentDimensionIndex;
      if (!this.portalActivated) {
        this.debugIgnitePortal();
      }
      if (!this.portalActivated) {
        return false;
      }
      await this.advanceDimension();
      return this.currentDimensionIndex !== previousIndex;
    }
  }

  function createSimpleExperience(options) {
    const experience = new SimpleExperience(options);
    activeSimpleExperiences.add(experience);
    const originalDestroy =
      typeof experience.destroy === 'function' ? experience.destroy.bind(experience) : null;
    experience.destroy = (...args) => {
      try {
        return originalDestroy ? originalDestroy(...args) : undefined;
      } finally {
        activeSimpleExperiences.delete(experience);
      }
    };
    applyControlMapToExperience(experience, simpleExperienceControlMap.get());
    return experience;
  }

  window.SimpleExperience = {
    create: createSimpleExperience,
    destroyAll() {
      const instances = Array.from(activeSimpleExperiences);
      instances.forEach((instance) => {
        try {
          instance.destroy?.();
        } catch (error) {
          if (typeof console !== 'undefined' && typeof console.debug === 'function') {
            console.debug('Failed to destroy SimpleExperience instance.', error);
          }
        }
      });
      activeSimpleExperiences.clear();
    },
    controlMap: simpleExperienceControlMap,
    dimensionManifest: DIMENSION_ASSET_MANIFEST,
    dimensionThemes: DIMENSION_THEME,
    dimensionLootTables: DIMENSION_LOOT_TABLES,
    terrainProfiles: DIMENSION_TERRAIN_PROFILES,
    defaultTerrainProfile: DEFAULT_TERRAIN_PROFILE,
  };

  if (typeof module !== 'undefined' && module.exports) {
    const exported = window.SimpleExperience;
    module.exports = exported;
    if (typeof Object.defineProperty === 'function') {
      Object.defineProperty(module.exports, 'default', {
        value: exported,
        enumerable: false,
        configurable: true,
        writable: true,
      });
      Object.defineProperty(module.exports, '__esModule', {
        value: true,
        enumerable: false,
        configurable: true,
      });
      Object.defineProperty(module.exports, 'SimpleExperience', {
        value: exported,
        enumerable: false,
        configurable: true,
        writable: true,
      });
    } else {
      module.exports.default = exported;
      module.exports.__esModule = true;
      module.exports.SimpleExperience = exported;
    }
  }
})();
